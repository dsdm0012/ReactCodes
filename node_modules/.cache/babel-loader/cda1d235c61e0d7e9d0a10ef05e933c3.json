{"ast":null,"code":"/* eslint consistent-return:0 */\n'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar ParticipantSignaling = require('./participant');\n\nvar RoomSignaling = require('./room');\n\nvar StateMachine = require('../statemachine');\n/*\nSignaling States\n----------------\n\n              +---------+\n              |         |\n              | opening |\n         +--->|         |\n         |    +---------+\n    +--------+   |   |   +------+\n    |        |<--+   +-->|      |\n    | closed |<----------| open |\n    |        |<--+   +-->|      |\n    +--------+   |   |   +------+\n              +---------+   |\n              |         |<--+\n              | closing |\n              |         |\n              +---------+\n\n*/\n\n\nvar states = {\n  closed: ['opening'],\n  opening: ['closed', 'open'],\n  open: ['closed', 'closing'],\n  closing: ['closed', 'open']\n};\n/**\n * @extends StateMachine\n * @property {string} state - one of \"closed\", \"opening\", \"open\", or \"closing\"\n */\n\nvar Signaling =\n/** @class */\nfunction (_super) {\n  __extends(Signaling, _super);\n  /**\n   * Construct {@link Signaling}.\n   */\n\n\n  function Signaling() {\n    return _super.call(this, 'closed', states) || this;\n  }\n  /**\n   * @private\n   */\n  // NOTE(mroberts): This is a dummy implementation suitable for testing.\n\n\n  Signaling.prototype._close = function (key) {\n    this.transition('closing', key);\n    this.transition('closed', key);\n    return Promise.resolve(this);\n  };\n  /**\n   * @private\n   */\n  // NOTE(mroberts): This is a dummy implementation suitable for testing.\n\n\n  Signaling.prototype._connect = function (localParticipant, token, encodingParameters, preferredCodecs, options) {\n    localParticipant.connect('PA00000000000000000000000000000000', 'test');\n    var sid = 'RM00000000000000000000000000000000';\n    var promise = Promise.resolve(new RoomSignaling(localParticipant, sid, options));\n\n    promise.cancel = function cancel() {};\n\n    return promise;\n  };\n  /**\n   * @private\n   */\n  // NOTE(mroberts): This is a dummy implementation suitable for testing.\n\n\n  Signaling.prototype._open = function (key) {\n    this.transition('opening', key);\n    this.transition('open', key);\n    return Promise.resolve(this);\n  };\n  /**\n   * Close the {@link Signaling}.\n   * @returns {Promise<this>}\n   */\n\n\n  Signaling.prototype.close = function () {\n    var _this = this;\n\n    return this.bracket('close', function (key) {\n      switch (_this.state) {\n        case 'closed':\n          return _this;\n\n        case 'open':\n          return _this._close(key);\n\n        default:\n          throw new Error(\"Unexpected Signaling state \\\"\" + _this.state + \"\\\"\");\n      }\n    });\n  };\n  /**\n   * Connect to a {@link RoomSignaling}.\n   * @param {ParticipantSignaling} localParticipant\n   * @param {string} token\n   * @param {EncodingParametersImpl} encodingParameters\n   * @param {PreferredCodecs} preferredCodecs\n   * @param {object} options\n   * @returns {Promise<function(): CancelablePromise<RoomSignaling>>}\n   */\n\n\n  Signaling.prototype.connect = function (localParticipant, token, encodingParameters, preferredCodecs, options) {\n    var self = this;\n    return this.bracket('connect', function transition(key) {\n      switch (self.state) {\n        case 'closed':\n          return self._open(key).then(transition.bind(null, key));\n\n        case 'open':\n          // NOTE(mroberts): We don't need to hold the lock in _connect. Instead,\n          // we just need to ensure the Signaling remains open.\n          self.releaseLockCompletely(key);\n          return self._connect(localParticipant, token, encodingParameters, preferredCodecs, options);\n\n        default:\n          throw new Error(\"Unexpected Signaling state \\\"\" + self.state + \"\\\"\");\n      }\n    });\n  };\n  /**\n   * Create a local {@link ParticipantSignaling}.\n   * @returns {ParticipantSignaling}\n   */\n\n\n  Signaling.prototype.createLocalParticipantSignaling = function () {\n    return new ParticipantSignaling();\n  };\n  /**\n   * Open the {@link Signaling}.\n   * @returns {Promise<this>}\n   */\n\n\n  Signaling.prototype.open = function () {\n    var _this = this;\n\n    return this.bracket('open', function (key) {\n      switch (_this.state) {\n        case 'closed':\n          return _this._open(key);\n\n        case 'open':\n          return _this;\n\n        default:\n          throw new Error(\"Unexpected Signaling state \\\"\" + _this.state + \"\\\"\");\n      }\n    });\n  };\n\n  return Signaling;\n}(StateMachine);\n\nmodule.exports = Signaling;","map":null,"metadata":{},"sourceType":"script"}