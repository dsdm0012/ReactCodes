{"ast":null,"code":"/* eslint-disable no-console */\n'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar DominantSpeakerSignaling = require('./dominantspeakersignaling');\n\nvar NetworkQualityMonitor = require('./networkqualitymonitor');\n\nvar NetworkQualitySignaling = require('./networkqualitysignaling');\n\nvar RecordingV2 = require('./recording');\n\nvar RoomSignaling = require('../room');\n\nvar RemoteParticipantV2 = require('./remoteparticipant');\n\nvar StatsReport = require('../../stats/statsreport');\n\nvar TrackPrioritySignaling = require('./trackprioritysignaling');\n\nvar TrackSwitchOffSignaling = require('./trackswitchoffsignaling');\n\nvar RenderHintsSignaling = require('./renderhintssignaling');\n\nvar PublisherHintsSignaling = require('./publisherhintsignaling.js');\n\nvar _a = require('../../util'),\n    DEFAULT_SESSION_TIMEOUT_SEC = _a.constants.DEFAULT_SESSION_TIMEOUT_SEC,\n    createBandwidthProfilePayload = _a.createBandwidthProfilePayload,\n    defer = _a.defer,\n    difference = _a.difference,\n    filterObject = _a.filterObject,\n    flatMap = _a.flatMap,\n    oncePerTick = _a.oncePerTick;\n\nvar MovingAverageDelta = require('../../util/movingaveragedelta');\n\nvar createTwilioError = require('../../util/twilio-video-errors').createTwilioError;\n\nvar STATS_PUBLISH_INTERVAL_MS = 10000;\n/**\n * @extends RoomSignaling\n */\n\nvar RoomV2 =\n/** @class */\nfunction (_super) {\n  __extends(RoomV2, _super);\n\n  function RoomV2(localParticipant, initialState, transport, peerConnectionManager, options) {\n    var _this = this;\n\n    initialState.options = Object.assign({\n      session_timeout: DEFAULT_SESSION_TIMEOUT_SEC\n    }, initialState.options);\n    options = Object.assign({\n      DominantSpeakerSignaling: DominantSpeakerSignaling,\n      NetworkQualityMonitor: NetworkQualityMonitor,\n      NetworkQualitySignaling: NetworkQualitySignaling,\n      RecordingSignaling: RecordingV2,\n      RemoteParticipantV2: RemoteParticipantV2,\n      TrackPrioritySignaling: TrackPrioritySignaling,\n      TrackSwitchOffSignaling: TrackSwitchOffSignaling,\n      bandwidthProfile: null,\n      sessionTimeout: initialState.options.session_timeout * 1000,\n      statsPublishIntervalMs: STATS_PUBLISH_INTERVAL_MS\n    }, options);\n    localParticipant.setBandwidthProfile(options.bandwidthProfile);\n    peerConnectionManager.setIceReconnectTimeout(options.sessionTimeout);\n    _this = _super.call(this, localParticipant, initialState.sid, initialState.name, options) || this;\n\n    var getTrackReceiver = function getTrackReceiver(id) {\n      return _this._getTrackReceiver(id);\n    };\n\n    var log = _this._log;\n    Object.defineProperties(_this, {\n      _disconnectedParticipantRevisions: {\n        value: new Map()\n      },\n      _NetworkQualityMonitor: {\n        value: options.NetworkQualityMonitor\n      },\n      _lastBandwidthProfileRevision: {\n        value: localParticipant.bandwidthProfileRevision,\n        writable: true\n      },\n      _networkQualityMonitor: {\n        value: null,\n        writable: true\n      },\n      _networkQualityConfiguration: {\n        value: localParticipant.networkQualityConfiguration\n      },\n      _peerConnectionManager: {\n        value: peerConnectionManager\n      },\n      _published: {\n        value: new Map()\n      },\n      _publishedRevision: {\n        value: 0,\n        writable: true\n      },\n      _RemoteParticipantV2: {\n        value: options.RemoteParticipantV2\n      },\n      _subscribed: {\n        value: new Map()\n      },\n      _subscribedRevision: {\n        value: 0,\n        writable: true\n      },\n      _subscriptionFailures: {\n        value: new Map()\n      },\n      _dominantSpeakerSignaling: {\n        value: new options.DominantSpeakerSignaling(getTrackReceiver, {\n          log: log\n        })\n      },\n      _networkQualitySignaling: {\n        value: new options.NetworkQualitySignaling(getTrackReceiver, localParticipant.networkQualityConfiguration, {\n          log: log\n        })\n      },\n      _renderHintsSignaling: {\n        value: new RenderHintsSignaling(getTrackReceiver, {\n          log: log\n        })\n      },\n      _publisherHintsSignaling: {\n        value: new PublisherHintsSignaling(getTrackReceiver, {\n          log: log\n        })\n      },\n      _trackPrioritySignaling: {\n        value: new options.TrackPrioritySignaling(getTrackReceiver, {\n          log: log\n        })\n      },\n      _trackSwitchOffSignaling: {\n        value: new options.TrackSwitchOffSignaling(getTrackReceiver, {\n          log: log\n        })\n      },\n      _pendingSwitchOffStates: {\n        value: new Map()\n      },\n      _transport: {\n        value: transport\n      },\n      _trackReceiverDeferreds: {\n        value: new Map()\n      },\n      mediaRegion: {\n        enumerable: true,\n        value: initialState.options.media_region || null\n      }\n    });\n\n    _this._initTrackSwitchOffSignaling();\n\n    _this._initDominantSpeakerSignaling();\n\n    _this._initNetworkQualityMonitorSignaling();\n\n    _this._initPublisherHintSignaling();\n\n    handleLocalParticipantEvents(_this, localParticipant);\n    handlePeerConnectionEvents(_this, peerConnectionManager);\n    handleTransportEvents(_this, transport);\n    periodicallyPublishStats(_this, transport, options.statsPublishIntervalMs);\n\n    _this._update(initialState); // NOTE(mpatwardhan) after initial state we know if publisher_hints are enabled or not\n    // if they are not enabled. we need to undo simulcast that if it was enabled with initial offer.\n\n\n    _this._peerConnectionManager.setEffectiveAdaptiveSimulcast(_this._publisherHintsSignaling.isSetup);\n\n    return _this;\n  }\n\n  Object.defineProperty(RoomV2.prototype, \"connectionState\", {\n    /**\n     * The PeerConnection state.\n     * @property {RTCPeerConnectionState}\n     */\n    get: function get() {\n      return this._peerConnectionManager.connectionState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RoomV2.prototype, \"signalingConnectionState\", {\n    /**\n     * The Signaling Connection State.\n     * @property {string} - \"connected\", \"reconnecting\", \"disconnected\"\n     */\n    get: function get() {\n      return this._transport.state === 'syncing' ? 'reconnecting' : this._transport.state;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RoomV2.prototype, \"iceConnectionState\", {\n    /**\n     * The Ice Connection State.\n     * @property {RTCIceConnectionState}\n     */\n    get: function get() {\n      return this._peerConnectionManager.iceConnectionState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * @private\n   */\n\n  RoomV2.prototype._deleteTrackReceiverDeferred = function (id) {\n    return this._trackReceiverDeferreds.delete(id);\n  };\n  /**\n   * @private\n   */\n\n\n  RoomV2.prototype._getOrCreateTrackReceiverDeferred = function (id) {\n    var deferred = this._trackReceiverDeferreds.get(id) || defer();\n\n    var trackReceivers = this._peerConnectionManager.getTrackReceivers(); // NOTE(mmalavalli): In Firefox, there can be instances where a MediaStreamTrack\n    // for the given Track ID already exists, for example, when a Track is removed\n    // and added back. If that is the case, then we should resolve 'deferred'.\n\n\n    var trackReceiver = trackReceivers.find(function (trackReceiver) {\n      return trackReceiver.id === id && trackReceiver.readyState !== 'ended';\n    });\n\n    if (trackReceiver) {\n      deferred.resolve(trackReceiver);\n    } else {\n      // NOTE(mmalavalli): Only add the 'deferred' to the map if it's not\n      // resolved. This will prevent old copies of the MediaStreamTrack from\n      // being used when the remote peer removes and re-adds a MediaStreamTrack.\n      this._trackReceiverDeferreds.set(id, deferred);\n    }\n\n    return deferred;\n  };\n  /**\n   * @private\n   */\n\n\n  RoomV2.prototype._addTrackReceiver = function (trackReceiver) {\n    var deferred = this._getOrCreateTrackReceiverDeferred(trackReceiver.id);\n\n    deferred.resolve(trackReceiver);\n    return this;\n  };\n  /**\n   * @private\n   */\n\n\n  RoomV2.prototype._disconnect = function (error) {\n    var didDisconnect = _super.prototype._disconnect.call(this, error);\n\n    if (didDisconnect) {\n      this._teardownNetworkQualityMonitor();\n\n      this._transport.disconnect();\n\n      this._peerConnectionManager.close();\n    }\n\n    this.localParticipant.tracks.forEach(function (track) {\n      track.publishFailed(error || new Error('LocalParticipant disconnected'));\n    });\n    return didDisconnect;\n  };\n  /**\n   * @private\n   */\n\n\n  RoomV2.prototype._getTrackReceiver = function (id) {\n    var _this = this;\n\n    return this._getOrCreateTrackReceiverDeferred(id).promise.then(function (trackReceiver) {\n      _this._deleteTrackReceiverDeferred(id);\n\n      return trackReceiver;\n    });\n  };\n  /**\n   * @private\n   */\n\n\n  RoomV2.prototype._getInitialTrackSwitchOffState = function (trackSid) {\n    var initiallySwitchedOff = this._pendingSwitchOffStates.get(trackSid) || false;\n\n    this._pendingSwitchOffStates.delete(trackSid);\n\n    if (initiallySwitchedOff) {\n      this._log.warn(\"[\" + trackSid + \"] was initially switched off! \");\n    }\n\n    return initiallySwitchedOff;\n  };\n  /**\n   * @private\n   */\n\n\n  RoomV2.prototype._getTrackSidsToTrackSignalings = function () {\n    var trackSidsToTrackSignalings = flatMap(this.participants, function (participant) {\n      return Array.from(participant.tracks);\n    });\n    return new Map(trackSidsToTrackSignalings);\n  };\n  /**\n   * @private\n   */\n\n\n  RoomV2.prototype._getOrCreateRemoteParticipant = function (participantState) {\n    var _this = this;\n\n    var RemoteParticipantV2 = this._RemoteParticipantV2;\n    var participant = this.participants.get(participantState.sid);\n    var self = this;\n\n    if (!participant) {\n      participant = new RemoteParticipantV2(participantState, function (trackSid) {\n        return _this._getInitialTrackSwitchOffState(trackSid);\n      }, function (trackSid, priority) {\n        return _this._trackPrioritySignaling.sendTrackPriorityUpdate(trackSid, 'subscribe', priority);\n      }, function (trackSid, hint) {\n        return _this._renderHintsSignaling.setTrackHint(trackSid, hint);\n      }, function (trackSid) {\n        return _this._renderHintsSignaling.clearTrackHint(trackSid);\n      });\n      participant.on('stateChanged', function stateChanged(state) {\n        if (state === 'disconnected') {\n          participant.removeListener('stateChanged', stateChanged);\n          self.participants.delete(participant.sid);\n\n          self._disconnectedParticipantRevisions.set(participant.sid, participant.revision);\n        }\n      });\n      this.connectParticipant(participant);\n    }\n\n    return participant;\n  };\n  /**\n   * @private\n   */\n\n\n  RoomV2.prototype._getState = function () {\n    return {\n      participant: this.localParticipant.getState()\n    };\n  };\n  /**\n   * @private\n   */\n\n\n  RoomV2.prototype._maybeAddBandwidthProfile = function (update) {\n    var _a = this.localParticipant,\n        bandwidthProfile = _a.bandwidthProfile,\n        bandwidthProfileRevision = _a.bandwidthProfileRevision;\n\n    if (bandwidthProfile && this._lastBandwidthProfileRevision < bandwidthProfileRevision) {\n      this._lastBandwidthProfileRevision = bandwidthProfileRevision;\n      return Object.assign({\n        bandwidth_profile: createBandwidthProfilePayload(bandwidthProfile)\n      }, update);\n    }\n\n    return update;\n  };\n  /**\n   * @private\n   */\n\n\n  RoomV2.prototype._publishNewLocalParticipantState = function () {\n    this._transport.publish(this._maybeAddBandwidthProfile(this._getState()));\n  };\n  /**\n   * @private\n   */\n\n\n  RoomV2.prototype._publishPeerConnectionState = function (peerConnectionState) {\n    /* eslint camelcase:0 */\n    this._transport.publish(Object.assign({\n      peer_connections: [peerConnectionState]\n    }, this._getState()));\n  };\n  /**\n   * @private\n   */\n\n\n  RoomV2.prototype._update = function (roomState) {\n    var _this = this;\n\n    if (roomState.subscribed && roomState.subscribed.revision > this._subscribedRevision) {\n      this._subscribedRevision = roomState.subscribed.revision;\n      roomState.subscribed.tracks.forEach(function (trackState) {\n        if (trackState.id) {\n          _this._subscriptionFailures.delete(trackState.sid);\n\n          _this._subscribed.set(trackState.sid, trackState.id);\n        } else if (trackState.error && !_this._subscriptionFailures.has(trackState.sid)) {\n          _this._subscriptionFailures.set(trackState.sid, trackState.error);\n        }\n      });\n      var subscribedTrackSids_1 = new Set(roomState.subscribed.tracks.filter(function (trackState) {\n        return !!trackState.id;\n      }).map(function (trackState) {\n        return trackState.sid;\n      }));\n\n      this._subscribed.forEach(function (trackId, trackSid) {\n        if (!subscribedTrackSids_1.has(trackSid)) {\n          _this._subscribed.delete(trackSid);\n        }\n      });\n    }\n\n    var participantsToKeep = new Set(); // eslint-disable-next-line no-warning-comments\n    // TODO(mroberts): Remove me once the Server is fixed.\n\n    (roomState.participants || []).forEach(function (participantState) {\n      if (participantState.sid === _this.localParticipant.sid) {\n        return;\n      } // NOTE(mmalavalli): If the incoming revision for a disconnected Participant is less than or\n      // equal to the revision when it was disconnected, then the state is old and can be ignored.\n      // Otherwise, the Participant was most likely disconnected in a Large Group Room when it\n      // stopped publishing media, and hence needs to be re-added.\n\n\n      var disconnectedParticipantRevision = _this._disconnectedParticipantRevisions.get(participantState.sid);\n\n      if (disconnectedParticipantRevision && participantState.revision <= disconnectedParticipantRevision) {\n        return;\n      }\n\n      if (disconnectedParticipantRevision) {\n        _this._disconnectedParticipantRevisions.delete(participantState.sid);\n      }\n\n      var participant = _this._getOrCreateRemoteParticipant(participantState);\n\n      participant.update(participantState);\n      participantsToKeep.add(participant);\n    });\n\n    if (roomState.type === 'synced') {\n      this.participants.forEach(function (participant) {\n        if (!participantsToKeep.has(participant)) {\n          participant.disconnect();\n        }\n      });\n    }\n\n    handleSubscriptions(this); // eslint-disable-next-line no-warning-comments\n    // TODO(mroberts): Remove me once the Server is fixed.\n\n    /* eslint camelcase:0 */\n\n    if (roomState.peer_connections) {\n      this._peerConnectionManager.update(roomState.peer_connections, roomState.type === 'synced');\n    }\n\n    if (roomState.recording) {\n      this.recording.update(roomState.recording);\n    }\n\n    if (roomState.published && roomState.published.revision > this._publishedRevision) {\n      this._publishedRevision = roomState.published.revision;\n      roomState.published.tracks.forEach(function (track) {\n        if (track.sid) {\n          _this._published.set(track.id, track.sid);\n        }\n      });\n      this.localParticipant.update(roomState.published);\n    }\n\n    if (roomState.participant) {\n      this.localParticipant.connect(roomState.participant.sid, roomState.participant.identity);\n    }\n\n    [this._dominantSpeakerSignaling, this._networkQualitySignaling, this._trackPrioritySignaling, this._trackSwitchOffSignaling, this._renderHintsSignaling, this._publisherHintsSignaling].forEach(function (mediaSignaling) {\n      var channel = mediaSignaling.channel;\n\n      if (!mediaSignaling.isSetup && roomState.media_signaling && roomState.media_signaling[channel] && roomState.media_signaling[channel].transport && roomState.media_signaling[channel].transport.type === 'data-channel') {\n        mediaSignaling.setup(roomState.media_signaling[channel].transport.label);\n      }\n    });\n    return this;\n  };\n\n  RoomV2.prototype._initPublisherHintSignaling = function () {\n    var _this = this;\n\n    this._publisherHintsSignaling.on('updated', function (hints, id) {\n      Promise.all(hints.map(function (hint) {\n        return _this.localParticipant.setPublisherHint(hint.track, hint.encodings).then(function (result) {\n          return {\n            track: hint.track,\n            result: result\n          };\n        });\n      })).then(function (hintResponses) {\n        _this._publisherHintsSignaling.sendHintResponse({\n          id: id,\n          hints: hintResponses\n        });\n      });\n    });\n\n    var handleReplaced = function handleReplaced(track) {\n      if (track.kind === 'video') {\n        track.trackTransceiver.on('replaced', function () {\n          _this._publisherHintsSignaling.sendTrackReplaced({\n            trackSid: track.sid\n          });\n        });\n      }\n    }; // hook up for any existing and new tracks getting replaced.\n\n\n    Array.from(this.localParticipant.tracks.values()).forEach(function (track) {\n      return handleReplaced(track);\n    });\n    this.localParticipant.on('trackAdded', function (track) {\n      return handleReplaced(track);\n    });\n  };\n\n  RoomV2.prototype._initTrackSwitchOffSignaling = function () {\n    var _this = this;\n\n    this._trackSwitchOffSignaling.on('updated', function (tracksOff, tracksOn) {\n      try {\n        _this._log.debug('received trackSwitch: ', {\n          tracksOn: tracksOn,\n          tracksOff: tracksOff\n        });\n\n        var trackUpdates_1 = new Map();\n        tracksOn.forEach(function (trackSid) {\n          return trackUpdates_1.set(trackSid, true);\n        });\n        tracksOff.forEach(function (trackSid) {\n          if (trackUpdates_1.get(trackSid)) {\n            // NOTE(mpatwardhan): This means that VIDEO-3762 has been reproduced.\n            _this._log.warn(trackSid + \" is DUPLICATED in both tracksOff and tracksOn list\");\n          }\n\n          trackUpdates_1.set(trackSid, false);\n        });\n\n        _this.participants.forEach(function (participant) {\n          participant.tracks.forEach(function (track) {\n            var isOn = trackUpdates_1.get(track.sid);\n\n            if (typeof isOn !== 'undefined') {\n              track.setSwitchedOff(!isOn);\n              trackUpdates_1.delete(track.sid);\n            }\n          });\n        }); // NOTE(mpatwardhan): Cache any notification about the tracks that we do not yet know about.\n\n\n        trackUpdates_1.forEach(function (isOn, trackSid) {\n          return _this._pendingSwitchOffStates.set(trackSid, !isOn);\n        });\n      } catch (ex) {\n        _this._log.error('error processing track switch off:', ex);\n      }\n    });\n  };\n\n  RoomV2.prototype._initDominantSpeakerSignaling = function () {\n    var _this = this;\n\n    this._dominantSpeakerSignaling.on('updated', function () {\n      return _this.setDominantSpeaker(_this._dominantSpeakerSignaling.loudestParticipantSid);\n    });\n  };\n\n  RoomV2.prototype._initNetworkQualityMonitorSignaling = function () {\n    var _this = this;\n\n    this._networkQualitySignaling.on('ready', function () {\n      var networkQualityMonitor = new _this._NetworkQualityMonitor(_this._peerConnectionManager, _this._networkQualitySignaling);\n      _this._networkQualityMonitor = networkQualityMonitor;\n      networkQualityMonitor.on('updated', function () {\n        if (_this.iceConnectionState === 'failed') {\n          return;\n        }\n\n        _this.localParticipant.setNetworkQualityLevel(networkQualityMonitor.level, networkQualityMonitor.levels);\n\n        _this.participants.forEach(function (participant) {\n          var levels = networkQualityMonitor.remoteLevels.get(participant.sid);\n\n          if (levels) {\n            participant.setNetworkQualityLevel(levels.level, levels);\n          }\n        });\n      });\n      networkQualityMonitor.start();\n    });\n\n    this._networkQualitySignaling.on('teardown', function () {\n      return _this._teardownNetworkQualityMonitor();\n    });\n  };\n\n  RoomV2.prototype._teardownNetworkQualityMonitor = function () {\n    if (this._networkQualityMonitor) {\n      this._networkQualityMonitor.stop();\n\n      this._networkQualityMonitor = null;\n    }\n  };\n  /**\n   * Get the {@link RoomV2}'s media statistics.\n   * @returns {Promise.<Map<PeerConnectionV2#id, StandardizedStatsResponse>>}\n   */\n\n\n  RoomV2.prototype.getStats = function () {\n    var _this = this;\n\n    return this._peerConnectionManager.getStats().then(function (responses) {\n      return new Map(Array.from(responses).map(function (_a) {\n        var _b = __read(_a, 2),\n            id = _b[0],\n            response = _b[1];\n\n        return [id, Object.assign({}, response, {\n          localAudioTrackStats: filterAndAddLocalTrackSids(_this, response.localAudioTrackStats),\n          localVideoTrackStats: filterAndAddLocalTrackSids(_this, response.localVideoTrackStats),\n          remoteAudioTrackStats: filterAndAddRemoteTrackSids(_this, response.remoteAudioTrackStats),\n          remoteVideoTrackStats: filterAndAddRemoteTrackSids(_this, response.remoteVideoTrackStats)\n        })];\n      }));\n    });\n  };\n\n  return RoomV2;\n}(RoomSignaling);\n/**\n * Filter out {@link TrackStats} that aren't in the collection while also\n * stamping their Track SIDs.\n * @param {Map<ID, SID>} idToSid\n * @param {Array<TrackStats>} trackStats\n * @returns {Array<TrackStats>}\n */\n\n\nfunction filterAndAddTrackSids(idToSid, trackStats) {\n  return trackStats.reduce(function (trackStats, trackStat) {\n    var trackSid = idToSid.get(trackStat.trackId);\n    return trackSid ? [Object.assign({}, trackStat, {\n      trackSid: trackSid\n    })].concat(trackStats) : trackStats;\n  }, []);\n}\n/**\n * Filter out {@link LocalTrackStats} that aren't currently published while also\n * stamping their Track SIDs.\n * @param {RoomV2} roomV2\n * @param {Array<LocalTrackStats>} localTrackStats\n * @returns {Array<LocalTrackStats>}\n */\n\n\nfunction filterAndAddLocalTrackSids(roomV2, localTrackStats) {\n  return filterAndAddTrackSids(roomV2._published, localTrackStats);\n}\n/**\n * Filter out {@link RemoteTrackStats} that aren't currently subscribed while\n * also stamping their Track SIDs.\n * @param {RoomV2} roomV2\n * @param {Array<RemoteTrackStats>} remoteTrackStats\n * @returns {Array<RemoteTrackStats>}\n */\n\n\nfunction filterAndAddRemoteTrackSids(roomV2, remoteTrackStats) {\n  var idToSid = new Map(Array.from(roomV2._subscribed.entries()).map(function (_a) {\n    var _b = __read(_a, 2),\n        sid = _b[0],\n        id = _b[1];\n\n    return [id, sid];\n  }));\n  return filterAndAddTrackSids(idToSid, remoteTrackStats);\n}\n/**\n * @typedef {object} RoomV2#Representation\n * @property {string} name\n * @property {LocalParticipantV2#Representation} participant\n * @property {?Array<RemoteParticipantV2#Representation>} participants\n * @property {?Array<PeerConnectionV2#Representation>} peer_connections\n * @property {?RecordingV2#Representation} recording\n * @property {string} sid\n */\n\n\nfunction handleLocalParticipantEvents(roomV2, localParticipant) {\n  var localParticipantUpdated = oncePerTick(function () {\n    roomV2._publishNewLocalParticipantState();\n  });\n  var renegotiate = oncePerTick(function () {\n    var trackSenders = flatMap(localParticipant.tracks, function (trackV2) {\n      return trackV2.trackTransceiver;\n    });\n\n    roomV2._peerConnectionManager.setTrackSenders(trackSenders);\n  });\n  localParticipant.on('trackAdded', renegotiate);\n  localParticipant.on('trackRemoved', renegotiate);\n  localParticipant.on('updated', localParticipantUpdated);\n  roomV2.on('stateChanged', function stateChanged(state) {\n    if (state === 'disconnected') {\n      localParticipant.removeListener('trackAdded', renegotiate);\n      localParticipant.removeListener('trackRemoved', renegotiate);\n      localParticipant.removeListener('updated', localParticipantUpdated);\n      roomV2.removeListener('stateChanged', stateChanged);\n      localParticipant.disconnect();\n    }\n  });\n  roomV2.on('signalingConnectionStateChanged', function () {\n    var localParticipant = roomV2.localParticipant,\n        signalingConnectionState = roomV2.signalingConnectionState;\n    var identity = localParticipant.identity,\n        sid = localParticipant.sid;\n\n    switch (signalingConnectionState) {\n      case 'connected':\n        localParticipant.connect(sid, identity);\n        break;\n\n      case 'reconnecting':\n        localParticipant.reconnecting();\n        break;\n    }\n  });\n}\n\nfunction handlePeerConnectionEvents(roomV2, peerConnectionManager) {\n  peerConnectionManager.on('description', function onDescription(description) {\n    roomV2._publishPeerConnectionState(description);\n  });\n  peerConnectionManager.dequeue('description');\n  peerConnectionManager.on('candidates', function onCandidates(candidates) {\n    roomV2._publishPeerConnectionState(candidates);\n  });\n  peerConnectionManager.dequeue('candidates');\n  peerConnectionManager.on('trackAdded', roomV2._addTrackReceiver.bind(roomV2));\n  peerConnectionManager.dequeue('trackAdded');\n  peerConnectionManager.getTrackReceivers().forEach(roomV2._addTrackReceiver, roomV2);\n  peerConnectionManager.on('connectionStateChanged', function () {\n    roomV2.emit('connectionStateChanged');\n  });\n  peerConnectionManager.on('iceConnectionStateChanged', function () {\n    roomV2.emit('iceConnectionStateChanged');\n\n    if (roomV2.iceConnectionState === 'failed') {\n      if (roomV2.localParticipant.networkQualityLevel !== null) {\n        roomV2.localParticipant.setNetworkQualityLevel(0);\n      }\n\n      roomV2.participants.forEach(function (participant) {\n        if (participant.networkQualityLevel !== null) {\n          participant.setNetworkQualityLevel(0);\n        }\n      });\n    }\n  });\n}\n\nfunction handleTransportEvents(roomV2, transport) {\n  transport.on('message', roomV2._update.bind(roomV2));\n  transport.on('stateChanged', function stateChanged(state, error) {\n    if (state === 'disconnected') {\n      if (roomV2.state !== 'disconnected') {\n        roomV2._disconnect(error);\n      }\n\n      transport.removeListener('stateChanged', stateChanged);\n    }\n\n    roomV2.emit('signalingConnectionStateChanged');\n  });\n}\n/**\n * Periodically publish {@link StatsReport}s.\n * @private\n * @param {RoomV2} roomV2\n * @param {Transport} transport\n * @param {Number} intervalMs\n */\n\n\nfunction periodicallyPublishStats(roomV2, transport, intervalMs) {\n  var movingAverageDeltas = new Map();\n  var oddPublishCount = false;\n  var interval = setInterval(function () {\n    roomV2.getStats().then(function (stats) {\n      oddPublishCount = !oddPublishCount;\n      stats.forEach(function (response, id) {\n        // NOTE(mmalavalli): A StatsReport is used to publish a \"stats-report\"\n        // event instead of using StandardizedStatsResponse directly because\n        // StatsReport will add zeros to properties that do not exist.\n        var report = new StatsReport(id, response, true\n        /* prepareForInsights */\n        ); // NOTE(mmalavalli): Since A/V sync metrics are not part of the StatsReport class,\n        // we add them to the insights payload here.\n\n        transport.publishEvent('quality', 'stats-report', 'info', {\n          audioTrackStats: report.remoteAudioTrackStats.map(function (trackStat, i) {\n            return addAVSyncMetricsToRemoteTrackStats(trackStat, response.remoteAudioTrackStats[i], movingAverageDeltas);\n          }),\n          localAudioTrackStats: report.localAudioTrackStats.map(function (trackStat, i) {\n            return addAVSyncMetricsToLocalTrackStats(trackStat, response.localAudioTrackStats[i], movingAverageDeltas);\n          }),\n          localVideoTrackStats: report.localVideoTrackStats.map(function (trackStat, i) {\n            return addAVSyncMetricsToLocalTrackStats(trackStat, response.localVideoTrackStats[i], movingAverageDeltas);\n          }),\n          peerConnectionId: report.peerConnectionId,\n          videoTrackStats: report.remoteVideoTrackStats.map(function (trackStat, i) {\n            return addAVSyncMetricsToRemoteTrackStats(trackStat, response.remoteVideoTrackStats[i], movingAverageDeltas);\n          })\n        }); // NOTE(mmalavalli): Clean up entries for Tracks that are no longer published or subscribed to.\n\n        var keys = flatMap(['localAudioTrackStats', 'localVideoTrackStats', 'remoteAudioTrackStats', 'remoteVideoTrackStats'], function (prop) {\n          return report[prop].map(function (_a) {\n            var ssrc = _a.ssrc,\n                trackSid = _a.trackSid;\n            return trackSid + \"+\" + ssrc;\n          });\n        });\n        var movingAverageDeltaKeysToBeRemoved = difference(Array.from(movingAverageDeltas.keys()), keys);\n        movingAverageDeltaKeysToBeRemoved.forEach(function (key) {\n          return movingAverageDeltas.delete(key);\n        });\n\n        if (oddPublishCount) {\n          // NOTE(mmalavalli): null properties of the \"active-ice-candidate-pair\"\n          // payload are assigned default values until the Insights gateway\n          // accepts null values.\n          var activeIceCandidatePair = replaceNullsWithDefaults(response.activeIceCandidatePair, report.peerConnectionId);\n          transport.publishEvent('quality', 'active-ice-candidate-pair', 'info', activeIceCandidatePair);\n        }\n      });\n    }, function () {// Do nothing.\n    });\n  }, intervalMs);\n  roomV2.on('stateChanged', function onStateChanged(state) {\n    if (state === 'disconnected') {\n      clearInterval(interval);\n      roomV2.removeListener('stateChanged', onStateChanged);\n    }\n  });\n}\n\nfunction handleSubscriptions(room) {\n  var trackSidsToTrackSignalings = room._getTrackSidsToTrackSignalings();\n\n  room._subscriptionFailures.forEach(function (error, trackSid) {\n    var trackSignaling = trackSidsToTrackSignalings.get(trackSid);\n\n    if (trackSignaling) {\n      room._subscriptionFailures.delete(trackSid);\n\n      trackSignaling.subscribeFailed(createTwilioError(error.code, error.message));\n    }\n  });\n\n  trackSidsToTrackSignalings.forEach(function (trackSignaling) {\n    var trackId = room._subscribed.get(trackSignaling.sid);\n\n    if (!trackId || trackSignaling.isSubscribed && trackSignaling.trackTransceiver.id !== trackId) {\n      trackSignaling.setTrackTransceiver(null);\n    }\n\n    if (trackId) {\n      room._getTrackReceiver(trackId).then(function (trackReceiver) {\n        return trackSignaling.setTrackTransceiver(trackReceiver);\n      });\n    }\n  });\n}\n/**\n * NOTE(mmalavalli): Since A/V sync metrics are not part of the public StatsReport class, we add them\n * only for reporting purposes.\n * @private\n */\n\n\nfunction addAVSyncMetricsToLocalTrackStats(trackStats, trackResponse, movingAverageDeltas) {\n  var framesEncoded = trackResponse.framesEncoded,\n      packetsSent = trackResponse.packetsSent,\n      totalEncodeTime = trackResponse.totalEncodeTime,\n      totalPacketSendDelay = trackResponse.totalPacketSendDelay;\n  var augmentedTrackStats = Object.assign({}, trackStats);\n  var key = trackStats.trackSid + \"+\" + trackStats.ssrc;\n  var trackMovingAverageDeltas = movingAverageDeltas.get(key) || new Map();\n\n  if (typeof totalEncodeTime === 'number' && typeof framesEncoded === 'number') {\n    var trackAvgEncodeDelayMovingAverageDelta = trackMovingAverageDeltas.get('avgEncodeDelay') || new MovingAverageDelta();\n    trackAvgEncodeDelayMovingAverageDelta.putSample(totalEncodeTime * 1000, framesEncoded);\n    augmentedTrackStats.avgEncodeDelay = Math.round(trackAvgEncodeDelayMovingAverageDelta.get());\n    trackMovingAverageDeltas.set('avgEncodeDelay', trackAvgEncodeDelayMovingAverageDelta);\n  }\n\n  if (typeof totalPacketSendDelay === 'number' && typeof packetsSent === 'number') {\n    var trackAvgPacketSendDelayMovingAverageDelta = trackMovingAverageDeltas.get('avgPacketSendDelay') || new MovingAverageDelta();\n    trackAvgPacketSendDelayMovingAverageDelta.putSample(totalPacketSendDelay * 1000, packetsSent);\n    augmentedTrackStats.avgPacketSendDelay = Math.round(trackAvgPacketSendDelayMovingAverageDelta.get());\n    trackMovingAverageDeltas.set('avgPacketSendDelay', trackAvgPacketSendDelayMovingAverageDelta);\n  }\n\n  movingAverageDeltas.set(key, trackMovingAverageDeltas);\n  return augmentedTrackStats;\n}\n/**\n * NOTE(mmalavalli): Since A/V sync metrics are not part of the public StatsReport class, we add them\n * only for reporting purposes.\n * @private\n */\n\n\nfunction addAVSyncMetricsToRemoteTrackStats(trackStats, trackResponse, movingAverageDeltas) {\n  var estimatedPlayoutTimestamp = trackResponse.estimatedPlayoutTimestamp,\n      framesDecoded = trackResponse.framesDecoded,\n      jitterBufferDelay = trackResponse.jitterBufferDelay,\n      jitterBufferEmittedCount = trackResponse.jitterBufferEmittedCount,\n      totalDecodeTime = trackResponse.totalDecodeTime;\n  var augmentedTrackStats = Object.assign({}, trackStats);\n  var key = trackStats.trackSid + \"+\" + trackStats.ssrc;\n  var trackMovingAverageDeltas = movingAverageDeltas.get(key) || new Map();\n\n  if (typeof estimatedPlayoutTimestamp === 'number') {\n    augmentedTrackStats.estimatedPlayoutTimestamp = estimatedPlayoutTimestamp;\n  }\n\n  if (typeof framesDecoded === 'number' && typeof totalDecodeTime === 'number') {\n    var trackAvgDecodeDelayMovingAverageDelta = trackMovingAverageDeltas.get('avgDecodeDelay') || new MovingAverageDelta();\n    trackAvgDecodeDelayMovingAverageDelta.putSample(totalDecodeTime * 1000, framesDecoded);\n    augmentedTrackStats.avgDecodeDelay = Math.round(trackAvgDecodeDelayMovingAverageDelta.get());\n    trackMovingAverageDeltas.set('avgDecodeDelay', trackAvgDecodeDelayMovingAverageDelta);\n  }\n\n  if (typeof jitterBufferDelay === 'number' && typeof jitterBufferEmittedCount === 'number') {\n    var trackAvgJitterBufferDelayMovingAverageDelta = trackMovingAverageDeltas.get('avgJitterBufferDelay') || new MovingAverageDelta();\n    trackAvgJitterBufferDelayMovingAverageDelta.putSample(jitterBufferDelay * 1000, jitterBufferEmittedCount);\n    augmentedTrackStats.avgJitterBufferDelay = Math.round(trackAvgJitterBufferDelayMovingAverageDelta.get());\n    trackMovingAverageDeltas.set('avgJitterBufferDelay', trackAvgJitterBufferDelayMovingAverageDelta);\n  }\n\n  movingAverageDeltas.set(key, trackMovingAverageDeltas);\n  return augmentedTrackStats;\n}\n\nfunction replaceNullsWithDefaults(activeIceCandidatePair, peerConnectionId) {\n  activeIceCandidatePair = Object.assign({\n    availableIncomingBitrate: 0,\n    availableOutgoingBitrate: 0,\n    bytesReceived: 0,\n    bytesSent: 0,\n    consentRequestsSent: 0,\n    currentRoundTripTime: 0,\n    lastPacketReceivedTimestamp: 0,\n    lastPacketSentTimestamp: 0,\n    nominated: false,\n    peerConnectionId: peerConnectionId,\n    priority: 0,\n    readable: false,\n    requestsReceived: 0,\n    requestsSent: 0,\n    responsesReceived: 0,\n    responsesSent: 0,\n    retransmissionsReceived: 0,\n    retransmissionsSent: 0,\n    state: 'failed',\n    totalRoundTripTime: 0,\n    transportId: '',\n    writable: false\n  }, filterObject(activeIceCandidatePair || {}, null));\n  activeIceCandidatePair.localCandidate = Object.assign({\n    candidateType: 'host',\n    deleted: false,\n    ip: '',\n    port: 0,\n    priority: 0,\n    protocol: 'udp',\n    url: ''\n  }, filterObject(activeIceCandidatePair.localCandidate || {}, null));\n  activeIceCandidatePair.remoteCandidate = Object.assign({\n    candidateType: 'host',\n    ip: '',\n    port: 0,\n    priority: 0,\n    protocol: 'udp',\n    url: ''\n  }, filterObject(activeIceCandidatePair.remoteCandidate || {}, null));\n  return activeIceCandidatePair;\n}\n\nmodule.exports = RoomV2;","map":null,"metadata":{},"sourceType":"script"}