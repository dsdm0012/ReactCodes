{"ast":null,"code":"'use strict';\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) {\n    to[j] = from[i];\n  }\n\n  return to;\n};\n/**\n * A Promise that can be canceled with {@link CancelablePromise#cancel}.\n * @extends Promise\n*/\n\n\nvar CancelablePromise =\n/** @class */\nfunction () {\n  /**\n   * Construct a new {@link CancelablePromise}.\n   * @param {CancelablePromise.OnCreate} onCreate\n   * @param {CancelablePromise.OnCancel} onCancel\n  */\n\n  /**\n  * A function to be called on {@link CancelablePromise} creation\n  * @typedef {function} CancelablePromise.OnCreate\n  * @param {function(*)} resolve\n  * @param {function(*)} reject\n  * @param {function(): boolean} isCanceled\n  */\n\n  /**\n  * A function to be called when {@link CancelablePromise#cancel} is called\n  * @typedef {function} CancelablePromise.OnCancel\n  */\n  function CancelablePromise(onCreate, onCancel) {\n    var _this = this;\n    /* istanbul ignore next */\n\n\n    Object.defineProperties(this, {\n      _isCancelable: {\n        writable: true,\n        value: true\n      },\n      _isCanceled: {\n        writable: true,\n        value: false\n      },\n      _onCancel: {\n        value: onCancel\n      }\n    });\n    Object.defineProperty(this, '_promise', {\n      value: new Promise(function (resolve, reject) {\n        onCreate(function (value) {\n          _this._isCancelable = false;\n          resolve(value);\n        }, function (reason) {\n          _this._isCancelable = false;\n          reject(reason);\n        }, function () {\n          return _this._isCanceled;\n        });\n      })\n    });\n  }\n  /**\n   * Create a synchronously-rejected {@link CancelablePromise}.\n   * @param {*} reason\n   * @returns {Promise<*>}\n   */\n\n\n  CancelablePromise.reject = function (reason) {\n    return new CancelablePromise(function rejected(resolve, reject) {\n      reject(reason);\n    }, function onCancel() {// Do nothing.\n    });\n  };\n  /**\n   * Create a synchronously-resolved {@link CancelablePromise}.\n   * @param {*|Promise<*>|Thenable<*>} result\n   * @returns {CancelablePromise<*>}\n   */\n\n\n  CancelablePromise.resolve = function (result) {\n    return new CancelablePromise(function resolved(resolve) {\n      resolve(result);\n    }, function onCancel() {// Do nothing.\n    });\n  };\n  /**\n   * Attempt to cancel the {@link CancelablePromise}.\n   * @returns {this}\n   */\n\n\n  CancelablePromise.prototype.cancel = function () {\n    if (this._isCancelable) {\n      this._isCanceled = true;\n\n      this._onCancel();\n    }\n\n    return this;\n  };\n  /**\n   * @param {function} onRejected\n   * @returns {CancelablePromise}\n   */\n\n\n  CancelablePromise.prototype.catch = function () {\n    var args = [].slice.call(arguments);\n    var promise = this._promise;\n    return new CancelablePromise(function onCreate(resolve, reject) {\n      promise.catch.apply(promise, __spreadArray([], __read(args))).then(resolve, reject);\n    }, this._onCancel);\n  };\n  /**\n   * @param {?function} onResolved\n   * @param {function} [onRejected]\n   * @returns {CancelablePromise}\n   */\n\n\n  CancelablePromise.prototype.then = function () {\n    var args = [].slice.call(arguments);\n    var promise = this._promise;\n    return new CancelablePromise(function onCreate(resolve, reject) {\n      promise.then.apply(promise, __spreadArray([], __read(args))).then(resolve, reject);\n    }, this._onCancel);\n  };\n  /**\n  * @param {?function} onFinally\n  * @returns {CancelablePromise}\n  */\n\n\n  CancelablePromise.prototype.finally = function () {\n    var args = [].slice.call(arguments);\n    var promise = this._promise;\n    return new CancelablePromise(function onCreate(resolve, reject) {\n      promise.finally.apply(promise, __spreadArray([], __read(args))).then(resolve, reject);\n    }, this._onCancel);\n  };\n\n  return CancelablePromise;\n}();\n\nmodule.exports = CancelablePromise;","map":null,"metadata":{},"sourceType":"script"}