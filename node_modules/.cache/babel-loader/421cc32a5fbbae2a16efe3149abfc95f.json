{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar _a = require('../../webrtc/util'),\n    guessBrowser = _a.guessBrowser,\n    isIOSChrome = _a.isIOSChrome;\n\nvar MediaStream = require('../../webrtc').MediaStream;\n\nvar _b = require('../../util'),\n    waitForEvent = _b.waitForEvent,\n    waitForSometime = _b.waitForSometime;\n\nvar localMediaRestartDeferreds = require('../../util/localmediarestartdeferreds');\n\nvar Track = require('./');\n/**\n * A {@link MediaTrack} represents audio or video that can be sent to or\n * received from a {@link Room}.\n * @extends Track\n * @property {Track.ID} id - This {@link Track}'s ID\n * @property {boolean} isStarted - Whether or not the {@link MediaTrack} has\n *   started\n * @property {boolean} isEnabled - Whether or not the {@link MediaTrack} is\n *   enabled (i.e., whether it is paused or muted)\n * @property {Track.Kind} kind - The kind of the underlying\n *   MediaStreamTrack, \"audio\" or \"video\"\n * @property {MediaStreamTrack} mediaStreamTrack - The underlying\n *   MediaStreamTrack\n * @emits MediaTrack#disabled\n * @emits MediaTrack#enabled\n * @emits MediaTrack#started\n */\n\n\nvar MediaTrack =\n/** @class */\nfunction (_super) {\n  __extends(MediaTrack, _super);\n  /**\n   * Construct a {@link MediaTrack}.\n   * @param {MediaTrackTransceiver} mediaTrackTransceiver\n   * @param {{log: Log}} options\n   */\n\n\n  function MediaTrack(mediaTrackTransceiver, options) {\n    var _this = this;\n\n    options = Object.assign({\n      playPausedElementsIfNotBackgrounded: (guessBrowser() === 'safari' || isIOSChrome()) && typeof document === 'object' && typeof document.addEventListener === 'function' && typeof document.visibilityState === 'string'\n    }, options);\n    _this = _super.call(this, mediaTrackTransceiver.id, mediaTrackTransceiver.kind, options) || this;\n    var isStarted = false;\n    options = Object.assign({\n      MediaStream: MediaStream\n    }, options);\n    /* istanbul ignore next */\n\n    Object.defineProperties(_this, {\n      _attachments: {\n        value: new Set()\n      },\n      _dummyEl: {\n        value: null,\n        writable: true\n      },\n      _elShims: {\n        value: new WeakMap()\n      },\n      _isStarted: {\n        get: function () {\n          return isStarted;\n        },\n        set: function (_isStarted) {\n          isStarted = _isStarted;\n        }\n      },\n      _playPausedElementsIfNotBackgrounded: {\n        value: options.playPausedElementsIfNotBackgrounded\n      },\n      _shouldShimAttachedElements: {\n        value: options.workaroundWebKitBug212780 || options.playPausedElementsIfNotBackgrounded\n      },\n      _unprocessedTrack: {\n        value: null,\n        writable: true\n      },\n      _MediaStream: {\n        value: options.MediaStream\n      },\n      isStarted: {\n        enumerable: true,\n        get: function () {\n          return isStarted;\n        }\n      },\n      mediaStreamTrack: {\n        enumerable: true,\n        get: function () {\n          return this._unprocessedTrack || mediaTrackTransceiver.track;\n        }\n      },\n      processedTrack: {\n        enumerable: true,\n        value: null,\n        writable: true\n      }\n    });\n\n    _this._initialize();\n\n    return _this;\n  }\n  /**\n   * @private\n   */\n\n\n  MediaTrack.prototype._start = function () {\n    this._log.debug('Started');\n\n    this._isStarted = true;\n\n    if (this._dummyEl) {\n      this._dummyEl.oncanplay = null;\n    } // eslint-disable-next-line no-use-before-define\n\n\n    this.emit('started', this);\n  };\n  /**\n   * @private\n   */\n\n\n  MediaTrack.prototype._initialize = function () {\n    var self = this;\n\n    this._log.debug('Initializing');\n\n    this._dummyEl = this._createElement();\n    this.mediaStreamTrack.addEventListener('ended', function onended() {\n      self._end();\n\n      self.mediaStreamTrack.removeEventListener('ended', onended);\n    });\n\n    if (this._dummyEl) {\n      this._dummyEl.muted = true;\n      this._dummyEl.oncanplay = this._start.bind(this, this._dummyEl); // NOTE(csantos): We always want to attach the original mediaStreamTrack for dummyEl\n\n      this._attach(this._dummyEl, this.mediaStreamTrack);\n\n      this._attachments.delete(this._dummyEl);\n    }\n  };\n  /**\n   * @private\n   */\n\n\n  MediaTrack.prototype._end = function () {\n    this._log.debug('Ended');\n\n    if (this._dummyEl) {\n      this._dummyEl.remove();\n\n      this._dummyEl.srcObject = null;\n      this._dummyEl.oncanplay = null;\n      this._dummyEl = null;\n    }\n  };\n\n  MediaTrack.prototype.attach = function (el) {\n    var _this = this;\n\n    if (typeof el === 'string') {\n      el = this._selectElement(el);\n    } else if (!el) {\n      el = this._createElement();\n    }\n\n    this._log.debug('Attempting to attach to element:', el);\n\n    el = this._attach(el);\n\n    if (this._shouldShimAttachedElements && !this._elShims.has(el)) {\n      var onUnintentionallyPaused = this._playPausedElementsIfNotBackgrounded ? function () {\n        return playIfPausedAndNotBackgrounded(el, _this._log);\n      } : null;\n\n      this._elShims.set(el, shimMediaElement(el, onUnintentionallyPaused));\n    }\n\n    return el;\n  };\n  /**\n   * Attach the provided MediaStreamTrack to the media element.\n   * @param el - The media element to attach to\n   * @param mediaStreamTrack - The MediaStreamTrack to attach. If this is\n   * not provided, it uses the processedTrack if it exists\n   * or it defaults to the current mediaStreamTrack\n   * @private\n   */\n\n\n  MediaTrack.prototype._attach = function (el, mediaStreamTrack) {\n    if (mediaStreamTrack === void 0) {\n      mediaStreamTrack = this.processedTrack || this.mediaStreamTrack;\n    }\n\n    var mediaStream = el.srcObject;\n\n    if (!(mediaStream instanceof this._MediaStream)) {\n      mediaStream = new this._MediaStream();\n    }\n\n    var getTracks = mediaStreamTrack.kind === 'audio' ? 'getAudioTracks' : 'getVideoTracks';\n    mediaStream[getTracks]().forEach(function (track) {\n      mediaStream.removeTrack(track);\n    });\n    mediaStream.addTrack(mediaStreamTrack); // NOTE(mpatwardhan): resetting `srcObject` here, causes flicker (JSDK-2641), but it lets us\n    // to sidestep the a chrome bug: https://bugs.chromium.org/p/chromium/issues/detail?id=1052353\n    //\n\n    el.srcObject = mediaStream;\n    el.autoplay = true;\n    el.playsInline = true;\n\n    if (!this._attachments.has(el)) {\n      this._attachments.add(el);\n    }\n\n    return el;\n  };\n  /**\n   * @private\n   */\n\n\n  MediaTrack.prototype._selectElement = function (selector) {\n    var el = document.querySelector(selector);\n\n    if (!el) {\n      throw new Error(\"Selector matched no element: \" + selector);\n    }\n\n    return el;\n  };\n  /**\n   * @private\n   */\n\n\n  MediaTrack.prototype._updateElementsMediaStreamTrack = function () {\n    var _this = this;\n\n    this._log.debug('Reattaching all elements to update mediaStreamTrack');\n\n    this._getAllAttachedElements().forEach(function (el) {\n      return _this._attach(el);\n    });\n  };\n  /**\n   * @private\n   */\n\n\n  MediaTrack.prototype._createElement = function () {\n    return typeof document !== 'undefined' ? document.createElement(this.kind) : null;\n  };\n\n  MediaTrack.prototype.detach = function (el) {\n    var els;\n\n    if (typeof el === 'string') {\n      els = [this._selectElement(el)];\n    } else if (!el) {\n      els = this._getAllAttachedElements();\n    } else {\n      els = [el];\n    }\n\n    this._log.debug('Attempting to detach from elements:', els);\n\n    this._detachElements(els);\n\n    return el ? els[0] : els;\n  };\n  /**\n   * @private\n   */\n\n\n  MediaTrack.prototype._detachElements = function (elements) {\n    return elements.map(this._detachElement.bind(this));\n  };\n  /**\n   * @private\n   */\n\n\n  MediaTrack.prototype._detachElement = function (el) {\n    if (!this._attachments.has(el)) {\n      return el;\n    }\n\n    var mediaStream = el.srcObject;\n\n    if (mediaStream instanceof this._MediaStream) {\n      mediaStream.removeTrack(this.processedTrack || this.mediaStreamTrack);\n    }\n\n    this._attachments.delete(el);\n\n    if (this._shouldShimAttachedElements && this._elShims.has(el)) {\n      var shim = this._elShims.get(el);\n\n      shim.unShim();\n\n      this._elShims.delete(el);\n    }\n\n    return el;\n  };\n  /**\n   * @private\n   */\n\n\n  MediaTrack.prototype._getAllAttachedElements = function () {\n    var els = [];\n\n    this._attachments.forEach(function (el) {\n      els.push(el);\n    });\n\n    return els;\n  };\n\n  return MediaTrack;\n}(Track);\n/**\n * Play an HTMLMediaElement if it is paused and not backgrounded.\n * @private\n * @param {HTMLMediaElement} el\n * @param {Log} log\n * @returns {void}\n */\n\n\nfunction playIfPausedAndNotBackgrounded(el, log) {\n  var tag = el.tagName.toLowerCase();\n  log.warn('Unintentionally paused:', el); // NOTE(mmalavalli): When the element is unintentionally paused, we wait one\n  // second for the \"onvisibilitychange\" event on the HTMLDocument to see if the\n  // app will be backgrounded. If not, then the element can be safely played.\n\n  Promise.race([waitForEvent(document, 'visibilitychange'), waitForSometime(1000)]).then(function () {\n    if (document.visibilityState === 'visible') {\n      // NOTE(mmalavalli): We play the inadvertently paused elements only after\n      // the LocalAudioTrack is unmuted to work around WebKit Bug 213853.\n      //\n      // Bug: https://bugs.webkit.org/show_bug.cgi?id=213853\n      //\n      localMediaRestartDeferreds.whenResolved('audio').then(function () {\n        log.info(\"Playing unintentionally paused <\" + tag + \"> element\");\n        log.debug('Element:', el);\n        return el.play();\n      }).then(function () {\n        log.info(\"Successfully played unintentionally paused <\" + tag + \"> element\");\n        log.debug('Element:', el);\n      }).catch(function (error) {\n        log.warn(\"Error while playing unintentionally paused <\" + tag + \"> element:\", {\n          error: error,\n          el: el\n        });\n      });\n    }\n  });\n}\n/**\n * Shim the pause() and play() methods of the given HTMLMediaElement so that\n * we can detect if it was paused unintentionally.\n * @param {HTMLMediaElement} el\n * @param {?function} [onUnintentionallyPaused=null]\n * @returns {{pausedIntentionally: function, unShim: function}}\n */\n\n\nfunction shimMediaElement(el, onUnintentionallyPaused) {\n  if (onUnintentionallyPaused === void 0) {\n    onUnintentionallyPaused = null;\n  }\n\n  var origPause = el.pause;\n  var origPlay = el.play;\n  var pausedIntentionally = false;\n\n  el.pause = function () {\n    pausedIntentionally = true;\n    return origPause.call(el);\n  };\n\n  el.play = function () {\n    pausedIntentionally = false;\n    return origPlay.call(el);\n  };\n\n  var onPause = onUnintentionallyPaused ? function () {\n    if (!pausedIntentionally) {\n      onUnintentionallyPaused();\n    }\n  } : null;\n\n  if (onPause) {\n    el.addEventListener('pause', onPause);\n  }\n\n  return {\n    pausedIntentionally: function () {\n      return pausedIntentionally;\n    },\n    unShim: function () {\n      el.pause = origPause;\n      el.play = origPlay;\n\n      if (onPause) {\n        el.removeEventListener('pause', onPause);\n      }\n    }\n  };\n}\n\nmodule.exports = MediaTrack;","map":null,"metadata":{},"sourceType":"script"}