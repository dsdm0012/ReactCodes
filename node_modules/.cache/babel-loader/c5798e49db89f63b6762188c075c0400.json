{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) {\n    to[j] = from[i];\n  }\n\n  return to;\n};\n\nvar DefaultBackoff = require('../../util/backoff');\n\nvar _a = require('../../webrtc'),\n    DefaultRTCIceCandidate = _a.RTCIceCandidate,\n    DefaultRTCPeerConnection = _a.RTCPeerConnection,\n    DefaultRTCSessionDescription = _a.RTCSessionDescription,\n    getStatistics = _a.getStats;\n\nvar util = require('../../webrtc/util');\n\nvar _b = require('../../util/constants'),\n    DEFAULT_ICE_GATHERING_TIMEOUT_MS = _b.DEFAULT_ICE_GATHERING_TIMEOUT_MS,\n    DEFAULT_LOG_LEVEL = _b.DEFAULT_LOG_LEVEL,\n    DEFAULT_SESSION_TIMEOUT_SEC = _b.DEFAULT_SESSION_TIMEOUT_SEC,\n    iceRestartBackoffConfig = _b.iceRestartBackoffConfig;\n\nvar _c = require('../../util/sdp'),\n    addOrRewriteNewTrackIds = _c.addOrRewriteNewTrackIds,\n    addOrRewriteTrackIds = _c.addOrRewriteTrackIds,\n    createCodecMapForMediaSection = _c.createCodecMapForMediaSection,\n    disableRtx = _c.disableRtx,\n    enableDtxForOpus = _c.enableDtxForOpus,\n    filterLocalCodecs = _c.filterLocalCodecs,\n    getMediaSections = _c.getMediaSections,\n    removeSSRCAttributes = _c.removeSSRCAttributes,\n    revertSimulcast = _c.revertSimulcast,\n    setCodecPreferences = _c.setCodecPreferences,\n    setSimulcast = _c.setSimulcast;\n\nvar DefaultTimeout = require('../../util/timeout');\n\nvar _d = require('../../util/twilio-video-errors'),\n    MediaClientLocalDescFailedError = _d.MediaClientLocalDescFailedError,\n    MediaClientRemoteDescFailedError = _d.MediaClientRemoteDescFailedError;\n\nvar _e = require('../../util'),\n    buildLogLevels = _e.buildLogLevels,\n    getPlatform = _e.getPlatform,\n    isChromeScreenShareTrack = _e.isChromeScreenShareTrack,\n    oncePerTick = _e.oncePerTick,\n    defer = _e.defer;\n\nvar IceBox = require('./icebox');\n\nvar DefaultIceConnectionMonitor = require('./iceconnectionmonitor.js');\n\nvar DataTrackReceiver = require('../../data/receiver');\n\nvar MediaTrackReceiver = require('../../media/track/receiver');\n\nvar StateMachine = require('../../statemachine');\n\nvar Log = require('../../util/log');\n\nvar TrackMatcher = require('../../util/sdp/trackmatcher');\n\nvar workaroundIssue8329 = require('../../util/sdp/issue8329');\n\nvar guess = util.guessBrowser();\nvar platform = getPlatform();\nvar isAndroid = /android/.test(platform);\nvar isChrome = guess === 'chrome';\nvar isFirefox = guess === 'firefox';\nvar isSafari = guess === 'safari';\nvar nInstances = 0;\n/*\nPeerConnectionV2 States\n-----------------------\n\n    +------+    +--------+\n    |      |    |        |\n    | open |--->| closed |\n    |      |    |        |\n    +------+    +--------+\n      |  ^          ^\n      |  |          |\n      |  |          |\n      v  |          |\n  +----------+      |\n  |          |      |\n  | updating |------+\n  |          |\n  +----------+\n\n*/\n\nvar states = {\n  open: ['closed', 'updating'],\n  updating: ['closed', 'open'],\n  closed: []\n};\n/**\n * @extends StateMachine\n * @property {id}\n * @emits PeerConnectionV2#connectionStateChanged\n * @emits PeerConnectionV2#iceConnectionStateChanged\n * @emits PeerConnectionV2#candidates\n * @emits PeerConnectionV2#description\n */\n\nvar PeerConnectionV2 =\n/** @class */\nfunction (_super) {\n  __extends(PeerConnectionV2, _super);\n  /**\n   * Construct a {@link PeerConnectionV2}.\n   * @param {string} id\n   * @param {EncodingParametersImpl} encodingParameters\n   * @param {PreferredCodecs} preferredCodecs\n   * @param {object} [options]\n   */\n\n\n  function PeerConnectionV2(id, encodingParameters, preferredCodecs, options) {\n    var _this = _super.call(this, 'open', states) || this;\n\n    options = Object.assign({\n      enableDscp: false,\n      dummyAudioMediaStreamTrack: null,\n      isChromeScreenShareTrack: isChromeScreenShareTrack,\n      iceServers: [],\n      logLevel: DEFAULT_LOG_LEVEL,\n      offerOptions: {},\n      revertSimulcast: revertSimulcast,\n      sessionTimeout: DEFAULT_SESSION_TIMEOUT_SEC * 1000,\n      setCodecPreferences: setCodecPreferences,\n      setSimulcast: setSimulcast,\n      Backoff: DefaultBackoff,\n      IceConnectionMonitor: DefaultIceConnectionMonitor,\n      RTCIceCandidate: DefaultRTCIceCandidate,\n      RTCPeerConnection: DefaultRTCPeerConnection,\n      RTCSessionDescription: DefaultRTCSessionDescription,\n      Timeout: DefaultTimeout\n    }, options);\n    var configuration = getConfiguration(options);\n    var logLevels = buildLogLevels(options.logLevel);\n    var RTCPeerConnection = options.RTCPeerConnection;\n\n    if (options.enableDscp === true) {\n      options.chromeSpecificConstraints = options.chromeSpecificConstraints || {};\n      options.chromeSpecificConstraints.optional = options.chromeSpecificConstraints.optional || [];\n      options.chromeSpecificConstraints.optional.push({\n        googDscp: true\n      });\n    }\n\n    var log = options.log ? options.log.createLog('webrtc', _this) : new Log('webrtc', _this, logLevels, options.loggerName);\n    var peerConnection = new RTCPeerConnection(configuration, options.chromeSpecificConstraints);\n\n    if (options.dummyAudioMediaStreamTrack) {\n      peerConnection.addTrack(options.dummyAudioMediaStreamTrack);\n    }\n\n    Object.defineProperties(_this, {\n      _appliedTrackIdsToAttributes: {\n        value: new Map(),\n        writable: true\n      },\n      _dataChannels: {\n        value: new Map()\n      },\n      _dataTrackReceivers: {\n        value: new Set()\n      },\n      _descriptionRevision: {\n        writable: true,\n        value: 0\n      },\n      _didGenerateLocalCandidates: {\n        writable: true,\n        value: false\n      },\n      _enableDscp: {\n        value: options.enableDscp\n      },\n      _encodingParameters: {\n        value: encodingParameters\n      },\n      _isChromeScreenShareTrack: {\n        value: options.isChromeScreenShareTrack\n      },\n      _iceGatheringFailed: {\n        value: false,\n        writable: true\n      },\n      _iceGatheringTimeout: {\n        value: new options.Timeout(function () {\n          return _this._handleIceGatheringTimeout();\n        }, DEFAULT_ICE_GATHERING_TIMEOUT_MS, false)\n      },\n      _iceRestartBackoff: {\n        // eslint-disable-next-line new-cap\n        value: new options.Backoff(iceRestartBackoffConfig)\n      },\n      _instanceId: {\n        value: ++nInstances\n      },\n      _isIceConnectionInactive: {\n        writable: true,\n        value: false\n      },\n      _isIceLite: {\n        writable: true,\n        value: false\n      },\n      _isIceRestartBackoffInProgress: {\n        writable: true,\n        value: false\n      },\n      _isRestartingIce: {\n        writable: true,\n        value: false\n      },\n      _lastIceConnectionState: {\n        writable: true,\n        value: null\n      },\n      _lastStableDescriptionRevision: {\n        writable: true,\n        value: 0\n      },\n      _localCandidates: {\n        writable: true,\n        value: []\n      },\n      _localCodecs: {\n        value: new Set()\n      },\n      _localCandidatesRevision: {\n        writable: true,\n        value: 1\n      },\n      _localDescriptionWithoutSimulcast: {\n        writable: true,\n        value: null\n      },\n      _localDescription: {\n        writable: true,\n        value: null\n      },\n      _localUfrag: {\n        writable: true,\n        value: null\n      },\n      _log: {\n        value: log\n      },\n      _eventObserver: {\n        value: options.eventObserver\n      },\n      _remoteCodecMaps: {\n        value: new Map()\n      },\n      _rtpSenders: {\n        value: new Map()\n      },\n      _rtpNewSenders: {\n        value: new Set()\n      },\n      _iceConnectionMonitor: {\n        value: new options.IceConnectionMonitor(peerConnection)\n      },\n      _mediaTrackReceivers: {\n        value: new Set()\n      },\n      _needsAnswer: {\n        writable: true,\n        value: false\n      },\n      _negotiationRole: {\n        writable: true,\n        value: null\n      },\n      _offerOptions: {\n        writable: true,\n        value: options.offerOptions\n      },\n      _onEncodingParametersChanged: {\n        value: oncePerTick(function () {\n          if (!_this._needsAnswer) {\n            updateEncodingParameters(_this);\n          }\n        })\n      },\n      _peerConnection: {\n        value: peerConnection\n      },\n      _preferredAudioCodecs: {\n        value: preferredCodecs.audio\n      },\n      _preferredVideoCodecs: {\n        value: preferredCodecs.video\n      },\n      _shouldApplyDtx: {\n        value: preferredCodecs.audio.every(function (_a) {\n          var codec = _a.codec;\n          return codec !== 'opus';\n        }) || preferredCodecs.audio.some(function (_a) {\n          var codec = _a.codec,\n              dtx = _a.dtx;\n          return codec === 'opus' && dtx;\n        })\n      },\n      _queuedDescription: {\n        writable: true,\n        value: null\n      },\n      _iceReconnectTimeout: {\n        value: new options.Timeout(function () {\n          log.debug('ICE reconnect timed out');\n\n          _this.close();\n        }, options.sessionTimeout, false)\n      },\n      _recycledTransceivers: {\n        value: {\n          audio: [],\n          video: []\n        }\n      },\n      _replaceTrackPromises: {\n        value: new Map()\n      },\n      _remoteCandidates: {\n        writable: true,\n        value: new IceBox()\n      },\n      _setCodecPreferences: {\n        // NOTE(mmalavalli): Re-ordering payload types in order to make sure a non-H264\n        // preferred codec is selected does not work on Android Firefox due to this behavior:\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1683258. So, we work around this by\n        // not applying any non-H264 preferred video codec.\n        value: isFirefox && isAndroid && preferredCodecs.video[0] && preferredCodecs.video[0].codec.toLowerCase() !== 'h264' ? function (sdp) {\n          return sdp;\n        } : options.setCodecPreferences\n      },\n      _setSimulcast: {\n        value: options.setSimulcast\n      },\n      _revertSimulcast: {\n        value: options.revertSimulcast\n      },\n      _RTCIceCandidate: {\n        value: options.RTCIceCandidate\n      },\n      _RTCPeerConnection: {\n        value: options.RTCPeerConnection\n      },\n      _RTCSessionDescription: {\n        value: options.RTCSessionDescription\n      },\n      _shouldOffer: {\n        writable: true,\n        value: false\n      },\n      _shouldRestartIce: {\n        writable: true,\n        value: false\n      },\n      _trackIdsToAttributes: {\n        value: new Map(),\n        writable: true\n      },\n      _trackMatcher: {\n        writable: true,\n        value: null\n      },\n      _mediaTrackSenderToPublisherHints: {\n        value: new Map()\n      },\n      id: {\n        enumerable: true,\n        value: id\n      }\n    });\n    encodingParameters.on('changed', _this._onEncodingParametersChanged);\n    peerConnection.addEventListener('connectionstatechange', _this._handleConnectionStateChange.bind(_this));\n    peerConnection.addEventListener('datachannel', _this._handleDataChannelEvent.bind(_this));\n    peerConnection.addEventListener('icecandidate', _this._handleIceCandidateEvent.bind(_this));\n    peerConnection.addEventListener('iceconnectionstatechange', _this._handleIceConnectionStateChange.bind(_this));\n    peerConnection.addEventListener('icegatheringstatechange', _this._handleIceGatheringStateChange.bind(_this));\n    peerConnection.addEventListener('signalingstatechange', _this._handleSignalingStateChange.bind(_this));\n    peerConnection.addEventListener('track', _this._handleTrackEvent.bind(_this));\n    var self = _this;\n\n    _this.on('stateChanged', function stateChanged(state) {\n      if (state !== 'closed') {\n        return;\n      }\n\n      self.removeListener('stateChanged', stateChanged);\n\n      self._dataChannels.forEach(function (dataChannel, dataTrackSender) {\n        self.removeDataTrackSender(dataTrackSender);\n      });\n    });\n\n    return _this;\n  }\n\n  PeerConnectionV2.prototype.toString = function () {\n    return \"[PeerConnectionV2 #\" + this._instanceId + \": \" + this.id + \"]\";\n  };\n\n  PeerConnectionV2.prototype.setEffectiveAdaptiveSimulcast = function (effectiveAdaptiveSimulcast) {\n    this._log.debug('Setting setEffectiveAdaptiveSimulcast: ', effectiveAdaptiveSimulcast); // clear adaptive simulcast from codec preferences if it was set.\n\n\n    this._preferredVideoCodecs.forEach(function (cs) {\n      if ('adaptiveSimulcast' in cs) {\n        cs.adaptiveSimulcast = effectiveAdaptiveSimulcast;\n      }\n    });\n  };\n\n  Object.defineProperty(PeerConnectionV2.prototype, \"_shouldApplySimulcast\", {\n    get: function get() {\n      if (!isChrome && !isSafari) {\n        return false;\n      } // adaptiveSimulcast is set to false after connected message is received if other party does not support it.\n\n\n      var simulcast = this._preferredVideoCodecs.some(function (cs) {\n        return cs.codec.toLowerCase() === 'vp8' && cs.simulcast && cs.adaptiveSimulcast !== false;\n      });\n\n      return simulcast;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PeerConnectionV2.prototype, \"connectionState\", {\n    /**\n     * The {@link PeerConnectionV2}'s underlying RTCPeerConnection's RTCPeerConnectionState\n     * if supported by the browser, its RTCIceConnectionState otherwise.\n     * @property {RTCPeerConnectionState}\n     */\n    get: function get() {\n      return this.iceConnectionState === 'failed' ? 'failed' : this._peerConnection.connectionState || this.iceConnectionState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PeerConnectionV2.prototype, \"iceConnectionState\", {\n    /**\n     * The {@link PeerConnectionV2}'s underlying RTCPeerConnection's\n     * RTCIceConnectionState.\n     * @property {RTCIceConnectionState}\n     */\n    get: function get() {\n      return this._isIceConnectionInactive && this._peerConnection.iceConnectionState === 'disconnected' || this._iceGatheringFailed ? 'failed' : this._peerConnection.iceConnectionState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PeerConnectionV2.prototype, \"isApplicationSectionNegotiated\", {\n    /**\n     * Whether the {@link PeerConnectionV2} has negotiated or is in the process\n     * of negotiating the application m= section.\n     * @returns {boolean}\n     */\n    get: function get() {\n      if (this._peerConnection.signalingState !== 'closed') {\n        // accessing .localDescription in 'closed' state causes it throw exceptions.\n        return this._peerConnection.localDescription ? getMediaSections(this._peerConnection.localDescription.sdp, 'application').length > 0 : false;\n      }\n\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PeerConnectionV2.prototype, \"_isAdaptiveSimulcastEnabled\", {\n    /**\n     * Whether adaptive simulcast is enabled.\n     * @returns {boolean}\n     */\n    get: function get() {\n      var adaptiveSimulcastEntry = this._preferredVideoCodecs.find(function (cs) {\n        return 'adaptiveSimulcast' in cs;\n      });\n\n      return adaptiveSimulcastEntry && adaptiveSimulcastEntry.adaptiveSimulcast === true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * @param {MediaStreamTrack} track\n   * @param {Array<RTCRtpEncodingParameters>} encodings\n   * @param {boolean} trackReplaced\n   * @returns {boolean} true if encodings were updated.\n   */\n\n  PeerConnectionV2.prototype._maybeUpdateEncodings = function (track, encodings, trackReplaced) {\n    if (trackReplaced === void 0) {\n      trackReplaced = false;\n    }\n\n    if (track.kind !== 'video' || track.readyState === 'ended') {\n      return false;\n    }\n\n    var browser = util.guessBrowser(); // Note(mpatwardhan): always configure encodings for safari.\n    // for chrome only when adaptive simulcast enabled.\n\n    if (browser === 'safari' || browser === 'chrome' && this._isAdaptiveSimulcastEnabled) {\n      this._updateEncodings(track, encodings, trackReplaced);\n\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Configures with default encodings depending on track type and resolution.\n   * Default configuration sets some encodings to disabled, and for others set scaleResolutionDownBy\n   * values. When trackReplaced is set to true, it will clear 'active' for any encodings that\n   * needs to be enabled.\n   * @param {MediaStreamTrack} track\n   * @param {Array<RTCRtpEncodingParameters>} encodings\n   * @param {boolean} trackReplaced\n   */\n\n\n  PeerConnectionV2.prototype._updateEncodings = function (track, encodings, trackReplaced) {\n    if (this._isChromeScreenShareTrack(track)) {\n      var screenShareActiveLayerConfig_1 = [{\n        scaleResolutionDownBy: 1\n      }, {\n        scaleResolutionDownBy: 1\n      }];\n      encodings.forEach(function (encoding, i) {\n        var activeLayerConfig = screenShareActiveLayerConfig_1[i];\n\n        if (activeLayerConfig) {\n          encoding.scaleResolutionDownBy = activeLayerConfig.scaleResolutionDownBy;\n\n          if (trackReplaced) {\n            delete encoding.active;\n          }\n        } else {\n          encoding.active = false;\n          delete encoding.scaleResolutionDownBy;\n        }\n      });\n    } else {\n      var _a = track.getSettings(),\n          width = _a.width,\n          height = _a.height; // NOTE(mpatwardhan): for non-screen share tracks\n      // enable layers depending on track resolutions\n\n\n      var pixelsToMaxActiveLayers = [{\n        pixels: 960 * 540,\n        maxActiveLayers: 3\n      }, {\n        pixels: 480 * 270,\n        maxActiveLayers: 2\n      }, {\n        pixels: 0,\n        maxActiveLayers: 1\n      }];\n      var trackPixels_1 = width * height;\n      var activeLayersInfo = pixelsToMaxActiveLayers.find(function (layer) {\n        return trackPixels_1 >= layer.pixels;\n      });\n      var activeLayers_1 = Math.min(encodings.length, activeLayersInfo.maxActiveLayers);\n      encodings.forEach(function (encoding, i) {\n        var enabled = i < activeLayers_1;\n\n        if (enabled) {\n          encoding.scaleResolutionDownBy = 1 << activeLayers_1 - i - 1;\n\n          if (trackReplaced) {\n            encoding.active = true;\n          }\n        } else {\n          encoding.active = false;\n          delete encoding.scaleResolutionDownBy;\n        }\n      });\n    }\n\n    this._log.debug('_updateEncodings:', encodings.map(function (_a, i) {\n      var active = _a.active,\n          scaleResolutionDownBy = _a.scaleResolutionDownBy;\n      return \"[\" + i + \": \" + active + \", \" + (scaleResolutionDownBy || 0) + \"]\";\n    }).join(', '));\n  };\n  /**\n   * Add an ICE candidate to the {@link PeerConnectionV2}.\n   * @private\n   * @param {object} candidate\n   * @returns {Promise<void>}\n   */\n\n\n  PeerConnectionV2.prototype._addIceCandidate = function (candidate) {\n    var _this = this;\n\n    return Promise.resolve().then(function () {\n      candidate = new _this._RTCIceCandidate(candidate);\n      return _this._peerConnection.addIceCandidate(candidate);\n    }).catch(function (error) {\n      // NOTE(mmalavalli): Firefox 68+ now generates an RTCIceCandidate with an\n      // empty candidate string to signal end-of-candidates, followed by a null\n      // candidate. As of now, Chrome and Safari reject this RTCIceCandidate. Since\n      // this does not affect the media connection between Firefox 68+ and Chrome/Safari\n      // in Peer-to-Peer Rooms, we suppress the Error and log a warning message.\n      //\n      // Chrome bug: https://bugs.chromium.org/p/chromium/issues/detail?id=978582\n      //\n      _this._log.warn(\"Failed to add RTCIceCandidate \" + (candidate ? \"\\\"\" + candidate.candidate + \"\\\"\" : 'null') + \": \" + error.message);\n    });\n  };\n  /**\n   * Add ICE candidates to the {@link PeerConnectionV2}.\n   * @private\n   * @param {Array<object>} candidates\n   * @returns {Promise<void>}\n   */\n\n\n  PeerConnectionV2.prototype._addIceCandidates = function (candidates) {\n    return Promise.all(candidates.map(this._addIceCandidate, this)).then(function () {});\n  };\n  /**\n   * Add a new RTCRtpTransceiver or update an existing RTCRtpTransceiver for the\n   * given MediaStreamTrack.\n   * @private\n   * @param {MediaStreamTrack} track\n   * @returns {RTCRtpTransceiver}\n   */\n\n\n  PeerConnectionV2.prototype._addOrUpdateTransceiver = function (track) {\n    var _this = this;\n\n    var transceiver = takeRecycledTransceiver(this, track.kind);\n\n    if (transceiver && transceiver.sender) {\n      var oldTrackId = transceiver.sender.track ? transceiver.sender.track.id : null;\n\n      if (oldTrackId) {\n        this._log.warn(\"Reusing transceiver: \" + transceiver.mid + \"] \" + oldTrackId + \" => \" + track.id);\n      } // NOTE(mpatwardhan):remember this transceiver while we replace track.\n      // we recycle transceivers that are not in use after 'negotiationCompleted', but we want to prevent\n      // this one from getting recycled while replaceTrack is pending.\n\n\n      this._replaceTrackPromises.set(transceiver, transceiver.sender.replaceTrack(track).then(function () {\n        transceiver.direction = 'sendrecv';\n      }, function () {// Do nothing.\n      }).finally(function () {\n        _this._replaceTrackPromises.delete(transceiver);\n      }));\n\n      return transceiver;\n    }\n\n    return this._peerConnection.addTransceiver(track);\n  };\n  /**\n   * Check the {@link IceBox}.\n   * @private\n   * @param {RTCSessionDescriptionInit} description\n   * @returns {Promise<void>}\n   */\n\n\n  PeerConnectionV2.prototype._checkIceBox = function (description) {\n    var ufrag = getUfrag(description);\n\n    if (!ufrag) {\n      return Promise.resolve();\n    }\n\n    var candidates = this._remoteCandidates.setUfrag(ufrag);\n\n    return this._addIceCandidates(candidates);\n  };\n  /**\n   * Create an answer and set it on the {@link PeerConnectionV2}.\n   * @private\n   * @param {RTCSessionDescriptionInit} offer\n   * @returns {Promise<boolean>}\n   */\n\n\n  PeerConnectionV2.prototype._answer = function (offer) {\n    var _this = this;\n\n    return Promise.resolve().then(function () {\n      if (!_this._negotiationRole) {\n        _this._negotiationRole = 'answerer';\n      }\n\n      return _this._setRemoteDescription(offer);\n    }).catch(function () {\n      throw new MediaClientRemoteDescFailedError();\n    }).then(function () {\n      return _this._peerConnection.createAnswer();\n    }).then(function (answer) {\n      if (isFirefox) {\n        // NOTE(mmalavalli): We work around Chromium bug 1106157 by disabling\n        // RTX in Firefox 79+. For more details about the bug, please go here:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1106157\n        answer = new _this._RTCSessionDescription({\n          sdp: disableRtx(answer.sdp),\n          type: answer.type\n        });\n      } else {\n        answer = workaroundIssue8329(answer);\n      } // NOTE(mpatwardhan): Upcoming chrome versions are going to remove ssrc attributes\n      // mslabel and label. See this bug https://bugs.chromium.org/p/webrtc/issues/detail?id=7110\n      // and PSA: https://groups.google.com/forum/#!searchin/discuss-webrtc/PSA%7Csort:date/discuss-webrtc/jcZO-Wj0Wus/k2XvPCvoAwAJ\n      // We are not referencing those attributes, but this changes goes ahead and removes them to see if it works.\n      // this also helps reduce bytes on wires\n\n\n      var updatedSdp = removeSSRCAttributes(answer.sdp, ['mslabel', 'label']);\n\n      if (_this._shouldApplySimulcast) {\n        var sdpWithoutSimulcast = updatedSdp;\n        updatedSdp = _this._setSimulcast(sdpWithoutSimulcast, _this._trackIdsToAttributes); // NOTE(syerrapragada): VMS does not support H264 simulcast. So,\n        // unset simulcast for sections in local offer where corresponding\n        // sections in answer doesn't have vp8 as preferred codec and reapply offer.\n\n        updatedSdp = _this._revertSimulcast(updatedSdp, sdpWithoutSimulcast, offer.sdp);\n      } // NOTE(mmalavalli): Work around Chromium bug 1074421.\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=1074421\n\n\n      updatedSdp = updatedSdp.replace(/42e015/g, '42e01f');\n      return _this._setLocalDescription({\n        type: answer.type,\n        sdp: updatedSdp\n      });\n    }).then(function () {\n      return _this._checkIceBox(offer);\n    }).then(function () {\n      return _this._queuedDescription && _this._updateDescription(_this._queuedDescription);\n    }).then(function () {\n      _this._queuedDescription = null;\n      return _this._maybeReoffer(_this._peerConnection.localDescription);\n    }).catch(function (error) {\n      var errorToThrow = error instanceof MediaClientRemoteDescFailedError ? error : new MediaClientLocalDescFailedError();\n\n      _this._publishMediaWarning({\n        message: 'Failed to _answer',\n        code: errorToThrow.code,\n        error: error\n      });\n\n      throw errorToThrow;\n    });\n  };\n  /**\n   * Close the underlying RTCPeerConnection. Returns false if the\n   * RTCPeerConnection was already closed.\n   * @private\n   * @returns {boolean}\n   */\n\n\n  PeerConnectionV2.prototype._close = function () {\n    this._iceConnectionMonitor.stop();\n\n    if (this._peerConnection.signalingState !== 'closed') {\n      this._peerConnection.close();\n\n      this.preempt('closed');\n\n      this._encodingParameters.removeListener('changed', this._onEncodingParametersChanged);\n\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Handle a \"connectionstatechange\" event.\n   * @private\n   * @returns {void}\n   */\n\n\n  PeerConnectionV2.prototype._handleConnectionStateChange = function () {\n    this.emit('connectionStateChanged');\n  };\n  /**\n   * Handle a \"datachannel\" event.\n   * @private\n   * @param {RTCDataChannelEvent} event\n   * @returns {void}\n   */\n\n\n  PeerConnectionV2.prototype._handleDataChannelEvent = function (event) {\n    var _this = this;\n\n    var dataChannel = event.channel;\n    var dataTrackReceiver = new DataTrackReceiver(dataChannel);\n\n    this._dataTrackReceivers.add(dataTrackReceiver);\n\n    dataChannel.addEventListener('close', function () {\n      _this._dataTrackReceivers.delete(dataTrackReceiver);\n    });\n    this.emit('trackAdded', dataTrackReceiver);\n  };\n  /**\n   * Handle a glare scenario on the {@link PeerConnectionV2}.\n   * @private\n   * @param {RTCSessionDescriptionInit} offer\n   * @returns {Promise<void>}\n   */\n\n\n  PeerConnectionV2.prototype._handleGlare = function (offer) {\n    var _this = this;\n\n    this._log.debug('Glare detected; rolling back');\n\n    if (this._isRestartingIce) {\n      this._log.debug('An ICE restart was in progress; we\\'ll need to restart ICE again after rolling back');\n\n      this._isRestartingIce = false;\n      this._shouldRestartIce = true;\n    }\n\n    return Promise.resolve().then(function () {\n      _this._trackIdsToAttributes = new Map(_this._appliedTrackIdsToAttributes);\n      return _this._setLocalDescription({\n        type: 'rollback'\n      });\n    }).then(function () {\n      _this._needsAnswer = false;\n      return _this._answer(offer);\n    }).then(function (didReoffer) {\n      return didReoffer ? Promise.resolve() : _this._offer();\n    });\n  };\n\n  PeerConnectionV2.prototype._publishMediaWarning = function (_a) {\n    var message = _a.message,\n        code = _a.code,\n        error = _a.error,\n        sdp = _a.sdp;\n\n    this._eventObserver.emit('event', {\n      level: 'warning',\n      name: 'error',\n      group: 'media',\n      payload: {\n        message: message,\n        code: code,\n        context: JSON.stringify({\n          error: error.message,\n          sdp: sdp\n        })\n      }\n    });\n  };\n  /**\n   * Handle an ICE candidate event.\n   * @private\n   * @param {Event} event\n   * @returns {void}\n   */\n\n\n  PeerConnectionV2.prototype._handleIceCandidateEvent = function (event) {\n    if (event.candidate) {\n      this._log.debug('Clearing ICE gathering timeout');\n\n      this._didGenerateLocalCandidates = true;\n\n      this._iceGatheringTimeout.clear();\n\n      this._localCandidates.push(event.candidate);\n    }\n\n    var peerConnectionState = {\n      ice: {\n        candidates: this._isIceLite ? [] : this._localCandidates.slice(),\n        ufrag: this._localUfrag\n      },\n      id: this.id\n    };\n\n    if (!event.candidate) {\n      peerConnectionState.ice.complete = true;\n    }\n\n    if (!(this._isIceLite && event.candidate)) {\n      peerConnectionState.ice.revision = this._localCandidatesRevision++;\n      this.emit('candidates', peerConnectionState);\n    }\n  };\n  /**\n   * Handle an ICE connection state change event.\n   * @private\n   * @returns {void}\n   */\n\n\n  PeerConnectionV2.prototype._handleIceConnectionStateChange = function () {\n    var _this = this;\n\n    var iceConnectionState = this._peerConnection.iceConnectionState;\n    var isIceConnectedOrComplete = ['connected', 'completed'].includes(iceConnectionState);\n    var log = this._log;\n    log.debug(\"ICE connection state is \\\"\" + iceConnectionState + \"\\\"\");\n\n    if (isIceConnectedOrComplete) {\n      this._iceReconnectTimeout.clear();\n\n      this._iceRestartBackoff.reset();\n    }\n\n    if (this._lastIceConnectionState !== 'failed' && iceConnectionState === 'failed' && !this._shouldRestartIce && !this._isRestartingIce) {\n      // Case 1: Transition to \"failed\".\n      log.warn('ICE failed');\n\n      this._initiateIceRestartBackoff();\n    } else if (['disconnected', 'failed'].includes(this._lastIceConnectionState) && isIceConnectedOrComplete) {\n      // Case 2: Transition from \"disconnected\" or \"failed\".\n      log.debug('ICE reconnected');\n    } // start monitor media when connected, and continue to monitor while state is complete-disconnected-connected.\n\n\n    if (iceConnectionState === 'connected') {\n      this._isIceConnectionInactive = false;\n\n      this._iceConnectionMonitor.start(function () {\n        // note: iceConnection monitor waits for iceConnectionState=disconnected for\n        // detecting inactivity. Its possible that it may know about disconnected before _handleIceConnectionStateChange\n        _this._iceConnectionMonitor.stop();\n\n        if (!_this._shouldRestartIce && !_this._isRestartingIce) {\n          log.warn('ICE Connection Monitor detected inactivity');\n          _this._isIceConnectionInactive = true;\n\n          _this._initiateIceRestartBackoff();\n\n          _this.emit('iceConnectionStateChanged');\n\n          _this.emit('connectionStateChanged');\n        }\n      });\n    } else if (!['disconnected', 'completed'].includes(iceConnectionState)) {\n      // don't stop monitoring for disconnected or completed.\n      this._iceConnectionMonitor.stop();\n\n      this._isIceConnectionInactive = false;\n    }\n\n    this._lastIceConnectionState = iceConnectionState;\n    this.emit('iceConnectionStateChanged');\n  };\n  /**\n   * Handle ICE gathering timeout.\n   * @private\n   * @returns {void}\n   */\n\n\n  PeerConnectionV2.prototype._handleIceGatheringTimeout = function () {\n    this._log.warn('ICE failed to gather any local candidates');\n\n    this._iceGatheringFailed = true;\n\n    this._initiateIceRestartBackoff();\n\n    this.emit('iceConnectionStateChanged');\n    this.emit('connectionStateChanged');\n  };\n  /**\n   * Handle an ICE gathering state change event.\n   * @private\n   * @returns {void}\n   */\n\n\n  PeerConnectionV2.prototype._handleIceGatheringStateChange = function () {\n    var iceGatheringState = this._peerConnection.iceGatheringState;\n    var log = this._log;\n    log.debug(\"ICE gathering state is \\\"\" + iceGatheringState + \"\\\"\"); // NOTE(mmalavalli): Start the ICE gathering timeout only if the RTCPeerConnection\n    // has started gathering candidates for the first time since the initial offer/answer\n    // or an offer/answer with ICE restart.\n\n    var _a = this._iceGatheringTimeout,\n        delay = _a.delay,\n        isSet = _a.isSet;\n\n    if (iceGatheringState === 'gathering' && !this._didGenerateLocalCandidates && !isSet) {\n      log.debug(\"Starting ICE gathering timeout: \" + delay);\n      this._iceGatheringFailed = false;\n\n      this._iceGatheringTimeout.start();\n    }\n  };\n  /**\n   * Handle a signaling state change event.\n   * @private\n   * @returns {void}\n   */\n\n\n  PeerConnectionV2.prototype._handleSignalingStateChange = function () {\n    if (this._peerConnection.signalingState === 'stable') {\n      this._appliedTrackIdsToAttributes = new Map(this._trackIdsToAttributes);\n    }\n  };\n  /**\n   * Handle a track event.\n   * @private\n   * @param {RTCTrackEvent} event\n   * @returns {void}\n   */\n\n\n  PeerConnectionV2.prototype._handleTrackEvent = function (event) {\n    var _this = this;\n\n    var sdp = this._peerConnection.remoteDescription ? this._peerConnection.remoteDescription.sdp : null;\n    this._trackMatcher = this._trackMatcher || new TrackMatcher();\n\n    this._trackMatcher.update(sdp);\n\n    var mediaStreamTrack = event.track;\n    var signaledTrackId = this._trackMatcher.match(event) || mediaStreamTrack.id;\n    var mediaTrackReceiver = new MediaTrackReceiver(signaledTrackId, mediaStreamTrack); // NOTE(mmalavalli): \"ended\" is not fired on the remote MediaStreamTrack when\n    // the remote peer removes a track. So, when this MediaStreamTrack is re-used\n    // for a different track due to the remote peer calling RTCRtpSender.replaceTrack(),\n    // we delete the previous MediaTrackReceiver that owned this MediaStreamTrack\n    // before adding the new MediaTrackReceiver.\n\n    this._mediaTrackReceivers.forEach(function (trackReceiver) {\n      if (trackReceiver.track.id === mediaTrackReceiver.track.id) {\n        _this._mediaTrackReceivers.delete(trackReceiver);\n      }\n    });\n\n    this._mediaTrackReceivers.add(mediaTrackReceiver);\n\n    mediaStreamTrack.addEventListener('ended', function () {\n      return _this._mediaTrackReceivers.delete(mediaTrackReceiver);\n    });\n    this.emit('trackAdded', mediaTrackReceiver);\n  };\n  /**\n   * Initiate ICE Restart.\n   * @private\n   * @returns {void}\n   */\n\n\n  PeerConnectionV2.prototype._initiateIceRestart = function () {\n    if (this._peerConnection.signalingState === 'closed') {\n      return;\n    }\n\n    var log = this._log;\n    log.warn('Attempting to restart ICE');\n    this._didGenerateLocalCandidates = false;\n    this._isIceRestartBackoffInProgress = false;\n    this._shouldRestartIce = true;\n    var _a = this._iceReconnectTimeout,\n        delay = _a.delay,\n        isSet = _a.isSet;\n\n    if (!isSet) {\n      log.debug(\"Starting ICE reconnect timeout: \" + delay);\n\n      this._iceReconnectTimeout.start();\n    }\n\n    this.offer().catch(function (ex) {\n      log.error(\"offer failed in _initiateIceRestart with: \" + ex.message);\n    });\n  };\n  /**\n   * Schedule an ICE Restart.\n   * @private\n   * @returns {void}\n   */\n\n\n  PeerConnectionV2.prototype._initiateIceRestartBackoff = function () {\n    var _this = this;\n\n    if (this._peerConnection.signalingState === 'closed' || this._isIceRestartBackoffInProgress) {\n      return;\n    }\n\n    this._log.warn('An ICE restart has been scheduled');\n\n    this._isIceRestartBackoffInProgress = true;\n\n    this._iceRestartBackoff.backoff(function () {\n      return _this._initiateIceRestart();\n    });\n  };\n  /**\n   * Conditionally re-offer.\n   * @private\n   * @param {?RTCSessionDescriptionInit} localDescription\n   * @returns {Promise<boolean>}\n   */\n\n\n  PeerConnectionV2.prototype._maybeReoffer = function (localDescription) {\n    var shouldReoffer = this._shouldOffer;\n\n    if (localDescription && localDescription.sdp) {\n      // NOTE(mmalavalli): If the local RTCSessionDescription has fewer audio and/or\n      // video send* m= lines than the corresponding RTCRtpSenders with non-null\n      // MediaStreamTracks, it means that the newly added RTCRtpSenders require\n      // renegotiation.\n      var senders_1 = this._peerConnection.getSenders().filter(function (sender) {\n        return sender.track;\n      });\n\n      shouldReoffer = ['audio', 'video'].reduce(function (shouldOffer, kind) {\n        var mediaSections = getMediaSections(localDescription.sdp, kind, '(sendrecv|sendonly)');\n        var sendersOfKind = senders_1.filter(isSenderOfKind.bind(null, kind));\n        return shouldOffer || mediaSections.length < sendersOfKind.length;\n      }, shouldReoffer); // NOTE(mroberts): We also need to re-offer if we have a DataTrack to share\n      // but no m= application section.\n\n      var hasDataTrack = this._dataChannels.size > 0;\n      var hasApplicationMediaSection = getMediaSections(localDescription.sdp, 'application').length > 0;\n      var needsApplicationMediaSection = hasDataTrack && !hasApplicationMediaSection;\n      shouldReoffer = shouldReoffer || needsApplicationMediaSection;\n    }\n\n    var promise = shouldReoffer ? this._offer() : Promise.resolve();\n    return promise.then(function () {\n      return shouldReoffer;\n    });\n  };\n  /**\n   * Create an offer and set it on the {@link PeerConnectionV2}.\n   * @private\n   * @returns {Promise<void>}\n   */\n\n\n  PeerConnectionV2.prototype._offer = function () {\n    var _this = this;\n\n    var offerOptions = Object.assign({}, this._offerOptions);\n    this._needsAnswer = true;\n\n    if (this._shouldRestartIce) {\n      this._shouldRestartIce = false;\n      this._isRestartingIce = true;\n      offerOptions.iceRestart = true;\n    }\n\n    return Promise.all(this._replaceTrackPromises.values()).then(function () {\n      return _this._peerConnection.createOffer(offerOptions);\n    }).catch(function (error) {\n      var errorToThrow = new MediaClientLocalDescFailedError();\n\n      _this._publishMediaWarning({\n        message: 'Failed to create offer',\n        code: errorToThrow.code,\n        error: error\n      });\n\n      throw errorToThrow;\n    }).then(function (offer) {\n      if (isFirefox) {\n        // NOTE(mmalavalli): We work around Chromium bug 1106157 by disabling\n        // RTX in Firefox 79+. For more details about the bug, please go here:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1106157\n        offer = new _this._RTCSessionDescription({\n          sdp: disableRtx(offer.sdp),\n          type: offer.type\n        });\n      } else {\n        offer = workaroundIssue8329(offer);\n      } // NOTE(mpatwardhan): upcoming chrome versions are going to remove ssrc attributes\n      // mslabel and label. See this bug https://bugs.chromium.org/p/webrtc/issues/detail?id=7110\n      // and PSA: https://groups.google.com/forum/#!searchin/discuss-webrtc/PSA%7Csort:date/discuss-webrtc/jcZO-Wj0Wus/k2XvPCvoAwAJ\n      // Looks like we are not referencing those attributes, but this changes goes ahead and removes them to see if it works.\n      // this also helps reduce bytes on wires\n\n\n      var sdp = removeSSRCAttributes(offer.sdp, ['mslabel', 'label']);\n      sdp = _this._peerConnection.remoteDescription ? filterLocalCodecs(sdp, _this._peerConnection.remoteDescription.sdp) : sdp;\n\n      var updatedSdp = _this._setCodecPreferences(sdp, _this._preferredAudioCodecs, _this._preferredVideoCodecs);\n\n      _this._shouldOffer = false;\n\n      if (!_this._negotiationRole) {\n        _this._negotiationRole = 'offerer';\n      }\n\n      if (_this._shouldApplySimulcast) {\n        _this._localDescriptionWithoutSimulcast = {\n          type: 'offer',\n          sdp: updatedSdp\n        };\n        updatedSdp = _this._setSimulcast(updatedSdp, _this._trackIdsToAttributes);\n      }\n\n      return _this._setLocalDescription({\n        type: 'offer',\n        sdp: updatedSdp\n      });\n    });\n  };\n  /**\n   * Get the MediaTrackSender ID of the given MediaStreamTrack ID.\n   * Since a MediaTrackSender's underlying MediaStreamTrack can be\n   * replaced, the corresponding IDs can mismatch.\n   * @private\n   * @param {Track.ID} id\n   * @returns {Track.ID}\n   */\n\n\n  PeerConnectionV2.prototype._getMediaTrackSenderId = function (trackId) {\n    var mediaTrackSender = Array.from(this._rtpSenders.keys()).find(function (_a) {\n      var id = _a.track.id;\n      return id === trackId;\n    });\n    return mediaTrackSender ? mediaTrackSender.id : trackId;\n  };\n  /**\n   * Add or rewrite local MediaStreamTrack IDs in the given RTCSessionDescription.\n   * @private\n   * @param {RTCSessionDescription} description\n   * @return {RTCSessionDescription}\n   */\n\n\n  PeerConnectionV2.prototype._addOrRewriteLocalTrackIds = function (description) {\n    var _this = this;\n\n    var transceivers = this._peerConnection.getTransceivers();\n\n    var activeTransceivers = transceivers.filter(function (_a) {\n      var sender = _a.sender,\n          stopped = _a.stopped;\n      return !stopped && sender && sender.track;\n    }); // NOTE(mmalavalli): There is no guarantee that MediaStreamTrack IDs will be present in\n    // SDPs, and even if they are, there is no guarantee that they will be the same as the\n    // actual MediaStreamTrack IDs. So, we add or re-write the actual MediaStreamTrack IDs\n    // to the assigned m= sections here.\n\n    var assignedTransceivers = activeTransceivers.filter(function (_a) {\n      var mid = _a.mid;\n      return mid;\n    });\n    var midsToTrackIds = new Map(assignedTransceivers.map(function (_a) {\n      var mid = _a.mid,\n          sender = _a.sender;\n      return [mid, _this._getMediaTrackSenderId(sender.track.id)];\n    }));\n    var sdp1 = addOrRewriteTrackIds(description.sdp, midsToTrackIds); // NOTE(mmalavalli): Chrome and Safari do not apply the offer until they get an answer.\n    // So, we add or re-write the actual MediaStreamTrack IDs to the unassigned m= sections here.\n\n    var unassignedTransceivers = activeTransceivers.filter(function (_a) {\n      var mid = _a.mid;\n      return !mid;\n    });\n    var newTrackIdsByKind = new Map(['audio', 'video'].map(function (kind) {\n      return [kind, unassignedTransceivers.filter(function (_a) {\n        var sender = _a.sender;\n        return sender.track.kind === kind;\n      }).map(function (_a) {\n        var sender = _a.sender;\n        return _this._getMediaTrackSenderId(sender.track.id);\n      })];\n    }));\n    var sdp2 = addOrRewriteNewTrackIds(sdp1, midsToTrackIds, newTrackIdsByKind);\n    return new this._RTCSessionDescription({\n      sdp: sdp2,\n      type: description.type\n    });\n  };\n  /**\n   * Rollback and apply the given offer.\n   * @private\n   * @param {RTCSessionDescriptionInit} offer\n   * @returns {Promise<void>}\n   */\n\n\n  PeerConnectionV2.prototype._rollbackAndApplyOffer = function (offer) {\n    var _this = this;\n\n    return this._setLocalDescription({\n      type: 'rollback'\n    }).then(function () {\n      return _this._setLocalDescription(offer);\n    });\n  };\n  /**\n   * Set a local description on the {@link PeerConnectionV2}.\n   * @private\n   * @param {RTCSessionDescription|RTCSessionDescriptionInit} description\n   * @returns {Promise<void>}\n   */\n\n\n  PeerConnectionV2.prototype._setLocalDescription = function (description) {\n    var _this = this;\n\n    if (description.type !== 'rollback' && this._shouldApplyDtx) {\n      description = new this._RTCSessionDescription({\n        sdp: enableDtxForOpus(description.sdp),\n        type: description.type\n      });\n    }\n\n    return this._peerConnection.setLocalDescription(description).catch(function (error) {\n      _this._log.warn(\"Calling setLocalDescription with an RTCSessionDescription of type \\\"\" + description.type + \"\\\" failed with the error \\\"\" + error.message + \"\\\".\", error);\n\n      var errorToThrow = new MediaClientLocalDescFailedError();\n      var publishWarning = {\n        message: \"Calling setLocalDescription with an RTCSessionDescription of type \\\"\" + description.type + \"\\\" failed\",\n        code: errorToThrow.code,\n        error: error\n      };\n\n      if (description.sdp) {\n        _this._log.warn(\"The SDP was \" + description.sdp);\n\n        publishWarning.sdp = description.sdp;\n      }\n\n      _this._publishMediaWarning(publishWarning);\n\n      throw errorToThrow;\n    }).then(function () {\n      if (description.type !== 'rollback') {\n        _this._localDescription = _this._addOrRewriteLocalTrackIds(description); // NOTE(mmalavalli): In order for this feature to be backward compatible with older\n        // SDK versions which to not support opus DTX, we append \"usedtx=1\" to the local SDP\n        // only while applying it. We will not send it over the wire to prevent inadvertent\n        // enabling of opus DTX in older SDKs. Newer SDKs will append \"usedtx=1\" by themselves\n        // if the developer has requested opus DTX to be enabled. (JSDK-3063)\n\n        if (_this._shouldApplyDtx) {\n          _this._localDescription = new _this._RTCSessionDescription({\n            sdp: enableDtxForOpus(_this._localDescription.sdp, []),\n            type: _this._localDescription.type\n          });\n        }\n\n        _this._localCandidates = [];\n\n        if (description.type === 'offer') {\n          _this._descriptionRevision++;\n        } else if (description.type === 'answer') {\n          _this._lastStableDescriptionRevision = _this._descriptionRevision;\n          negotiationCompleted(_this);\n        }\n\n        _this._localUfrag = getUfrag(description);\n\n        _this.emit('description', _this.getState());\n      }\n    });\n  };\n  /**\n   * Set a remote RTCSessionDescription on the {@link PeerConnectionV2}.\n   * @private\n   * @param {RTCSessionDescriptionInit} description\n   * @returns {Promise<void>}\n   */\n\n\n  PeerConnectionV2.prototype._setRemoteDescription = function (description) {\n    var _this = this;\n\n    if (description.sdp) {\n      description.sdp = this._setCodecPreferences(description.sdp, this._preferredAudioCodecs, this._preferredVideoCodecs);\n\n      if (this._shouldApplyDtx) {\n        description.sdp = enableDtxForOpus(description.sdp);\n      } else {\n        // NOTE(mmalavalli): Remove \"usedtx=1\" from opus's fmtp line if present\n        // since DTX is disabled.\n        description.sdp = enableDtxForOpus(description.sdp, []);\n      }\n\n      if (isFirefox) {\n        // NOTE(mroberts): Do this to reduce our MediaStream count in Firefox. By\n        // mapping MediaStream IDs in the SDP to \"-\", we ensure the \"track\" event\n        // doesn't include any new MediaStreams in Firefox. Its `streams` member\n        // will always be the empty Array.\n        description.sdp = filterOutMediaStreamIds(description.sdp);\n      }\n\n      if (!this._peerConnection.remoteDescription) {\n        this._isIceLite = /a=ice-lite/.test(description.sdp);\n      }\n    }\n\n    description = new this._RTCSessionDescription(description); // eslint-disable-next-line consistent-return\n\n    return Promise.resolve().then(function () {\n      // NOTE(syerrapragada): VMS does not support H264 simulcast. So,\n      // unset simulcast for sections in local offer where corresponding\n      // sections in answer doesn't have vp8 as preferred codec and reapply offer.\n      if (description.type === 'answer' && _this._localDescriptionWithoutSimulcast) {\n        // NOTE(mpatwardhan):if we were using adaptive simulcast, and if its not supported by server\n        // revert simulcast even for vp8.\n        var adaptiveSimulcastEntry = _this._preferredVideoCodecs.find(function (cs) {\n          return 'adaptiveSimulcast' in cs;\n        });\n\n        var revertForAll = !!adaptiveSimulcastEntry && adaptiveSimulcastEntry.adaptiveSimulcast === false;\n\n        var sdpWithoutSimulcastForNonVP8MediaSections = _this._revertSimulcast(_this._localDescription.sdp, _this._localDescriptionWithoutSimulcast.sdp, description.sdp, revertForAll);\n\n        _this._localDescriptionWithoutSimulcast = null;\n\n        if (sdpWithoutSimulcastForNonVP8MediaSections !== _this._localDescription.sdp) {\n          return _this._rollbackAndApplyOffer({\n            type: _this._localDescription.type,\n            sdp: sdpWithoutSimulcastForNonVP8MediaSections\n          });\n        }\n      }\n    }).then(function () {\n      return _this._peerConnection.setRemoteDescription(description);\n    }).then(function () {\n      if (description.type === 'answer') {\n        if (_this._isRestartingIce) {\n          _this._log.debug('An ICE restart was in-progress and is now completed');\n\n          _this._isRestartingIce = false;\n        }\n\n        negotiationCompleted(_this);\n      }\n    }, function (error) {\n      _this._log.warn(\"Calling setRemoteDescription with an RTCSessionDescription of type \\\"\" + description.type + \"\\\" failed with the error \\\"\" + error.message + \"\\\".\", error);\n\n      if (description.sdp) {\n        _this._log.warn(\"The SDP was \" + description.sdp);\n      }\n\n      throw error;\n    });\n  };\n  /**\n   * Update the {@link PeerConnectionV2}'s description.\n   * @private\n   * @param {RTCSessionDescriptionInit} description\n   * @returns {Promise<void>}\n   */\n\n\n  PeerConnectionV2.prototype._updateDescription = function (description) {\n    var _this = this;\n\n    switch (description.type) {\n      case 'answer':\n      case 'pranswer':\n        if (description.revision !== this._descriptionRevision || this._peerConnection.signalingState !== 'have-local-offer') {\n          return Promise.resolve();\n        }\n\n        this._descriptionRevision = description.revision;\n        break;\n\n      case 'close':\n        return this._close();\n\n      case 'create-offer':\n        if (description.revision <= this._lastStableDescriptionRevision) {\n          return Promise.resolve();\n        } else if (this._needsAnswer) {\n          this._queuedDescription = description;\n          return Promise.resolve();\n        }\n\n        this._descriptionRevision = description.revision;\n        return this._offer();\n\n      case 'offer':\n        if (description.revision <= this._lastStableDescriptionRevision || this._peerConnection.signalingState === 'closed') {\n          return Promise.resolve();\n        }\n\n        if (this._peerConnection.signalingState === 'have-local-offer') {\n          // NOTE(mpatwardhan): For a peer connection\n          // 1) createOffer always generate SDP with `setup:actpass`\n          // 2) when remote description is set `setup:active`  - the answer generated selects the dtls role of setup:passive\n          // 3) when remote description is set `setup:passive` - the answer generated selects the dtls role of setup:active\n          // 4) when remote description is set `setup:actpass` - the answer generated uses the previously negotiated role (if not negotiated previously setup:active is used)\n          // This test shows the  behavior: https://github.com/twilio/twilio-webrtc.js/blob/master/test/integration/spec/rtcpeerconnection.js#L936\n          // with glare handling (if dtls role was not negotiated before ) the generated answer will set setup:active.\n          // we do not want that. lets wait for \"initial negotiation\" before attempting glare handling.\n          if (this._needsAnswer && this._lastStableDescriptionRevision === 0) {\n            this._queuedDescription = description;\n            return Promise.resolve();\n          }\n\n          this._descriptionRevision = description.revision;\n          return this._handleGlare(description);\n        }\n\n        this._descriptionRevision = description.revision;\n        return this._answer(description).then(function () {});\n\n      default: // Do nothing.\n\n    } // Handle answer or pranswer.\n\n\n    var revision = description.revision;\n    return Promise.resolve().then(function () {\n      return _this._setRemoteDescription(description);\n    }).catch(function (error) {\n      var errorToThrow = new MediaClientRemoteDescFailedError();\n\n      _this._publishMediaWarning({\n        message: \"Calling setRemoteDescription with an RTCSessionDescription of type \\\"\" + description.type + \"\\\" failed\",\n        code: errorToThrow.code,\n        error: error,\n        sdp: description.sdp\n      });\n\n      throw errorToThrow;\n    }).then(function () {\n      _this._lastStableDescriptionRevision = revision;\n      _this._needsAnswer = false;\n      return _this._checkIceBox(description);\n    }).then(function () {\n      return _this._queuedDescription && _this._updateDescription(_this._queuedDescription);\n    }).then(function () {\n      _this._queuedDescription = null;\n      return _this._maybeReoffer(_this._peerConnection.localDescription).then(function () {});\n    });\n  };\n  /**\n   * Update the {@link PeerConnectionV2}'s ICE candidates.\n   * @private\n   * @param {object} iceState\n   * @returns {Promise<void>}\n   */\n\n\n  PeerConnectionV2.prototype._updateIce = function (iceState) {\n    var candidates = this._remoteCandidates.update(iceState);\n\n    return this._addIceCandidates(candidates);\n  };\n  /**\n   * Add a {@link DataTrackSender} to the {@link PeerConnectionV2}.\n   * @param {DataTrackSender} dataTrackSender\n   * @returns {void}\n   */\n\n\n  PeerConnectionV2.prototype.addDataTrackSender = function (dataTrackSender) {\n    if (this._dataChannels.has(dataTrackSender)) {\n      return;\n    }\n\n    try {\n      var dataChannelDict = {\n        ordered: dataTrackSender.ordered\n      };\n\n      if (dataTrackSender.maxPacketLifeTime !== null) {\n        dataChannelDict.maxPacketLifeTime = dataTrackSender.maxPacketLifeTime;\n      }\n\n      if (dataTrackSender.maxRetransmits !== null) {\n        dataChannelDict.maxRetransmits = dataTrackSender.maxRetransmits;\n      }\n\n      var dataChannel = this._peerConnection.createDataChannel(dataTrackSender.id, dataChannelDict);\n\n      dataTrackSender.addDataChannel(dataChannel);\n\n      this._dataChannels.set(dataTrackSender, dataChannel);\n    } catch (error) {\n      this._log.warn(\"Error creating an RTCDataChannel for DataTrack \\\"\" + dataTrackSender.id + \"\\\": \" + error.message);\n    }\n  };\n\n  PeerConnectionV2.prototype._handleQueuedPublisherHints = function () {\n    var _this = this;\n\n    if (this._peerConnection.signalingState === 'stable') {\n      this._mediaTrackSenderToPublisherHints.forEach(function (_a, mediaTrackSender) {\n        var deferred = _a.deferred,\n            encodings = _a.encodings;\n\n        _this._mediaTrackSenderToPublisherHints.delete(mediaTrackSender);\n\n        _this._setPublisherHint(mediaTrackSender, encodings).then(function (result) {\n          return deferred.resolve(result);\n        }).catch(function (error) {\n          return deferred.reject(error);\n        });\n      });\n    }\n  };\n  /**\n   * updates encodings for simulcast layers of given sender.\n   * @param {RTCRtpSender} sender\n   * @param {Array<{enabled: boolean, layer_index: number}>|null} encodings\n   * @returns {Promise<string>} string indicating result of the operation. can be one of\n   *  \"OK\", \"INVALID_HINT\", \"COULD_NOT_APPLY_HINT\", \"UNKNOWN_TRACK\"\n   */\n\n\n  PeerConnectionV2.prototype._setPublisherHint = function (mediaTrackSender, encodings) {\n    var _this = this;\n\n    if (isFirefox) {\n      return Promise.resolve('COULD_NOT_APPLY_HINT');\n    }\n\n    if (this._mediaTrackSenderToPublisherHints.has(mediaTrackSender)) {\n      // skip any stale hint associated with the mediaTrackSender.\n      var queuedHint = this._mediaTrackSenderToPublisherHints.get(mediaTrackSender);\n\n      queuedHint.deferred.resolve('REQUEST_SKIPPED');\n\n      this._mediaTrackSenderToPublisherHints.delete(mediaTrackSender);\n    }\n\n    var sender = this._rtpSenders.get(mediaTrackSender);\n\n    if (!sender) {\n      this._log.warn('Could not apply publisher hint because RTCRtpSender was not found');\n\n      return Promise.resolve('UNKNOWN_TRACK');\n    }\n\n    if (this._peerConnection.signalingState === 'closed') {\n      this._log.warn('Could not apply publisher hint because signalingState was \"closed\"');\n\n      return Promise.resolve('COULD_NOT_APPLY_HINT');\n    }\n\n    if (this._peerConnection.signalingState !== 'stable') {\n      // enqueue this hint to be applied when pc becomes stable.\n      this._log.debug('Queuing up publisher hint because signalingState:', this._peerConnection.signalingState);\n\n      var deferred = defer();\n\n      this._mediaTrackSenderToPublisherHints.set(mediaTrackSender, {\n        deferred: deferred,\n        encodings: encodings\n      });\n\n      return deferred.promise;\n    }\n\n    var parameters = sender.getParameters();\n\n    if (encodings !== null) {\n      encodings.forEach(function (_a) {\n        var enabled = _a.enabled,\n            layerIndex = _a.layer_index;\n\n        if (parameters.encodings.length > layerIndex) {\n          _this._log.debug(\"layer:\" + layerIndex + \", active:\" + parameters.encodings[layerIndex].active + \" => \" + enabled);\n\n          parameters.encodings[layerIndex].active = enabled;\n        } else {\n          _this._log.warn(\"invalid layer:\" + layerIndex + \", active:\" + enabled);\n        }\n      });\n    } // Note(mpatwardhan): after publisher hints are applied, overwrite with default encodings\n    // to disable any encoding that shouldn't have been enabled by publisher_hints.\n    // When encodings===null (that is we are asked to reset encodings for replaceTrack)\n    // along with disabling encodings, clear active flag for encodings that should not be disabled\n\n\n    this._maybeUpdateEncodings(sender.track, parameters.encodings, encodings === null\n    /* trackReplaced */\n    );\n\n    return sender.setParameters(parameters).then(function () {\n      return 'OK';\n    }).catch(function (error) {\n      _this._log.error('Failed to apply publisher hints:', error);\n\n      return 'COULD_NOT_APPLY_HINT';\n    });\n  };\n  /**\n   * Add the {@link MediaTrackSender} to the {@link PeerConnectionV2}.\n   * @param {MediaTrackSender} mediaTrackSender\n   * @returns {void}\n   */\n\n\n  PeerConnectionV2.prototype.addMediaTrackSender = function (mediaTrackSender) {\n    var _this = this;\n\n    if (this._peerConnection.signalingState === 'closed' || this._rtpSenders.has(mediaTrackSender)) {\n      return;\n    }\n\n    var transceiver = this._addOrUpdateTransceiver(mediaTrackSender.track);\n\n    var sender = transceiver.sender;\n    mediaTrackSender.addSender(sender, function (encodings) {\n      return _this._setPublisherHint(mediaTrackSender, encodings);\n    });\n\n    this._rtpNewSenders.add(sender);\n\n    this._rtpSenders.set(mediaTrackSender, sender);\n  };\n  /**\n   * Close the {@link PeerConnectionV2}.\n   * @returns {void}\n   */\n\n\n  PeerConnectionV2.prototype.close = function () {\n    if (this._close()) {\n      this._descriptionRevision++;\n      this._localDescription = {\n        type: 'close'\n      };\n      this.emit('description', this.getState());\n    }\n  };\n  /**\n   * Get the {@link DataTrackReceiver}s and the {@link MediaTrackReceiver}s on the\n   * {@link PeerConnectionV2}.\n   * @returns {Array<DataTrackReceiver|MediaTrackReceiver>} trackReceivers\n   */\n\n\n  PeerConnectionV2.prototype.getTrackReceivers = function () {\n    return Array.from(this._dataTrackReceivers).concat(Array.from(this._mediaTrackReceivers));\n  };\n  /**\n   * Get the {@link PeerConnectionV2}'s state (specifically, its description).\n   * @returns {?object}\n   */\n\n\n  PeerConnectionV2.prototype.getState = function () {\n    if (!this._localDescription) {\n      return null;\n    } // NOTE(mpatwardhan): Return most recent localDescription. If the most recent local description is an\n    // answer, and this method is called for sending a \"sync\" message while the next remote offer is being processed,\n    // we need to send the most recent stable description revision instead of the current description revision,\n    // which is supposed to be for the next local answer.\n\n\n    var localDescriptionRevision = this._localDescription.type === 'answer' ? this._lastStableDescriptionRevision : this._descriptionRevision;\n    var localDescription = {\n      type: this._localDescription.type,\n      revision: localDescriptionRevision\n    };\n\n    if (this._localDescription.sdp) {\n      localDescription.sdp = this._localDescription.sdp;\n    }\n\n    return {\n      description: localDescription,\n      id: this.id\n    };\n  };\n  /**\n   * Create an offer and set it on the {@link PeerConnectionV2}.\n   * @returns {Promise<void>}\n   */\n\n\n  PeerConnectionV2.prototype.offer = function () {\n    var _this = this;\n\n    if (this._needsAnswer || this._isRestartingIce) {\n      this._shouldOffer = true;\n      return Promise.resolve();\n    }\n\n    return this.bracket('offering', function (key) {\n      _this.transition('updating', key);\n\n      var promise = _this._needsAnswer || _this._isRestartingIce ? Promise.resolve() : _this._offer();\n      return promise.then(function () {\n        _this.tryTransition('open', key);\n      }, function (error) {\n        _this.tryTransition('open', key);\n\n        throw error;\n      });\n    });\n  };\n  /**\n   * Remove a {@link DataTrackSender} from the {@link PeerConnectionV2}.\n   * @param {DataTrackSender} dataTrackSender\n   * @returns {void}\n   */\n\n\n  PeerConnectionV2.prototype.removeDataTrackSender = function (dataTrackSender) {\n    var dataChannel = this._dataChannels.get(dataTrackSender);\n\n    if (dataChannel) {\n      dataTrackSender.removeDataChannel(dataChannel);\n\n      this._dataChannels.delete(dataTrackSender);\n\n      dataChannel.close();\n    }\n  };\n  /**\n   * Remove the {@link MediaTrackSender} from the {@link PeerConnectionV2}.\n   * @param {MediaTrackSender} mediaTrackSender\n   * @returns {void}\n   */\n\n\n  PeerConnectionV2.prototype.removeMediaTrackSender = function (mediaTrackSender) {\n    var sender = this._rtpSenders.get(mediaTrackSender);\n\n    if (!sender) {\n      return;\n    }\n\n    if (this._peerConnection.signalingState !== 'closed') {\n      this._peerConnection.removeTrack(sender);\n    }\n\n    mediaTrackSender.removeSender(sender); // clean up any pending publisher hints associated with this mediaTrackSender.\n\n    if (this._mediaTrackSenderToPublisherHints.has(mediaTrackSender)) {\n      var queuedHint = this._mediaTrackSenderToPublisherHints.get(mediaTrackSender);\n\n      queuedHint.deferred.resolve('UNKNOWN_TRACK');\n\n      this._mediaTrackSenderToPublisherHints.delete(mediaTrackSender);\n    }\n\n    this._rtpNewSenders.delete(sender);\n\n    this._rtpSenders.delete(mediaTrackSender);\n  };\n  /**\n   * Set the RTCConfiguration on the underlying RTCPeerConnection.\n   * @param {RTCConfiguration} configuration\n   * @returns {void}\n   */\n\n\n  PeerConnectionV2.prototype.setConfiguration = function (configuration) {\n    if (typeof this._peerConnection.setConfiguration === 'function') {\n      this._peerConnection.setConfiguration(getConfiguration(configuration));\n    }\n  };\n  /**\n   * Set the ICE reconnect timeout period.\n   * @param {number} period - Period in milliseconds.\n   * @returns {this}\n   */\n\n\n  PeerConnectionV2.prototype.setIceReconnectTimeout = function (period) {\n    this._iceReconnectTimeout.setDelay(period);\n\n    this._log.debug('Updated ICE reconnection timeout period:', this._iceReconnectTimeout.delay);\n\n    return this;\n  };\n  /**\n   * Update the {@link PeerConnectionV2}.\n   * @param {object} peerConnectionState\n   * @returns {Promise<void>}\n   */\n\n\n  PeerConnectionV2.prototype.update = function (peerConnectionState) {\n    var _this = this;\n\n    return this.bracket('updating', function (key) {\n      if (_this.state === 'closed') {\n        return Promise.resolve();\n      }\n\n      _this.transition('updating', key);\n\n      var updates = [];\n\n      if (peerConnectionState.ice) {\n        updates.push(_this._updateIce(peerConnectionState.ice));\n      }\n\n      if (peerConnectionState.description) {\n        updates.push(_this._updateDescription(peerConnectionState.description));\n      }\n\n      return Promise.all(updates).then(function () {\n        _this.tryTransition('open', key);\n      }, function (error) {\n        _this.tryTransition('open', key);\n\n        throw error;\n      });\n    });\n  };\n  /**\n   * Get the {@link PeerConnectionV2}'s media statistics.\n   * @returns {Promise<StandardizedStatsResponse>}\n   */\n\n\n  PeerConnectionV2.prototype.getStats = function () {\n    var _this = this;\n\n    return getStatistics(this._peerConnection).then(function (response) {\n      return rewriteTrackIds(_this, response);\n    });\n  };\n\n  return PeerConnectionV2;\n}(StateMachine);\n\nfunction rewriteLocalTrackId(pcv2, stats) {\n  var trackId = pcv2._getMediaTrackSenderId(stats.trackId);\n\n  return Object.assign(stats, {\n    trackId: trackId\n  });\n}\n\nfunction rewriteTrackId(pcv2, stats) {\n  var receiver = __spreadArray([], __read(pcv2._mediaTrackReceivers)).find(function (receiver) {\n    return receiver.track.id === stats.trackId;\n  });\n\n  var trackId = receiver ? receiver.id : null;\n  return Object.assign(stats, {\n    trackId: trackId\n  });\n}\n\nfunction rewriteTrackIds(pcv2, response) {\n  return Object.assign(response, {\n    remoteAudioTrackStats: response.remoteAudioTrackStats.map(function (stats) {\n      return rewriteTrackId(pcv2, stats);\n    }),\n    remoteVideoTrackStats: response.remoteVideoTrackStats.map(function (stats) {\n      return rewriteTrackId(pcv2, stats);\n    }),\n    localAudioTrackStats: response.localAudioTrackStats.map(function (stats) {\n      return rewriteLocalTrackId(pcv2, stats);\n    }),\n    localVideoTrackStats: response.localVideoTrackStats.map(function (stats) {\n      return rewriteLocalTrackId(pcv2, stats);\n    })\n  });\n}\n/**\n * @event PeerConnectionV2#candidates\n * @param {object} candidates\n */\n\n/**\n * @event PeerConnectionV2#connectionStateChanged\n */\n\n/**\n * @event PeerConnectionV2#description\n * @param {object} description\n */\n\n/**\n * @event PeerConnectionV2#iceConnectionStateChanged\n */\n\n/**\n * @event PeerConnectionV2#trackAdded\n * @param {DataTrackReceiver|MediaTrackReceiver} trackReceiver\n */\n\n\nfunction getUfrag(description) {\n  if (description.sdp) {\n    var match = description.sdp.match(/^a=ice-ufrag:([a-zA-Z0-9+/]+)/m);\n\n    if (match) {\n      return match[1];\n    }\n  }\n\n  return null;\n}\n\nfunction getConfiguration(configuration) {\n  return Object.assign({\n    bundlePolicy: 'max-bundle',\n    rtcpMuxPolicy: 'require'\n  }, configuration);\n}\n/**\n * Whether the MediaStreamTrack of the given RTCRTPSender is a non-ended\n * MediaStreamTrack of a given kind.\n * @private\n * @param {string} kind\n * @param {RTCRtpSender} sender\n * @return {boolean}\n */\n\n\nfunction isSenderOfKind(kind, sender) {\n  var track = sender.track;\n  return track && track.kind === kind && track.readyState !== 'ended';\n}\n/**\n * Preferred codecs.\n * @typedef {object} PreferredCodecs\n * @property {Array<AudioCodec>} audio\n * @property {Array<VideoCodec>} video\n */\n\n\nfunction filterOutMediaStreamIds(sdp) {\n  return sdp.replace(/a=msid:[^ ]+ /g, 'a=msid:- ');\n}\n/**\n * Whether an RTCRtpTransceiver can be recycled.\n * @param {RTCRtpTransceiver} transceiver\n * @returns {boolean}\n */\n\n\nfunction shouldRecycleTransceiver(transceiver, pcv2) {\n  return !transceiver.stopped && !pcv2._replaceTrackPromises.has(transceiver) && ['inactive', 'recvonly'].includes(transceiver.direction);\n}\n/**\n * Take a recycled RTCRtpTransceiver if available.\n * @param {PeerConnectionV2} pcv2\n * @param {Track.Kind} kind\n * @returns {?RTCRtpTransceiver}\n */\n\n\nfunction takeRecycledTransceiver(pcv2, kind) {\n  var preferredCodecs = {\n    audio: pcv2._preferredAudioCodecs.map(function (_a) {\n      var codec = _a.codec;\n      return codec.toLowerCase();\n    }),\n    video: pcv2._preferredVideoCodecs.map(function (_a) {\n      var codec = _a.codec;\n      return codec.toLowerCase();\n    })\n  }[kind];\n  var recycledTransceivers = pcv2._recycledTransceivers[kind];\n  var localCodec = preferredCodecs.find(function (codec) {\n    return pcv2._localCodecs.has(codec);\n  });\n\n  if (!localCodec) {\n    return recycledTransceivers.shift();\n  }\n\n  var transceiver = recycledTransceivers.find(function (transceiver) {\n    var remoteCodecMap = pcv2._remoteCodecMaps.get(transceiver.mid);\n\n    return remoteCodecMap && remoteCodecMap.has(localCodec);\n  });\n\n  if (transceiver) {\n    recycledTransceivers.splice(recycledTransceivers.indexOf(transceiver), 1);\n  }\n\n  return transceiver;\n}\n/**\n * Update the set of locally supported {@link Codec}s.\n * @param pcv2\n * @returns {void}\n */\n\n\nfunction updateLocalCodecs(pcv2) {\n  var description = pcv2._peerConnection.localDescription;\n\n  if (!description || !description.sdp) {\n    return;\n  }\n\n  getMediaSections(description.sdp).forEach(function (section) {\n    var codecMap = createCodecMapForMediaSection(section);\n    codecMap.forEach(function (pts, codec) {\n      return pcv2._localCodecs.add(codec);\n    });\n  });\n}\n/**\n * Update the {@link Codec} maps for all m= sections in the remote {@link RTCSessionDescription}s.\n * @param {PeerConnectionV2} pcv2\n * @returns {void}\n */\n\n\nfunction updateRemoteCodecMaps(pcv2) {\n  var description = pcv2._peerConnection.remoteDescription;\n\n  if (!description || !description.sdp) {\n    return;\n  }\n\n  getMediaSections(description.sdp).forEach(function (section) {\n    var matched = section.match(/^a=mid:(.+)$/m);\n\n    if (!matched || !matched[1]) {\n      return;\n    }\n\n    var mid = matched[1];\n    var codecMap = createCodecMapForMediaSection(section);\n\n    pcv2._remoteCodecMaps.set(mid, codecMap);\n  });\n}\n/**\n * Update the list of recycled RTCRtpTransceivers.\n * @param {PeerConnectionV2} pcv2\n */\n\n\nfunction updateRecycledTransceivers(pcv2) {\n  pcv2._recycledTransceivers.audio = [];\n  pcv2._recycledTransceivers.video = [];\n\n  pcv2._peerConnection.getTransceivers().forEach(function (transceiver) {\n    if (shouldRecycleTransceiver(transceiver, pcv2)) {\n      var track = transceiver.receiver.track;\n\n      pcv2._recycledTransceivers[track.kind].push(transceiver);\n    }\n  });\n}\n/**\n * Perform certain updates after an SDP negotiation is completed.\n * @param {PeerConnectionV2} pcv2\n * @returns {void}\n */\n\n\nfunction negotiationCompleted(pcv2) {\n  updateRecycledTransceivers(pcv2);\n  updateLocalCodecs(pcv2);\n  updateRemoteCodecMaps(pcv2);\n  updateEncodingParameters(pcv2).then(function () {\n    // if there any any publisher hints queued, apply them now.\n    pcv2._handleQueuedPublisherHints();\n  });\n}\n/**\n * Update the RTCRtpEncodingParameters of all active RTCRtpSenders.\n * @param {PeerConnectionV2} pcv2\n * @returns {void}\n */\n\n\nfunction updateEncodingParameters(pcv2) {\n  var _a = pcv2._encodingParameters,\n      maxAudioBitrate = _a.maxAudioBitrate,\n      maxVideoBitrate = _a.maxVideoBitrate;\n  var maxBitrates = new Map([['audio', maxAudioBitrate], ['video', maxVideoBitrate]]);\n  var promises = [];\n\n  pcv2._peerConnection.getSenders().filter(function (sender) {\n    return sender.track;\n  }).forEach(function (sender) {\n    var maxBitrate = maxBitrates.get(sender.track.kind);\n    var params = sender.getParameters();\n\n    if (maxBitrate === null || maxBitrate === 0) {\n      removeMaxBitrate(params);\n    } else if (pcv2._isChromeScreenShareTrack(sender.track)) {\n      // NOTE(mpatwardhan): Sometimes (JSDK-2557) chrome does not send any bytes on screen track if MaxBitRate is set on it via setParameters,\n      // To workaround this issue we will not apply maxBitrate if the track appears to be a screen share track created by chrome\n      pcv2._log.warn(\"Not setting maxBitrate for \" + sender.track.kind + \" Track \" + sender.track.id + \" because it appears to be screen share track: \" + sender.track.label);\n    } else {\n      setMaxBitrate(params, maxBitrate);\n    }\n\n    if (!isFirefox && pcv2._enableDscp && params.encodings.length > 0) {\n      // NOTE(mmalavalli): \"networkPriority\" is a per-sender property and not\n      // a per-encoding-layer property. So, we set the value only on the first\n      // encoding layer. Any attempt to set the value on subsequent encoding\n      // layers (in the case of simulcast) will result in the Promise returned\n      // by RTCRtpSender.setParameters() being rejected.\n      params.encodings[0].networkPriority = 'high';\n    } // when a sender is reused, delete any active encodings set by server.\n\n\n    var trackReplaced = pcv2._rtpNewSenders.has(sender);\n\n    pcv2._maybeUpdateEncodings(sender.track, params.encodings, trackReplaced);\n\n    pcv2._rtpNewSenders.delete(sender);\n\n    var promise = sender.setParameters(params).catch(function (error) {\n      pcv2._log.warn(\"Error while setting encodings parameters for \" + sender.track.kind + \" Track \" + sender.track.id + \": \" + (error.message || error.name));\n    });\n    promises.push(promise);\n  });\n\n  return Promise.all(promises);\n}\n/**\n * Remove maxBitrate from the RTCRtpSendParameters' encodings.\n * @param {RTCRtpSendParameters} params\n * @returns {void}\n */\n\n\nfunction removeMaxBitrate(params) {\n  if (Array.isArray(params.encodings)) {\n    params.encodings.forEach(function (encoding) {\n      return delete encoding.maxBitrate;\n    });\n  }\n}\n/**\n * Set the given maxBitrate in the RTCRtpSendParameters' encodings.\n * @param {RTCRtpSendParameters} params\n * @param {number} maxBitrate\n * @returns {void}\n */\n\n\nfunction setMaxBitrate(params, maxBitrate) {\n  if (isFirefox) {\n    params.encodings = [{\n      maxBitrate: maxBitrate\n    }];\n  } else {\n    params.encodings.forEach(function (encoding) {\n      encoding.maxBitrate = maxBitrate;\n    });\n  }\n}\n\nmodule.exports = PeerConnectionV2;","map":null,"metadata":{},"sourceType":"script"}