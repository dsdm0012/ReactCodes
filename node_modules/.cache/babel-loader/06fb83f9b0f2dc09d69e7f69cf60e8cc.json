{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar DefaultRecordingSignaling = require('./recording');\n\nvar StateMachine = require('../statemachine');\n\nvar DefaultTimeout = require('../util/timeout');\n\nvar buildLogLevels = require('../util').buildLogLevels;\n\nvar DEFAULT_LOG_LEVEL = require('../util/constants').DEFAULT_LOG_LEVEL;\n\nvar Log = require('../util/log');\n\nvar _a = require('../util/twilio-video-errors'),\n    MediaConnectionError = _a.MediaConnectionError,\n    MediaDTLSTransportFailedError = _a.MediaDTLSTransportFailedError,\n    SignalingConnectionDisconnectedError = _a.SignalingConnectionDisconnectedError;\n\nvar nInstances = 0;\n/*\nRoomSignaling States\n-----------------------\n\n    +-----------+     +--------------+\n    |           |     |              |\n    | connected |---->| disconnected |\n    |           |     |              |\n    +-----------+     +--------------+\n          |  ^               ^\n          |  |               |\n          |  |   +--------------+\n          |  +---|              |\n          |      | reconnecting |\n          +----->|              |\n                 +--------------+\n\n*/\n\nvar states = {\n  connected: ['reconnecting', 'disconnected'],\n  reconnecting: ['connected', 'disconnected'],\n  disconnected: []\n};\n/**\n * A {@link Room} implementation\n * @extends StateMachine\n * @property {RTCPeerConnectionState} connectionState\n * @property {?Participant.SID} dominantSpeakerSid\n * @property {ParticipantSignaling} localParticipant\n * @property {RTCIceConnectionState} iceConnectionState\n * @property {string} name\n * @property {Map<string, RemoteParticipantSignaling>} participants\n * @property {RecordingSignaling} recording\n * @property {Room.SID} sid\n * @property {string} state - \"connected\", \"reconnecting\", or \"disconnected\"\n * @property {string} signalingConnectionState - \"connected\",\n *   \"reconnecting\", or \"disconnected\"\n * @emits RoomSignaling#connectionStateChanged\n * @emits RoomSignaling#dominantSpeakerChanged\n * @emits RoomSignaling#iceConnectionStateChanged\n * @emits RoomSignaling#signalingConnectionStateChanged\n */\n\nvar RoomSignaling =\n/** @class */\nfunction (_super) {\n  __extends(RoomSignaling, _super);\n  /**\n   * Construct a {@link RoomSignaling}.\n   * @param {ParticipantSignaling} localParticipant\n   * @param {Room.SID} sid\n   * @param {string} name\n   * @param {object} options\n   */\n\n\n  function RoomSignaling(localParticipant, sid, name, options) {\n    var _this = this;\n\n    options = Object.assign({\n      logLevel: DEFAULT_LOG_LEVEL,\n      RecordingSignaling: DefaultRecordingSignaling,\n      Timeout: DefaultTimeout\n    }, options);\n    var logLevels = buildLogLevels(options.logLevel);\n    _this = _super.call(this, 'connected', states) || this;\n    var RecordingSignaling = options.RecordingSignaling;\n    var sessionTimeout = new options.Timeout(function () {\n      _this._disconnect(_this._reconnectingError);\n    }, options.sessionTimeout, false);\n    Object.defineProperties(_this, {\n      _instanceId: {\n        value: nInstances++\n      },\n      _log: {\n        value: options.log ? options.log.createLog('default', _this) : new Log('default', _this, logLevels, options.loggerName)\n      },\n      _mediaConnectionIsReconnecting: {\n        writable: true,\n        value: false\n      },\n      _options: {\n        value: options\n      },\n      _reconnectingError: {\n        value: null,\n        writable: true\n      },\n      _sessionTimeout: {\n        value: sessionTimeout\n      },\n      dominantSpeakerSid: {\n        enumerable: true,\n        value: null,\n        writable: true\n      },\n      localParticipant: {\n        enumerable: true,\n        value: localParticipant\n      },\n      name: {\n        enumerable: true,\n        value: name\n      },\n      participants: {\n        enumerable: true,\n        value: new Map()\n      },\n      recording: {\n        enumerable: true,\n        value: new RecordingSignaling()\n      },\n      sid: {\n        enumerable: true,\n        value: sid\n      }\n    });\n\n    _this.on('connectionStateChanged', function () {\n      if (_this.connectionState === 'failed' && !['disconnected', 'failed'].includes(_this.iceConnectionState)) {\n        _this._disconnect(new MediaDTLSTransportFailedError());\n      }\n    });\n\n    _this.on('iceConnectionStateChanged', function () {\n      return maybeUpdateState(_this);\n    });\n\n    _this.on('signalingConnectionStateChanged', function () {\n      return maybeUpdateState(_this);\n    }); // NOTE(mmalavalli): In case \"iceConnectionState\" is already failed, update\n    // the RoomSignaling state. setTimeout() ensures that the state is updated\n    // after RoomV2's constructor is fully executed, thereby making \"signalingConnectionState\"\n    // available here.\n\n\n    setTimeout(function () {\n      return maybeUpdateState(_this);\n    });\n    return _this;\n  }\n  /**\n   * Disconnect, possibly with an Error.\n   * @private\n   * @param {Error} [error]\n   * @returns {boolean}\n   */\n\n\n  RoomSignaling.prototype._disconnect = function (error) {\n    if (this.state !== 'disconnected') {\n      this.preempt('disconnected', null, [error]);\n      return true;\n    }\n\n    return false;\n  };\n\n  RoomSignaling.prototype.toString = function () {\n    return \"[RoomSignaling #\" + this._instanceId + \": \" + (this.localParticipant ? this.localParticipant.sid : 'null') + \"]\";\n  };\n  /**\n   * Connect {@link RemoteParticipantSignaling} to the {@link RoomSignaling}.\n   * @param {RemoteParticipantSignaling} participant\n   * @returns {boolean}\n   */\n\n\n  RoomSignaling.prototype.connectParticipant = function (participant) {\n    var self = this;\n\n    if (participant.state === 'disconnected') {\n      return false;\n    }\n\n    if (this.participants.has(participant.sid)) {\n      return false;\n    }\n\n    this.participants.set(participant.sid, participant);\n    participant.on('stateChanged', function stateChanged(state) {\n      if (state === 'disconnected') {\n        participant.removeListener('stateChanged', stateChanged);\n        self.participants.delete(participant.sid);\n        self.emit('participantDisconnected', participant);\n      }\n    });\n    this.emit('participantConnected', participant);\n    return true;\n  };\n  /**\n   * Disconnect.\n   * @returns {boolean}\n   */\n\n\n  RoomSignaling.prototype.disconnect = function () {\n    return this._disconnect();\n  };\n  /**\n   * Set (or unset) the Dominant Speaker.\n   * @param {?Participant.SID} dominantSpeakerSid\n   * @returns {void}\n   */\n\n\n  RoomSignaling.prototype.setDominantSpeaker = function (dominantSpeakerSid) {\n    this.dominantSpeakerSid = dominantSpeakerSid;\n    this.emit('dominantSpeakerChanged');\n  };\n\n  return RoomSignaling;\n}(StateMachine);\n/**\n * @event RoomSignaling#event:connectionStateChanged\n */\n\n/**\n * @event RoomSignaling#event:dominantSpeakerChanged\n */\n\n/**\n * {@link RemoteParticipantSignaling} connected to the {@link RoomSignaling}.\n * @event RoomSignaling#event:participantConnected\n * @param {RemoteParticipantSignaling} participantSignaling\n */\n\n/**\n * {@link RemoteParticipantSignaling} disconnected from the {@link RoomSignaling}.\n * @event RoomSignaling#event:participantDisconnected\n * @param {RemoteParticipantSignaling} participantSignaling\n */\n\n/**\n * @event RoomSignaling#event:iceConnectionStateChanged\n */\n\n/**\n * @event RoomSignaling#event:signalingConnectionStateChanged\n */\n\n/**\n * Maybe update the {@link RoomSignaling} state.\n * @param {RoomSignaling} roomSignaling\n */\n\n\nfunction maybeUpdateState(roomSignaling) {\n  if (roomSignaling.state === 'disconnected' || roomSignaling.signalingConnectionState === 'disconnected') {\n    roomSignaling._sessionTimeout.clear();\n\n    return;\n  }\n\n  var newState;\n\n  if (roomSignaling.signalingConnectionState === 'reconnecting') {\n    newState = roomSignaling.signalingConnectionState;\n  } else if (roomSignaling.iceConnectionState === 'failed') {\n    roomSignaling._mediaConnectionIsReconnecting = true;\n    newState = 'reconnecting';\n  } else if (roomSignaling.iceConnectionState === 'new' || roomSignaling.iceConnectionState === 'checking') {\n    newState = roomSignaling._mediaConnectionIsReconnecting ? 'reconnecting' : 'connected';\n  } else {\n    roomSignaling._mediaConnectionIsReconnecting = false;\n    roomSignaling._reconnectingError = null;\n\n    roomSignaling._sessionTimeout.clear();\n\n    newState = 'connected';\n  }\n\n  if (newState === roomSignaling.state) {\n    return;\n  }\n\n  if (newState === 'reconnecting') {\n    roomSignaling._reconnectingError = roomSignaling.signalingConnectionState === 'reconnecting' ? new SignalingConnectionDisconnectedError() : new MediaConnectionError();\n\n    roomSignaling._sessionTimeout.start();\n\n    roomSignaling.preempt(newState, null, [roomSignaling._reconnectingError]);\n  } else {\n    roomSignaling.preempt(newState);\n  }\n}\n\nmodule.exports = RoomSignaling;","map":null,"metadata":{},"sourceType":"script"}