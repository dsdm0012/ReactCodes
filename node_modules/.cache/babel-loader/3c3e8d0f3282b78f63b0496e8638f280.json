{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar MediaTrackTransceiver = require('./transceiver');\n/**\n * A {@link MediaTrackSender} represents one or more local RTCRtpSenders.\n * @extends MediaTrackTransceiver\n * @emits MediaTrackSender#replaced\n */\n\n\nvar MediaTrackSender =\n/** @class */\nfunction (_super) {\n  __extends(MediaTrackSender, _super);\n  /**\n   * Construct a {@link MediaTrackSender}.\n   * @param {MediaStreamTrack} mediaStreamTrack\n   */\n\n\n  function MediaTrackSender(mediaStreamTrack) {\n    var _this = _super.call(this, mediaStreamTrack.id, mediaStreamTrack) || this;\n\n    Object.defineProperties(_this, {\n      _clones: {\n        value: new Set()\n      },\n      _senders: {\n        value: new Set()\n      },\n      _senderToPublisherHintCallbacks: {\n        value: new Map()\n      },\n      isPublishing: {\n        get: function () {\n          return !!this._clones.size;\n        }\n      }\n    });\n    return _this;\n  }\n  /**\n   * Return a new {@link MediaTrackSender} containing a clone of the underlying\n   * MediaStreamTrack. No RTCRtpSenders are copied.\n   * @returns {MediaTrackSender}\n   */\n\n\n  MediaTrackSender.prototype.clone = function () {\n    var clone = new MediaTrackSender(this.track.clone());\n\n    this._clones.add(clone);\n\n    return clone;\n  };\n  /**\n   * Remove a cloned {@link MediaTrackSender}.\n   * @returns {void}\n   */\n\n\n  MediaTrackSender.prototype.removeClone = function (clone) {\n    this._clones.delete(clone);\n  };\n  /**\n   * Set the given MediaStreamTrack.\n   * @param {MediaStreamTrack} mediaStreamTrack\n   * @returns {Promise<void>}\n   */\n\n\n  MediaTrackSender.prototype.setMediaStreamTrack = function (mediaStreamTrack) {\n    var _this = this;\n\n    var clones = Array.from(this._clones);\n    var senders = Array.from(this._senders);\n    return Promise.all(clones.map(function (clone) {\n      return clone.setMediaStreamTrack(mediaStreamTrack.clone());\n    }).concat(senders.map(function (sender) {\n      return _this._replaceTrack(sender, mediaStreamTrack);\n    }))).finally(function () {\n      _this._track = mediaStreamTrack;\n    });\n  };\n  /**\n   * Add an RTCRtpSender.\n   * @param {RTCRtpSender} sender\n   * @param {?()=>Promise<string>} publisherHintCallback\n   * @returns {this}\n   */\n\n\n  MediaTrackSender.prototype.addSender = function (sender, publisherHintCallback) {\n    this._senders.add(sender);\n\n    if (publisherHintCallback) {\n      this._senderToPublisherHintCallbacks.set(sender, publisherHintCallback);\n    }\n\n    return this;\n  };\n  /**\n   * Remove an RTCRtpSender.\n   * @param {RTCRtpSender} sender\n   * @returns {this}\n   */\n\n\n  MediaTrackSender.prototype.removeSender = function (sender) {\n    this._senders.delete(sender);\n\n    this._senderToPublisherHintCallbacks.delete(sender);\n\n    return this;\n  };\n  /**\n   * Applies given encodings, or resets encodings if none specified.\n   * @param {Array<{enabled: boolean, layer_index: number}>|null} encodings\n   * @returns {Promise<string>}\n   */\n\n\n  MediaTrackSender.prototype.setPublisherHint = function (encodings) {\n    // Note(mpatwardhan): since publisher hint applies only to group rooms we only look at 1st call callback.\n    var _a = __read(Array.from(this._senderToPublisherHintCallbacks.values()), 1),\n        publisherHintCallback = _a[0];\n\n    return publisherHintCallback ? publisherHintCallback(encodings) : Promise.resolve('COULD_NOT_APPLY_HINT');\n  };\n\n  MediaTrackSender.prototype._replaceTrack = function (sender, mediaStreamTrack) {\n    var _this = this;\n\n    return sender.replaceTrack(mediaStreamTrack).then(function (replaceTrackResult) {\n      // clear any publisherHints and apply default encodings.\n      _this.setPublisherHint(null).catch(function () {});\n\n      _this.emit('replaced');\n\n      return replaceTrackResult;\n    });\n  };\n\n  return MediaTrackSender;\n}(MediaTrackTransceiver);\n/**\n * The {@link MediaTrackSender} replaced the underlying mediaStreamTrack\n * @event MediaTrackSender#replaced\n */\n\n\nmodule.exports = MediaTrackSender;","map":null,"metadata":{},"sourceType":"script"}