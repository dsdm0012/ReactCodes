{"ast":null,"code":"'use strict';\n\nvar isNonArrayObject = require('./').isNonArrayObject;\n\nvar _a = require('./constants'),\n    E = _a.typeErrors,\n    clientTrackSwitchOffControl = _a.clientTrackSwitchOffControl,\n    videoContentPreferencesMode = _a.videoContentPreferencesMode,\n    subscriptionMode = _a.subscriptionMode,\n    trackPriority = _a.trackPriority,\n    trackSwitchOffMode = _a.trackSwitchOffMode;\n/**\n * Validate the {@link BandwidthProfileOptions} object.\n * @param {BandwidthProfileOptions} bandwidthProfile\n * @returns {?Error} - null if valid, Error if not.\n */\n\n\nfunction validateBandwidthProfile(bandwidthProfile) {\n  var error = validateObject(bandwidthProfile, 'options.bandwidthProfile');\n\n  if (!bandwidthProfile || error) {\n    return error;\n  }\n\n  error = validateObject(bandwidthProfile.video, 'options.bandwidthProfile.video', [{\n    prop: 'contentPreferencesMode',\n    values: Object.values(videoContentPreferencesMode)\n  }, {\n    prop: 'dominantSpeakerPriority',\n    values: Object.values(trackPriority)\n  }, {\n    prop: 'maxSubscriptionBitrate',\n    type: 'number'\n  }, {\n    prop: 'maxTracks',\n    type: 'number'\n  }, {\n    prop: 'mode',\n    values: Object.values(subscriptionMode)\n  }, {\n    prop: 'clientTrackSwitchOffControl',\n    values: Object.values(clientTrackSwitchOffControl)\n  }, {\n    prop: 'trackSwitchOffMode',\n    values: Object.values(trackSwitchOffMode)\n  }]);\n\n  if (error) {\n    return error;\n  }\n\n  if (bandwidthProfile.video) {\n    // maxTracks is replaced by clientTrackSwitchOffControl.\n    // throw an error if both are specified.\n    if ('maxTracks' in bandwidthProfile.video && 'clientTrackSwitchOffControl' in bandwidthProfile.video) {\n      return new TypeError('options.bandwidthProfile.video.maxTracks is deprecated. Use options.bandwidthProfile.video.clientTrackSwitchOffControl instead.');\n    } // renderDimensions is replaced by contentPreferencesMode.\n    // throw an error if both are specified.\n\n\n    if ('renderDimensions' in bandwidthProfile.video && 'contentPreferencesMode' in bandwidthProfile.video) {\n      return new TypeError('options.bandwidthProfile.video.renderDimensions is deprecated. Use options.bandwidthProfile.video.contentPreferencesMode instead.');\n    }\n\n    return validateRenderDimensions(bandwidthProfile.video.renderDimensions);\n  }\n\n  return null;\n}\n/**\n * Throw if the given track is not a {@link LocalAudioTrack}, a\n * {@link LocalVideoTrack} or a MediaStreamTrack.\n * @param {*} track\n * @param {object} options\n */\n\n\nfunction validateLocalTrack(track, options) {\n  if (!(track instanceof options.LocalAudioTrack || track instanceof options.LocalDataTrack || track instanceof options.LocalVideoTrack || track instanceof options.MediaStreamTrack)) {\n    /* eslint new-cap:0 */\n    throw E.INVALID_TYPE('track', 'LocalAudioTrack, LocalVideoTrack, LocalDataTrack, or MediaStreamTrack');\n  }\n}\n/**\n * Validate an object. An object is valid if it is undefined or a non-null, non-array\n * object whose properties satisfy the specified data-type or value-range requirements.\n * @param {object} object - the object to be validated\n * @param {string} name - the object name to be used to build the error message, if invalid\n * @param {Array<object>} [propChecks] - optional data-type or value-range requirements\n *   for the object's properties\n * @returns {?Error} - null if object is valid, Error if not\n */\n\n\nfunction validateObject(object, name, propChecks) {\n  if (propChecks === void 0) {\n    propChecks = [];\n  } // NOTE(mmalavalli): We determine that an undefined object is valid because this\n  // means the parent object does not contain this object as a property, which is\n  // a valid scenario.\n\n\n  if (typeof object === 'undefined') {\n    return null;\n  } // NOTE(mmalavalli): We determine that if the object is null, or an Array, or\n  // any other non-object type, then it is invalid.\n\n\n  if (object === null || !isNonArrayObject(object)) {\n    return E.INVALID_TYPE(name, 'object');\n  } // NOTE(mmalavalli): We determine that the object is invalid if at least one of\n  // its properties does not satisfy its data-type or value-range requirement.\n\n\n  return propChecks.reduce(function (error, _a) {\n    var prop = _a.prop,\n        type = _a.type,\n        values = _a.values;\n\n    if (error || !(prop in object)) {\n      return error;\n    }\n\n    var value = object[prop];\n\n    if (type && typeof value !== type) {\n      return E.INVALID_TYPE(name + \".\" + prop, type);\n    }\n\n    if (type === 'number' && isNaN(value)) {\n      return E.INVALID_TYPE(name + \".\" + prop, type);\n    }\n\n    if (Array.isArray(values) && !values.includes(value)) {\n      return E.INVALID_VALUE(name + \".\" + prop, values);\n    }\n\n    return error;\n  }, null);\n}\n/**\n * Validates the renderDimensions field to be \"auto\" or {@link VideoRenderDimensions} object.\n * @param {string|VideoRenderDimensions} renderDimensions\n * @returns {?Error} - null if valid, Error if not.\n */\n\n\nfunction validateRenderDimensions(renderDimensions) {\n  var name = 'options.bandwidthProfile.video.renderDimensions';\n  var error = validateObject(renderDimensions, name);\n  return renderDimensions ? error || Object.values(trackPriority).reduce(function (error, prop) {\n    return error || validateObject(renderDimensions[prop], name + \".\" + prop, [{\n      prop: 'height',\n      type: 'number'\n    }, {\n      prop: 'width',\n      type: 'number'\n    }]);\n  }, null) : error;\n}\n\nexports.validateBandwidthProfile = validateBandwidthProfile;\nexports.validateLocalTrack = validateLocalTrack;\nexports.validateObject = validateObject;","map":null,"metadata":{},"sourceType":"script"}