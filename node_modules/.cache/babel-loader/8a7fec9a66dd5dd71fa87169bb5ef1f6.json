{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nvar EventEmitter = require('events').EventEmitter;\n/**\n * A {@link QueueingEventEmitter} can queue events until a listener has been\n * added.\n * @extends EventEmitter\n */\n\n\nvar QueueingEventEmitter =\n/** @class */\nfunction (_super) {\n  __extends(QueueingEventEmitter, _super);\n  /**\n   * Construct a {@link QueueingEventEmitter}\n   */\n\n\n  function QueueingEventEmitter() {\n    var _this = _super.call(this) || this;\n\n    Object.defineProperties(_this, {\n      _queuedEvents: {\n        value: new Map()\n      }\n    });\n    return _this;\n  }\n  /**\n   * Emit any queued events.\n   * @returns {boolean} true if every event had listeners, false otherwise\n  */\n\n  /**\n  * Emit any queued events matching the event name.\n  * @param {string} event\n  * @returns {boolean} true if every event had listeners, false otherwise\n  */\n\n\n  QueueingEventEmitter.prototype.dequeue = function (event) {\n    var _this = this;\n\n    var result = true;\n\n    if (!event) {\n      this._queuedEvents.forEach(function (_, queuedEvent) {\n        result = this.dequeue(queuedEvent) && result;\n      }, this);\n\n      return result;\n    }\n\n    var queue = this._queuedEvents.get(event) || [];\n\n    this._queuedEvents.delete(event);\n\n    return queue.reduce(function (result, args) {\n      return _this.emit.apply(_this, __spreadArray([], __read([event].concat(args)))) && result;\n    }, result);\n  };\n  /**\n   * If the event has listeners, emit the event; otherwise, queue the event.\n   * @param {string} event\n   * @param {...*} args\n   * @returns {boolean} true if the event had listeners, false if the event was queued\n   */\n\n\n  QueueingEventEmitter.prototype.queue = function () {\n    var args = [].slice.call(arguments);\n\n    if (this.emit.apply(this, __spreadArray([], __read(args)))) {\n      return true;\n    }\n\n    var event = args[0];\n\n    if (!this._queuedEvents.has(event)) {\n      this._queuedEvents.set(event, []);\n    }\n\n    this._queuedEvents.get(event).push(args.slice(1));\n\n    return false;\n  };\n\n  return QueueingEventEmitter;\n}(EventEmitter);\n\nmodule.exports = QueueingEventEmitter;","map":null,"metadata":{},"sourceType":"script"}