{"ast":null,"code":"'use strict';\n/**\n * Create a {@link Deferred}.\n * @returns {Deferred}\n */\n\nfunction defer() {\n  var deferred = {};\n  deferred.promise = new Promise(function (resolve, reject) {\n    deferred.resolve = resolve;\n    deferred.reject = reject;\n  });\n  return deferred;\n}\n/**\n * Copy a method from a `source` prototype onto a `wrapper` prototype. Invoking\n * the method on the `wrapper` prototype will invoke the corresponding method\n * on an instance accessed by `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @param {string} methodName\n * @returns {undefined}\n */\n\n\nfunction delegateMethod(source, wrapper, target, methodName) {\n  if (methodName in wrapper) {\n    // Skip any methods already set.\n    return;\n  } else if (methodName.match(/^on[a-z]+$/)) {\n    // Skip EventHandlers (these are handled in the constructor).\n    return;\n  }\n\n  var isProperty = false;\n\n  try {\n    var propDesc = Object.getOwnPropertyDescriptor(source, methodName);\n    isProperty = propDesc && !!propDesc.get;\n  } catch (error) {// its okay to eat failure here.\n  } // NOTE(mpatwardhan):skip properties. we are only interested in overriding\n  // functions. we do not even want to evaluate  `typeof source[methodName]` for properties\n  // because getter would get invoked, and they might have side effects.\n  // For example RTCPeerConnection.peerIdentity is a property that returns a promise.\n  // calling typeof RTCPeerConnection.peerIdentity, would leak a promise, and in case it rejects\n  // we see errors.\n\n\n  if (isProperty) {\n    return;\n  }\n\n  var type;\n\n  try {\n    type = typeof source[methodName];\n  } catch (error) {// NOTE(mroberts): Attempting to check the type of non-function members\n    // on the prototype throws an error for some types.\n  }\n\n  if (type !== 'function') {\n    // Skip non-function members.\n    return;\n  }\n  /* eslint no-loop-func:0 */\n\n\n  wrapper[methodName] = function () {\n    return this[target][methodName].apply(this[target], arguments);\n  };\n}\n/**\n * Copy methods from a `source` prototype onto a `wrapper` prototype. Invoking\n * the methods on the `wrapper` prototype will invoke the corresponding method\n * on an instance accessed by `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @returns {undefined}\n */\n\n\nfunction delegateMethods(source, wrapper, target) {\n  for (var methodName in source) {\n    delegateMethod(source, wrapper, target, methodName);\n  }\n}\n/**\n * Finds the items in list1 that are not in list2.\n * @param {Array<*>|Map<*>|Set<*>} list1\n * @param {Array<*>|Map<*>|Set<*>} list2\n * @returns {Set}\n */\n\n\nfunction difference(list1, list2) {\n  list1 = Array.isArray(list1) ? new Set(list1) : new Set(list1.values());\n  list2 = Array.isArray(list2) ? new Set(list2) : new Set(list2.values());\n  var difference = new Set();\n  list1.forEach(function (item) {\n    if (!list2.has(item)) {\n      difference.add(item);\n    }\n  });\n  return difference;\n}\n/**\n * Map a list to an array of arrays, and return the flattened result.\n * @param {Array<*>|Set<*>|Map<*>} list\n * @param {function(*): Array<*>} mapFn\n * @returns Array<*>\n */\n\n\nfunction flatMap(list, mapFn) {\n  var listArray = list instanceof Map || list instanceof Set ? Array.from(list.values()) : list;\n  return listArray.reduce(function (flattened, item) {\n    var mapped = mapFn(item);\n    return flattened.concat(mapped);\n  }, []);\n}\n/**\n * Get the browser's user agent, if available.\n * @returns {?string}\n */\n\n\nfunction getUserAgent() {\n  return typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' ? navigator.userAgent : null;\n}\n/**\n * Guess the browser.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {?string} browser - \"chrome\", \"firefox\", \"safari\", or null\n */\n\n\nfunction guessBrowser(userAgent) {\n  if (typeof userAgent === 'undefined') {\n    userAgent = getUserAgent();\n  }\n\n  if (/Chrome|CriOS/.test(userAgent)) {\n    return 'chrome';\n  }\n\n  if (/Firefox|FxiOS/.test(userAgent)) {\n    return 'firefox';\n  }\n\n  if (/Safari|iPhone|iPad|iPod/.test(userAgent)) {\n    return 'safari';\n  }\n\n  return null;\n}\n/**\n * Guess the browser version.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {?{major: number, minor: number}}\n */\n\n\nfunction guessBrowserVersion(userAgent) {\n  if (typeof userAgent === 'undefined') {\n    userAgent = getUserAgent();\n  }\n\n  var prefix = {\n    chrome: 'Chrome|CriOS',\n    firefox: 'Firefox|FxiOS',\n    safari: 'Version'\n  }[guessBrowser(userAgent)];\n\n  if (!prefix) {\n    return null;\n  }\n\n  var regex = new RegExp('(' + prefix + ')/([^\\\\s]+)');\n  var match = (userAgent.match(regex) || [])[2];\n\n  if (!match) {\n    return null;\n  }\n\n  var versions = match.split('.').map(Number);\n  return {\n    major: isNaN(versions[0]) ? null : versions[0],\n    minor: isNaN(versions[1]) ? null : versions[1]\n  };\n}\n/**\n * Check whether the current browser is iOS Chrome.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {boolean}\n */\n\n\nfunction isIOSChrome(userAgent) {\n  if (typeof userAgent === 'undefined') {\n    userAgent = getUserAgent();\n  }\n\n  return /Mobi/.test(userAgent) && guessBrowser() === 'chrome' && /iPad|iPhone|iPod/.test(userAgent);\n}\n/**\n * Intercept an event that might otherwise be proxied on an EventTarget.\n * @param {EventTarget} target\n * @param {string} type\n * @returns {void}\n */\n\n\nfunction interceptEvent(target, type) {\n  var currentListener = null;\n  Object.defineProperty(target, 'on' + type, {\n    get: function () {\n      return currentListener;\n    },\n    set: function (newListener) {\n      if (currentListener) {\n        this.removeEventListener(type, currentListener);\n      }\n\n      if (typeof newListener === 'function') {\n        currentListener = newListener;\n        this.addEventListener(type, currentListener);\n      } else {\n        currentListener = null;\n      }\n    }\n  });\n}\n/**\n * This is a function for turning a Promise into the kind referenced in the\n * Legacy Interface Extensions section of the WebRTC spec.\n * @param {Promise<*>} promise\n * @param {function<*>} onSuccess\n * @param {function<Error>} onFailure\n * @returns {Promise<undefined>}\n */\n\n\nfunction legacyPromise(promise, onSuccess, onFailure) {\n  if (onSuccess) {\n    return promise.then(function (result) {\n      onSuccess(result);\n    }, function (error) {\n      onFailure(error);\n    });\n  }\n\n  return promise;\n}\n/**\n * Make a unique ID.\n * @return {string}\n */\n\n\nfunction makeUUID() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = Math.random() * 16 | 0;\n    var v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\n/**\n * For each property name on the `source` prototype, add getters and/or setters\n * to `wrapper` that proxy to `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @returns {undefined}\n */\n\n\nfunction proxyProperties(source, wrapper, target) {\n  Object.getOwnPropertyNames(source).forEach(function (propertyName) {\n    proxyProperty(source, wrapper, target, propertyName);\n  });\n}\n/**\n * For the property name on the `source` prototype, add a getter and/or setter\n * to `wrapper` that proxies to `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @param {string} propertyName\n * @returns {undefined}\n */\n\n\nfunction proxyProperty(source, wrapper, target, propertyName) {\n  if (propertyName in wrapper) {\n    // Skip any properties already set.\n    return;\n  } else if (propertyName.match(/^on[a-z]+$/)) {\n    Object.defineProperty(wrapper, propertyName, {\n      value: null,\n      writable: true\n    });\n    target.addEventListener(propertyName.slice(2), function () {\n      wrapper.dispatchEvent.apply(wrapper, arguments);\n    });\n    return;\n  }\n\n  Object.defineProperty(wrapper, propertyName, {\n    enumerable: true,\n    get: function () {\n      return target[propertyName];\n    }\n  });\n}\n/**\n * Check whether native WebRTC APIs are supported.\n * @returns {boolean}\n */\n\n\nfunction support() {\n  return typeof navigator === 'object' && typeof navigator.mediaDevices === 'object' && typeof navigator.mediaDevices.getUserMedia === 'function' && typeof RTCPeerConnection === 'function';\n}\n/**\n * @typedef {object} Deferred\n * @property {Promise} promise\n * @property {function} reject\n * @property {function} resolve\n */\n\n\nexports.defer = defer;\nexports.delegateMethods = delegateMethods;\nexports.difference = difference;\nexports.flatMap = flatMap;\nexports.guessBrowser = guessBrowser;\nexports.guessBrowserVersion = guessBrowserVersion;\nexports.isIOSChrome = isIOSChrome;\nexports.interceptEvent = interceptEvent;\nexports.legacyPromise = legacyPromise;\nexports.makeUUID = makeUUID;\nexports.proxyProperties = proxyProperties;\nexports.support = support;","map":{"version":3,"sources":["../../../lib/webrtc/util/index.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["'use strict';\n/**\n * Create a {@link Deferred}.\n * @returns {Deferred}\n */\nfunction defer() {\n    var deferred = {};\n    deferred.promise = new Promise(function (resolve, reject) {\n        deferred.resolve = resolve;\n        deferred.reject = reject;\n    });\n    return deferred;\n}\n/**\n * Copy a method from a `source` prototype onto a `wrapper` prototype. Invoking\n * the method on the `wrapper` prototype will invoke the corresponding method\n * on an instance accessed by `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @param {string} methodName\n * @returns {undefined}\n */\nfunction delegateMethod(source, wrapper, target, methodName) {\n    if (methodName in wrapper) {\n        // Skip any methods already set.\n        return;\n    }\n    else if (methodName.match(/^on[a-z]+$/)) {\n        // Skip EventHandlers (these are handled in the constructor).\n        return;\n    }\n    var isProperty = false;\n    try {\n        var propDesc = Object.getOwnPropertyDescriptor(source, methodName);\n        isProperty = propDesc && !!propDesc.get;\n    }\n    catch (error) {\n        // its okay to eat failure here.\n    }\n    // NOTE(mpatwardhan):skip properties. we are only interested in overriding\n    // functions. we do not even want to evaluate  `typeof source[methodName]` for properties\n    // because getter would get invoked, and they might have side effects.\n    // For example RTCPeerConnection.peerIdentity is a property that returns a promise.\n    // calling typeof RTCPeerConnection.peerIdentity, would leak a promise, and in case it rejects\n    // we see errors.\n    if (isProperty) {\n        return;\n    }\n    var type;\n    try {\n        type = typeof source[methodName];\n    }\n    catch (error) {\n        // NOTE(mroberts): Attempting to check the type of non-function members\n        // on the prototype throws an error for some types.\n    }\n    if (type !== 'function') {\n        // Skip non-function members.\n        return;\n    }\n    /* eslint no-loop-func:0 */\n    wrapper[methodName] = function () {\n        return this[target][methodName].apply(this[target], arguments);\n    };\n}\n/**\n * Copy methods from a `source` prototype onto a `wrapper` prototype. Invoking\n * the methods on the `wrapper` prototype will invoke the corresponding method\n * on an instance accessed by `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @returns {undefined}\n */\nfunction delegateMethods(source, wrapper, target) {\n    for (var methodName in source) {\n        delegateMethod(source, wrapper, target, methodName);\n    }\n}\n/**\n * Finds the items in list1 that are not in list2.\n * @param {Array<*>|Map<*>|Set<*>} list1\n * @param {Array<*>|Map<*>|Set<*>} list2\n * @returns {Set}\n */\nfunction difference(list1, list2) {\n    list1 = Array.isArray(list1) ? new Set(list1) : new Set(list1.values());\n    list2 = Array.isArray(list2) ? new Set(list2) : new Set(list2.values());\n    var difference = new Set();\n    list1.forEach(function (item) {\n        if (!list2.has(item)) {\n            difference.add(item);\n        }\n    });\n    return difference;\n}\n/**\n * Map a list to an array of arrays, and return the flattened result.\n * @param {Array<*>|Set<*>|Map<*>} list\n * @param {function(*): Array<*>} mapFn\n * @returns Array<*>\n */\nfunction flatMap(list, mapFn) {\n    var listArray = list instanceof Map || list instanceof Set\n        ? Array.from(list.values())\n        : list;\n    return listArray.reduce(function (flattened, item) {\n        var mapped = mapFn(item);\n        return flattened.concat(mapped);\n    }, []);\n}\n/**\n * Get the browser's user agent, if available.\n * @returns {?string}\n */\nfunction getUserAgent() {\n    return typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string'\n        ? navigator.userAgent\n        : null;\n}\n/**\n * Guess the browser.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {?string} browser - \"chrome\", \"firefox\", \"safari\", or null\n */\nfunction guessBrowser(userAgent) {\n    if (typeof userAgent === 'undefined') {\n        userAgent = getUserAgent();\n    }\n    if (/Chrome|CriOS/.test(userAgent)) {\n        return 'chrome';\n    }\n    if (/Firefox|FxiOS/.test(userAgent)) {\n        return 'firefox';\n    }\n    if (/Safari|iPhone|iPad|iPod/.test(userAgent)) {\n        return 'safari';\n    }\n    return null;\n}\n/**\n * Guess the browser version.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {?{major: number, minor: number}}\n */\nfunction guessBrowserVersion(userAgent) {\n    if (typeof userAgent === 'undefined') {\n        userAgent = getUserAgent();\n    }\n    var prefix = {\n        chrome: 'Chrome|CriOS',\n        firefox: 'Firefox|FxiOS',\n        safari: 'Version'\n    }[guessBrowser(userAgent)];\n    if (!prefix) {\n        return null;\n    }\n    var regex = new RegExp('(' + prefix + ')/([^\\\\s]+)');\n    var match = (userAgent.match(regex) || [])[2];\n    if (!match) {\n        return null;\n    }\n    var versions = match.split('.').map(Number);\n    return {\n        major: isNaN(versions[0]) ? null : versions[0],\n        minor: isNaN(versions[1]) ? null : versions[1]\n    };\n}\n/**\n * Check whether the current browser is iOS Chrome.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {boolean}\n */\nfunction isIOSChrome(userAgent) {\n    if (typeof userAgent === 'undefined') {\n        userAgent = getUserAgent();\n    }\n    return (/Mobi/.test(userAgent) && guessBrowser() === 'chrome' && /iPad|iPhone|iPod/.test(userAgent));\n}\n/**\n * Intercept an event that might otherwise be proxied on an EventTarget.\n * @param {EventTarget} target\n * @param {string} type\n * @returns {void}\n */\nfunction interceptEvent(target, type) {\n    var currentListener = null;\n    Object.defineProperty(target, 'on' + type, {\n        get: function () {\n            return currentListener;\n        },\n        set: function (newListener) {\n            if (currentListener) {\n                this.removeEventListener(type, currentListener);\n            }\n            if (typeof newListener === 'function') {\n                currentListener = newListener;\n                this.addEventListener(type, currentListener);\n            }\n            else {\n                currentListener = null;\n            }\n        }\n    });\n}\n/**\n * This is a function for turning a Promise into the kind referenced in the\n * Legacy Interface Extensions section of the WebRTC spec.\n * @param {Promise<*>} promise\n * @param {function<*>} onSuccess\n * @param {function<Error>} onFailure\n * @returns {Promise<undefined>}\n */\nfunction legacyPromise(promise, onSuccess, onFailure) {\n    if (onSuccess) {\n        return promise.then(function (result) {\n            onSuccess(result);\n        }, function (error) {\n            onFailure(error);\n        });\n    }\n    return promise;\n}\n/**\n * Make a unique ID.\n * @return {string}\n */\nfunction makeUUID() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n        var r = Math.random() * 16 | 0;\n        var v = c === 'x' ? r : (r & 0x3 | 0x8);\n        return v.toString(16);\n    });\n}\n/**\n * For each property name on the `source` prototype, add getters and/or setters\n * to `wrapper` that proxy to `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @returns {undefined}\n */\nfunction proxyProperties(source, wrapper, target) {\n    Object.getOwnPropertyNames(source).forEach(function (propertyName) {\n        proxyProperty(source, wrapper, target, propertyName);\n    });\n}\n/**\n * For the property name on the `source` prototype, add a getter and/or setter\n * to `wrapper` that proxies to `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @param {string} propertyName\n * @returns {undefined}\n */\nfunction proxyProperty(source, wrapper, target, propertyName) {\n    if (propertyName in wrapper) {\n        // Skip any properties already set.\n        return;\n    }\n    else if (propertyName.match(/^on[a-z]+$/)) {\n        Object.defineProperty(wrapper, propertyName, {\n            value: null,\n            writable: true\n        });\n        target.addEventListener(propertyName.slice(2), function () {\n            wrapper.dispatchEvent.apply(wrapper, arguments);\n        });\n        return;\n    }\n    Object.defineProperty(wrapper, propertyName, {\n        enumerable: true,\n        get: function () {\n            return target[propertyName];\n        }\n    });\n}\n/**\n * Check whether native WebRTC APIs are supported.\n * @returns {boolean}\n */\nfunction support() {\n    return typeof navigator === 'object'\n        && typeof navigator.mediaDevices === 'object'\n        && typeof navigator.mediaDevices.getUserMedia === 'function'\n        && typeof RTCPeerConnection === 'function';\n}\n/**\n * @typedef {object} Deferred\n * @property {Promise} promise\n * @property {function} reject\n * @property {function} resolve\n */\nexports.defer = defer;\nexports.delegateMethods = delegateMethods;\nexports.difference = difference;\nexports.flatMap = flatMap;\nexports.guessBrowser = guessBrowser;\nexports.guessBrowserVersion = guessBrowserVersion;\nexports.isIOSChrome = isIOSChrome;\nexports.interceptEvent = interceptEvent;\nexports.legacyPromise = legacyPromise;\nexports.makeUUID = makeUUID;\nexports.proxyProperties = proxyProperties;\nexports.support = support;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}