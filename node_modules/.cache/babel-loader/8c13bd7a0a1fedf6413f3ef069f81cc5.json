{"ast":null,"code":"/* globals RTCDataChannel, RTCPeerConnection, RTCSessionDescription */\n'use strict';\n\nvar ChromeRTCSessionDescription = require('../rtcsessiondescription/chrome');\n\nvar EventTarget = require('../util/eventtarget');\n\nvar inherits = require('../../vendor/inherits');\n\nvar Latch = require('../util/latch');\n\nvar MediaStream = require('../mediastream');\n\nvar RTCRtpSenderShim = require('../rtcrtpsender');\n\nvar sdpUtils = require('../util/sdp');\n\nvar util = require('../util');\n\nvar isIOSChrome = require('../util').isIOSChrome;\n\nvar isUnifiedPlan = sdpUtils.getSdpFormat() === 'unified'; // NOTE(mroberts): This class wraps Chrome's RTCPeerConnection implementation.\n// It provides some functionality not currently present in Chrome, namely the\n// abilities to\n//\n//   1. Rollback, per the workaround suggested here:\n//      https://bugs.chromium.org/p/webrtc/issues/detail?id=5738#c3\n//\n//   2. Listen for track events, per the adapter.js workaround.\n//\n//   3. Set iceTransportPolicy.\n//\n\nfunction ChromeRTCPeerConnection(configuration, constraints) {\n  if (!(this instanceof ChromeRTCPeerConnection)) {\n    return new ChromeRTCPeerConnection(configuration, constraints);\n  }\n\n  EventTarget.call(this);\n  configuration = configuration || {};\n  var newConfiguration = Object.assign(configuration.iceTransportPolicy ? {\n    iceTransports: configuration.iceTransportPolicy\n  } : {}, configuration);\n  util.interceptEvent(this, 'datachannel');\n  util.interceptEvent(this, 'signalingstatechange');\n  var sdpFormat = sdpUtils.getSdpFormat(newConfiguration.sdpSemantics);\n  var peerConnection = new RTCPeerConnection(newConfiguration, constraints);\n  Object.defineProperties(this, {\n    _appliedTracksToSSRCs: {\n      value: new Map(),\n      writable: true\n    },\n    _localStream: {\n      value: new MediaStream()\n    },\n    _peerConnection: {\n      value: peerConnection\n    },\n    _pendingLocalOffer: {\n      value: null,\n      writable: true\n    },\n    _pendingRemoteOffer: {\n      value: null,\n      writable: true\n    },\n    _rolledBackTracksToSSRCs: {\n      value: new Map(),\n      writable: true\n    },\n    _sdpFormat: {\n      value: sdpFormat\n    },\n    _senders: {\n      value: new Map()\n    },\n    _signalingStateLatch: {\n      value: new Latch()\n    },\n    _tracksToSSRCs: {\n      value: new Map(),\n      writable: true\n    },\n    localDescription: {\n      enumerable: true,\n      get: function () {\n        return this._pendingLocalOffer ? this._pendingLocalOffer : peerConnection.localDescription;\n      }\n    },\n    remoteDescription: {\n      enumerable: true,\n      get: function () {\n        return this._pendingRemoteOffer ? this._pendingRemoteOffer : peerConnection.remoteDescription;\n      }\n    },\n    signalingState: {\n      enumerable: true,\n      get: function () {\n        if (this._pendingLocalOffer) {\n          return 'have-local-offer';\n        } else if (this._pendingRemoteOffer) {\n          return 'have-remote-offer';\n        }\n\n        return peerConnection.signalingState;\n      }\n    }\n  });\n  var self = this;\n  peerConnection.addEventListener('datachannel', function ondatachannel(event) {\n    shimDataChannel(event.channel);\n    self.dispatchEvent(event);\n  });\n  peerConnection.addEventListener('signalingstatechange', function onsignalingstatechange() {\n    if (peerConnection.signalingState === 'stable') {\n      self._appliedTracksToSSRCs = new Map(self._tracksToSSRCs);\n    }\n\n    if (!self._pendingLocalOffer && !self._pendingRemoteOffer) {\n      self.dispatchEvent.apply(self, arguments);\n    }\n  });\n\n  peerConnection.ontrack = function ontrack() {// NOTE(mroberts): adapter.js's \"track\" event shim only kicks off if we set\n    // the ontrack property of the RTCPeerConnection.\n  };\n\n  if (typeof RTCPeerConnection.prototype.addTrack !== 'function') {\n    peerConnection.addStream(this._localStream);\n  }\n\n  util.proxyProperties(RTCPeerConnection.prototype, this, peerConnection);\n}\n\ninherits(ChromeRTCPeerConnection, EventTarget);\n\nif (typeof RTCPeerConnection.prototype.addTrack !== 'function') {\n  // NOTE(mmalavalli): This shim supports our limited case of adding\n  // all MediaStreamTracks to one MediaStream. It has been implemented this\n  // keeping in mind that this is to be maintained only until \"addTrack\" is\n  // supported natively in Chrome.\n  ChromeRTCPeerConnection.prototype.addTrack = function addTrack() {\n    var args = [].slice.call(arguments);\n    var track = args[0];\n\n    if (this._peerConnection.signalingState === 'closed') {\n      throw new Error('Cannot add MediaStreamTrack [' + track.id + ', ' + track.kind + ']: RTCPeerConnection is closed');\n    }\n\n    var sender = this._senders.get(track);\n\n    if (sender && sender.track) {\n      throw new Error('Cannot add MediaStreamTrack [' + track.id + ', ' + track.kind + ']: RTCPeerConnection already has it');\n    }\n\n    this._peerConnection.removeStream(this._localStream);\n\n    this._localStream.addTrack(track);\n\n    this._peerConnection.addStream(this._localStream);\n\n    sender = new RTCRtpSenderShim(track);\n\n    this._senders.set(track, sender);\n\n    return sender;\n  }; // NOTE(mmalavalli): This shim supports our limited case of removing\n  // MediaStreamTracks from one MediaStream. It has been implemented this\n  // keeping in mind that this is to be maintained only until \"removeTrack\" is\n  // supported natively in Chrome.\n\n\n  ChromeRTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    if (this._peerConnection.signalingState === 'closed') {\n      throw new Error('Cannot remove MediaStreamTrack: RTCPeerConnection is closed');\n    }\n\n    var track = sender.track;\n\n    if (!track) {\n      return;\n    }\n\n    sender = this._senders.get(track);\n\n    if (sender && sender.track) {\n      sender.track = null;\n\n      this._peerConnection.removeStream(this._localStream);\n\n      this._localStream.removeTrack(track);\n\n      this._peerConnection.addStream(this._localStream);\n    }\n  };\n\n  ChromeRTCPeerConnection.prototype.getSenders = function getSenders() {\n    return Array.from(this._senders.values());\n  };\n} else {\n  ChromeRTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    if (this._peerConnection.signalingState === 'closed') {\n      throw new Error('Cannot remove MediaStreamTrack: RTCPeerConnection is closed');\n    }\n\n    try {\n      this._peerConnection.removeTrack(sender);\n    } catch (e) {// NOTE(mhuynh): Do nothing. In Chrome, will throw if a 'sender was not\n      // created by this peer connection'. This behavior does not seem to be\n      // spec compliant, so a temporary shim is introduced. A bug has been filed,\n      // and is tracked here:\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=860853\n    }\n  };\n}\n\nChromeRTCPeerConnection.prototype.addIceCandidate = function addIceCandidate(candidate) {\n  var args = [].slice.call(arguments);\n  var promise;\n  var self = this;\n\n  if (this.signalingState === 'have-remote-offer') {\n    // NOTE(mroberts): Because the ChromeRTCPeerConnection simulates the\n    // \"have-remote-offer\" signalingStates, we only want to invoke the true\n    // addIceCandidates method when the remote description has been applied.\n    promise = this._signalingStateLatch.when('low').then(function signalingStatesResolved() {\n      return self._peerConnection.addIceCandidate(candidate);\n    });\n  } else {\n    promise = this._peerConnection.addIceCandidate(candidate);\n  }\n\n  return args.length > 1 ? util.legacyPromise(promise, args[1], args[2]) : promise;\n}; // NOTE(mroberts): The WebRTC spec does not specify that close should throw an\n// Error; however, in Chrome it does. We workaround this by checking the\n// signalingState manually.\n\n\nChromeRTCPeerConnection.prototype.close = function close() {\n  if (this.signalingState !== 'closed') {\n    this._pendingLocalOffer = null;\n    this._pendingRemoteOffer = null;\n\n    this._peerConnection.close();\n  }\n}; // NOTE(mroberts): Because we workaround Chrome's lack of rollback support by\n// \"faking\" setRemoteDescription, we cannot create an answer until we actually\n// apply the remote description. This means, once you call createAnswer, you\n// can no longer rollback. This is acceptable for our use case because we will\n// apply the newly-created answer almost immediately; however, this may be\n// unacceptable for other use cases.\n\n\nChromeRTCPeerConnection.prototype.createAnswer = function createAnswer() {\n  var args = [].slice.call(arguments);\n  var promise;\n  var self = this;\n\n  if (this._pendingRemoteOffer) {\n    promise = this._peerConnection.setRemoteDescription(this._pendingRemoteOffer).then(function setRemoteDescriptionSucceeded() {\n      // NOTE(mroberts): The signalingStates between the ChromeRTCPeerConnection\n      // and the underlying RTCPeerConnection implementation have converged. We\n      // can unblock any pending calls to addIceCandidate now.\n      self._signalingStateLatch.lower();\n\n      return self._peerConnection.createAnswer();\n    }).then(function createAnswerSucceeded(answer) {\n      self._pendingRemoteOffer = null; // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n      // longer need to retain the rolled back tracks to SSRCs Map.\n\n      self._rolledBackTracksToSSRCs.clear();\n\n      return new ChromeRTCSessionDescription({\n        type: 'answer',\n        sdp: updateTrackIdsToSSRCs(self._sdpFormat, self._tracksToSSRCs, answer.sdp)\n      });\n    }, function setRemoteDescriptionOrCreateAnswerFailed(error) {\n      self._pendingRemoteOffer = null;\n      throw error;\n    });\n  } else {\n    promise = this._peerConnection.createAnswer().then(function (answer) {\n      // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n      // longer need to retain the rolled back tracks to SSRCs Map.\n      self._rolledBackTracksToSSRCs.clear();\n\n      return new ChromeRTCSessionDescription({\n        type: 'answer',\n        sdp: updateTrackIdsToSSRCs(self._sdpFormat, self._tracksToSSRCs, answer.sdp)\n      });\n    });\n  }\n\n  return args.length > 1 ? util.legacyPromise(promise, args[0], args[1]) : promise;\n};\n\nChromeRTCPeerConnection.prototype.createOffer = function createOffer() {\n  var args = [].slice.call(arguments);\n  var options = (args.length > 1 ? args[2] : args[0]) || {};\n  var self = this;\n\n  if (isIOSChrome()) {\n    // NOTE (joma): From SafariRTCPeerConnection in order to support iOS Chrome.\n    if (options.offerToReceiveVideo && !this._audioTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'audio'))) {\n      delete options.offerToReceiveAudio;\n\n      try {\n        this._audioTransceiver = isUnifiedPlan ? this.addTransceiver('audio', {\n          direction: 'recvonly'\n        }) : this.addTransceiver('audio');\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }\n\n    if (options.offerToReceiveVideo && !this._videoTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'video'))) {\n      delete options.offerToReceiveVideo;\n\n      try {\n        this._videoTransceiver = isUnifiedPlan ? this.addTransceiver('video', {\n          direction: 'recvonly'\n        }) : this.addTransceiver('video');\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }\n  }\n\n  var promise = this._peerConnection.createOffer(options).then(function (offer) {\n    // NOTE(mmalavalli): If createOffer() is called immediately after rolling back, then we no\n    // longer need to retain the rolled back tracks to SSRCs Map.\n    self._rolledBackTracksToSSRCs.clear();\n\n    return new ChromeRTCSessionDescription({\n      type: offer.type,\n      sdp: updateTrackIdsToSSRCs(self._sdpFormat, self._tracksToSSRCs, offer.sdp)\n    });\n  });\n\n  return args.length > 1 ? util.legacyPromise(promise, args[0], args[1]) : promise;\n};\n\nChromeRTCPeerConnection.prototype.createDataChannel = function createDataChannel(label, dataChannelDict) {\n  dataChannelDict = shimDataChannelInit(dataChannelDict);\n\n  var dataChannel = this._peerConnection.createDataChannel(label, dataChannelDict);\n\n  shimDataChannel(dataChannel);\n  return dataChannel;\n};\n\nChromeRTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n  var args = [].slice.call(arguments);\n  var description = args[0]; // NOTE(mmalavalli): If setLocalDescription() is called immediately after rolling back,\n  // then we need to restore the rolled back tracks to SSRCs Map.\n\n  if (this._rolledBackTracksToSSRCs.size > 0) {\n    this._tracksToSSRCs = new Map(this._rolledBackTracksToSSRCs);\n\n    this._rolledBackTracksToSSRCs.clear();\n  }\n\n  var promise = setDescription(this, true, description);\n  return args.length > 1 ? util.legacyPromise(promise, args[1], args[2]) : promise;\n};\n\nChromeRTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n  var args = [].slice.call(arguments);\n  var description = args[0]; // NOTE(mmalavalli): If setRemoteDescription() is called immediately after rolling back,\n  // then we no longer need to retain the rolled back tracks to SSRCs Map.\n\n  this._rolledBackTracksToSSRCs.clear();\n\n  var promise = setDescription(this, false, description);\n  return args.length > 1 ? util.legacyPromise(promise, args[1], args[2]) : promise;\n};\n\nutil.delegateMethods(RTCPeerConnection.prototype, ChromeRTCPeerConnection.prototype, '_peerConnection'); // NOTE(mroberts): We workaround Chrome's lack of rollback support, per the\n// workaround suggested here: https://bugs.chromium.org/p/webrtc/issues/detail?id=5738#c3\n// Namely, we \"fake\" setting the local or remote description and instead buffer\n// it. If we receive or create an answer, then we will actually apply the\n// description. Until we receive or create an answer, we will be able to\n// \"rollback\" by simply discarding the buffer description.\n\nfunction setDescription(peerConnection, local, description) {\n  function setPendingLocalOffer(offer) {\n    if (local) {\n      peerConnection._pendingLocalOffer = offer;\n    } else {\n      peerConnection._pendingRemoteOffer = offer;\n    }\n  }\n\n  function clearPendingLocalOffer() {\n    if (local) {\n      peerConnection._pendingLocalOffer = null;\n    } else {\n      peerConnection._pendingRemoteOffer = null;\n    }\n  }\n\n  var pendingLocalOffer = local ? peerConnection._pendingLocalOffer : peerConnection._pendingRemoteOffer;\n  var pendingRemoteOffer = local ? peerConnection._pendingRemoteOffer : peerConnection._pendingLocalOffer;\n  var intermediateState = local ? 'have-local-offer' : 'have-remote-offer';\n  var setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';\n  var promise;\n\n  if (!local && pendingRemoteOffer && description.type === 'answer') {\n    promise = setRemoteAnswer(peerConnection, description);\n  } else if (description.type === 'offer') {\n    if (peerConnection.signalingState !== intermediateState && peerConnection.signalingState !== 'stable') {\n      // NOTE(mroberts): Error message copied from Firefox.\n      return Promise.reject(new Error('Cannot set ' + (local ? 'local' : 'remote') + ' offer in state ' + peerConnection.signalingState));\n    } // We need to save this local offer in case of a rollback. We also need to\n    // check to see if the signalingState between the ChromeRTCPeerConnection\n    // and the underlying RTCPeerConnection implementation are about to diverge.\n    // If so, we need to ensure subsequent calls to addIceCandidate will block.\n\n\n    if (!pendingLocalOffer && peerConnection._signalingStateLatch.state === 'low') {\n      peerConnection._signalingStateLatch.raise();\n    }\n\n    var previousSignalingState = peerConnection.signalingState;\n    setPendingLocalOffer(unwrap(description));\n    promise = Promise.resolve(); // Only dispatch a signalingstatechange event if we transitioned.\n\n    if (peerConnection.signalingState !== previousSignalingState) {\n      promise.then(function dispatchSignalingStateChangeEvent() {\n        peerConnection.dispatchEvent(new Event('signalingstatechange'));\n      });\n    }\n  } else if (description.type === 'rollback') {\n    if (peerConnection.signalingState !== intermediateState) {\n      // NOTE(mroberts): Error message copied from Firefox.\n      promise = Promise.reject(new Error('Cannot rollback ' + (local ? 'local' : 'remote') + ' description in ' + peerConnection.signalingState));\n    } else {\n      // Reset the pending offer.\n      clearPendingLocalOffer(); // NOTE(mmalavalli): We store the rolled back tracks to SSRCs Map here in case\n      // setLocalDescription() is called immediately after a rollback (without calling\n      // createOffer() or createAnswer()), in which case this roll back is not due to a\n      // glare scenario and this Map should be restored.\n\n      peerConnection._rolledBackTracksToSSRCs = new Map(peerConnection._tracksToSSRCs);\n      peerConnection._tracksToSSRCs = new Map(peerConnection._appliedTracksToSSRCs);\n      promise = Promise.resolve();\n      promise.then(function dispatchSignalingStateChangeEvent() {\n        peerConnection.dispatchEvent(new Event('signalingstatechange'));\n      });\n    }\n  }\n\n  return promise || peerConnection._peerConnection[setLocalDescription](unwrap(description));\n}\n\nfunction setRemoteAnswer(peerConnection, answer) {\n  // Apply the pending local offer.\n  var pendingLocalOffer = peerConnection._pendingLocalOffer;\n  return peerConnection._peerConnection.setLocalDescription(pendingLocalOffer).then(function setLocalOfferSucceeded() {\n    peerConnection._pendingLocalOffer = null;\n    return peerConnection.setRemoteDescription(answer);\n  }).then(function setRemoteAnswerSucceeded() {\n    // NOTE(mroberts): The signalingStates between the ChromeRTCPeerConnection\n    // and the underlying RTCPeerConnection implementation have converged. We\n    // can unblock any pending calls to addIceCandidate now.\n    peerConnection._signalingStateLatch.lower();\n  });\n}\n/**\n * Whether a ChromeRTCPeerConnection has any RTCRtpReceivers(s) for the given\n * MediaStreamTrack kind.\n * @param {ChromeRTCPeerConnection} peerConnection\n * @param {'audio' | 'video'} kind\n * @returns {boolean}\n */\n\n\nfunction hasReceiversForTracksOfKind(peerConnection, kind) {\n  return !!peerConnection.getTransceivers().find(function (transceiver) {\n    return transceiver.receiver && transceiver.receiver.track && transceiver.receiver.track.kind === kind;\n  });\n}\n\nfunction unwrap(description) {\n  if (description instanceof ChromeRTCSessionDescription) {\n    if (description._description) {\n      return description._description;\n    }\n  }\n\n  return new RTCSessionDescription(description);\n}\n/**\n * Check whether or not we need to apply our maxPacketLifeTime shim. We are\n * pretty conservative: we'll only apply it if the legacy maxRetransmitTime\n * property is available _and_ the standard maxPacketLifeTime property is _not_\n * available (the thinking being that Chrome will land the standards-compliant\n * property).\n * @returns {boolean}\n */\n\n\nfunction needsMaxPacketLifeTimeShim() {\n  return 'maxRetransmitTime' in RTCDataChannel.prototype && !('maxPacketLifeTime' in RTCDataChannel.prototype);\n}\n/**\n * Shim an RTCDataChannelInit dictionary (if necessary). This function returns\n * a copy of the original RTCDataChannelInit.\n * @param {RTCDataChannelInit} dataChannelDict\n * @returns {RTCDataChannelInit}\n */\n\n\nfunction shimDataChannelInit(dataChannelDict) {\n  dataChannelDict = Object.assign({}, dataChannelDict);\n\n  if (needsMaxPacketLifeTimeShim() && 'maxPacketLifeTime' in dataChannelDict) {\n    dataChannelDict.maxRetransmitTime = dataChannelDict.maxPacketLifeTime;\n  }\n\n  return dataChannelDict;\n}\n/**\n * Shim an RTCDataChannel (if necessary). This function mutates the\n * RTCDataChannel.\n * @param {RTCDataChannel} dataChannel\n * @returns {RTCDataChannel}\n */\n\n\nfunction shimDataChannel(dataChannel) {\n  Object.defineProperty(dataChannel, 'maxRetransmits', {\n    value: dataChannel.maxRetransmits === 65535 ? null : dataChannel.maxRetransmits\n  });\n\n  if (needsMaxPacketLifeTimeShim()) {\n    // NOTE(mroberts): We can rename `maxRetransmitTime` to `maxPacketLifeTime`.\n    //\n    //   https://bugs.chromium.org/p/chromium/issues/detail?id=696681\n    //\n    Object.defineProperty(dataChannel, 'maxPacketLifeTime', {\n      value: dataChannel.maxRetransmitTime === 65535 ? null : dataChannel.maxRetransmitTime\n    });\n  }\n\n  return dataChannel;\n}\n/**\n * Update the mappings from MediaStreamTrack IDs to SSRCs as indicated by both\n * the Map from MediaStreamTrack IDs to SSRCs and the SDP itself. This method\n * ensures that SSRCs never change once announced.\n * @param {'planb'|'unified'} sdpFormat\n * @param {Map<string, Set<string>>} tracksToSSRCs\n * @param {string} sdp - an SDP whose format is determined by `sdpSemantics`\n * @returns {string} updatedSdp - updated SDP\n */\n\n\nfunction updateTrackIdsToSSRCs(sdpFormat, tracksToSSRCs, sdp) {\n  return sdpFormat === 'unified' ? sdpUtils.updateUnifiedPlanTrackIdsToSSRCs(tracksToSSRCs, sdp) : sdpUtils.updatePlanBTrackIdsToSSRCs(tracksToSSRCs, sdp);\n}\n\nmodule.exports = ChromeRTCPeerConnection;","map":{"version":3,"sources":["../../../lib/webrtc/rtcpeerconnection/chrome.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/* globals RTCDataChannel, RTCPeerConnection, RTCSessionDescription */\n'use strict';\nvar ChromeRTCSessionDescription = require('../rtcsessiondescription/chrome');\nvar EventTarget = require('../util/eventtarget');\nvar inherits = require('../../vendor/inherits');\nvar Latch = require('../util/latch');\nvar MediaStream = require('../mediastream');\nvar RTCRtpSenderShim = require('../rtcrtpsender');\nvar sdpUtils = require('../util/sdp');\nvar util = require('../util');\nvar isIOSChrome = require('../util').isIOSChrome;\nvar isUnifiedPlan = sdpUtils.getSdpFormat() === 'unified';\n// NOTE(mroberts): This class wraps Chrome's RTCPeerConnection implementation.\n// It provides some functionality not currently present in Chrome, namely the\n// abilities to\n//\n//   1. Rollback, per the workaround suggested here:\n//      https://bugs.chromium.org/p/webrtc/issues/detail?id=5738#c3\n//\n//   2. Listen for track events, per the adapter.js workaround.\n//\n//   3. Set iceTransportPolicy.\n//\nfunction ChromeRTCPeerConnection(configuration, constraints) {\n    if (!(this instanceof ChromeRTCPeerConnection)) {\n        return new ChromeRTCPeerConnection(configuration, constraints);\n    }\n    EventTarget.call(this);\n    configuration = configuration || {};\n    var newConfiguration = Object.assign(configuration.iceTransportPolicy\n        ? { iceTransports: configuration.iceTransportPolicy }\n        : {}, configuration);\n    util.interceptEvent(this, 'datachannel');\n    util.interceptEvent(this, 'signalingstatechange');\n    var sdpFormat = sdpUtils.getSdpFormat(newConfiguration.sdpSemantics);\n    var peerConnection = new RTCPeerConnection(newConfiguration, constraints);\n    Object.defineProperties(this, {\n        _appliedTracksToSSRCs: {\n            value: new Map(),\n            writable: true\n        },\n        _localStream: {\n            value: new MediaStream()\n        },\n        _peerConnection: {\n            value: peerConnection\n        },\n        _pendingLocalOffer: {\n            value: null,\n            writable: true\n        },\n        _pendingRemoteOffer: {\n            value: null,\n            writable: true\n        },\n        _rolledBackTracksToSSRCs: {\n            value: new Map(),\n            writable: true\n        },\n        _sdpFormat: {\n            value: sdpFormat\n        },\n        _senders: {\n            value: new Map()\n        },\n        _signalingStateLatch: {\n            value: new Latch()\n        },\n        _tracksToSSRCs: {\n            value: new Map(),\n            writable: true\n        },\n        localDescription: {\n            enumerable: true,\n            get: function () {\n                return this._pendingLocalOffer ? this._pendingLocalOffer : peerConnection.localDescription;\n            }\n        },\n        remoteDescription: {\n            enumerable: true,\n            get: function () {\n                return this._pendingRemoteOffer ? this._pendingRemoteOffer : peerConnection.remoteDescription;\n            }\n        },\n        signalingState: {\n            enumerable: true,\n            get: function () {\n                if (this._pendingLocalOffer) {\n                    return 'have-local-offer';\n                }\n                else if (this._pendingRemoteOffer) {\n                    return 'have-remote-offer';\n                }\n                return peerConnection.signalingState;\n            }\n        }\n    });\n    var self = this;\n    peerConnection.addEventListener('datachannel', function ondatachannel(event) {\n        shimDataChannel(event.channel);\n        self.dispatchEvent(event);\n    });\n    peerConnection.addEventListener('signalingstatechange', function onsignalingstatechange() {\n        if (peerConnection.signalingState === 'stable') {\n            self._appliedTracksToSSRCs = new Map(self._tracksToSSRCs);\n        }\n        if (!self._pendingLocalOffer && !self._pendingRemoteOffer) {\n            self.dispatchEvent.apply(self, arguments);\n        }\n    });\n    peerConnection.ontrack = function ontrack() {\n        // NOTE(mroberts): adapter.js's \"track\" event shim only kicks off if we set\n        // the ontrack property of the RTCPeerConnection.\n    };\n    if (typeof RTCPeerConnection.prototype.addTrack !== 'function') {\n        peerConnection.addStream(this._localStream);\n    }\n    util.proxyProperties(RTCPeerConnection.prototype, this, peerConnection);\n}\ninherits(ChromeRTCPeerConnection, EventTarget);\nif (typeof RTCPeerConnection.prototype.addTrack !== 'function') {\n    // NOTE(mmalavalli): This shim supports our limited case of adding\n    // all MediaStreamTracks to one MediaStream. It has been implemented this\n    // keeping in mind that this is to be maintained only until \"addTrack\" is\n    // supported natively in Chrome.\n    ChromeRTCPeerConnection.prototype.addTrack = function addTrack() {\n        var args = [].slice.call(arguments);\n        var track = args[0];\n        if (this._peerConnection.signalingState === 'closed') {\n            throw new Error('Cannot add MediaStreamTrack [' + track.id + ', '\n                + track.kind + ']: RTCPeerConnection is closed');\n        }\n        var sender = this._senders.get(track);\n        if (sender && sender.track) {\n            throw new Error('Cannot add MediaStreamTrack [' + track.id + ', '\n                + track.kind + ']: RTCPeerConnection already has it');\n        }\n        this._peerConnection.removeStream(this._localStream);\n        this._localStream.addTrack(track);\n        this._peerConnection.addStream(this._localStream);\n        sender = new RTCRtpSenderShim(track);\n        this._senders.set(track, sender);\n        return sender;\n    };\n    // NOTE(mmalavalli): This shim supports our limited case of removing\n    // MediaStreamTracks from one MediaStream. It has been implemented this\n    // keeping in mind that this is to be maintained only until \"removeTrack\" is\n    // supported natively in Chrome.\n    ChromeRTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n        if (this._peerConnection.signalingState === 'closed') {\n            throw new Error('Cannot remove MediaStreamTrack: RTCPeerConnection is closed');\n        }\n        var track = sender.track;\n        if (!track) {\n            return;\n        }\n        sender = this._senders.get(track);\n        if (sender && sender.track) {\n            sender.track = null;\n            this._peerConnection.removeStream(this._localStream);\n            this._localStream.removeTrack(track);\n            this._peerConnection.addStream(this._localStream);\n        }\n    };\n    ChromeRTCPeerConnection.prototype.getSenders = function getSenders() {\n        return Array.from(this._senders.values());\n    };\n}\nelse {\n    ChromeRTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n        if (this._peerConnection.signalingState === 'closed') {\n            throw new Error('Cannot remove MediaStreamTrack: RTCPeerConnection is closed');\n        }\n        try {\n            this._peerConnection.removeTrack(sender);\n        }\n        catch (e) {\n            // NOTE(mhuynh): Do nothing. In Chrome, will throw if a 'sender was not\n            // created by this peer connection'. This behavior does not seem to be\n            // spec compliant, so a temporary shim is introduced. A bug has been filed,\n            // and is tracked here:\n            // https://bugs.chromium.org/p/chromium/issues/detail?id=860853\n        }\n    };\n}\nChromeRTCPeerConnection.prototype.addIceCandidate = function addIceCandidate(candidate) {\n    var args = [].slice.call(arguments);\n    var promise;\n    var self = this;\n    if (this.signalingState === 'have-remote-offer') {\n        // NOTE(mroberts): Because the ChromeRTCPeerConnection simulates the\n        // \"have-remote-offer\" signalingStates, we only want to invoke the true\n        // addIceCandidates method when the remote description has been applied.\n        promise = this._signalingStateLatch.when('low').then(function signalingStatesResolved() {\n            return self._peerConnection.addIceCandidate(candidate);\n        });\n    }\n    else {\n        promise = this._peerConnection.addIceCandidate(candidate);\n    }\n    return args.length > 1\n        ? util.legacyPromise(promise, args[1], args[2])\n        : promise;\n};\n// NOTE(mroberts): The WebRTC spec does not specify that close should throw an\n// Error; however, in Chrome it does. We workaround this by checking the\n// signalingState manually.\nChromeRTCPeerConnection.prototype.close = function close() {\n    if (this.signalingState !== 'closed') {\n        this._pendingLocalOffer = null;\n        this._pendingRemoteOffer = null;\n        this._peerConnection.close();\n    }\n};\n// NOTE(mroberts): Because we workaround Chrome's lack of rollback support by\n// \"faking\" setRemoteDescription, we cannot create an answer until we actually\n// apply the remote description. This means, once you call createAnswer, you\n// can no longer rollback. This is acceptable for our use case because we will\n// apply the newly-created answer almost immediately; however, this may be\n// unacceptable for other use cases.\nChromeRTCPeerConnection.prototype.createAnswer = function createAnswer() {\n    var args = [].slice.call(arguments);\n    var promise;\n    var self = this;\n    if (this._pendingRemoteOffer) {\n        promise = this._peerConnection.setRemoteDescription(this._pendingRemoteOffer).then(function setRemoteDescriptionSucceeded() {\n            // NOTE(mroberts): The signalingStates between the ChromeRTCPeerConnection\n            // and the underlying RTCPeerConnection implementation have converged. We\n            // can unblock any pending calls to addIceCandidate now.\n            self._signalingStateLatch.lower();\n            return self._peerConnection.createAnswer();\n        }).then(function createAnswerSucceeded(answer) {\n            self._pendingRemoteOffer = null;\n            // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n            // longer need to retain the rolled back tracks to SSRCs Map.\n            self._rolledBackTracksToSSRCs.clear();\n            return new ChromeRTCSessionDescription({\n                type: 'answer',\n                sdp: updateTrackIdsToSSRCs(self._sdpFormat, self._tracksToSSRCs, answer.sdp)\n            });\n        }, function setRemoteDescriptionOrCreateAnswerFailed(error) {\n            self._pendingRemoteOffer = null;\n            throw error;\n        });\n    }\n    else {\n        promise = this._peerConnection.createAnswer().then(function (answer) {\n            // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n            // longer need to retain the rolled back tracks to SSRCs Map.\n            self._rolledBackTracksToSSRCs.clear();\n            return new ChromeRTCSessionDescription({\n                type: 'answer',\n                sdp: updateTrackIdsToSSRCs(self._sdpFormat, self._tracksToSSRCs, answer.sdp)\n            });\n        });\n    }\n    return args.length > 1\n        ? util.legacyPromise(promise, args[0], args[1])\n        : promise;\n};\nChromeRTCPeerConnection.prototype.createOffer = function createOffer() {\n    var args = [].slice.call(arguments);\n    var options = (args.length > 1 ? args[2] : args[0]) || {};\n    var self = this;\n    if (isIOSChrome()) {\n        // NOTE (joma): From SafariRTCPeerConnection in order to support iOS Chrome.\n        if (options.offerToReceiveVideo && !this._audioTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'audio'))) {\n            delete options.offerToReceiveAudio;\n            try {\n                this._audioTransceiver = isUnifiedPlan\n                    ? this.addTransceiver('audio', { direction: 'recvonly' })\n                    : this.addTransceiver('audio');\n            }\n            catch (e) {\n                return Promise.reject(e);\n            }\n        }\n        if (options.offerToReceiveVideo && !this._videoTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'video'))) {\n            delete options.offerToReceiveVideo;\n            try {\n                this._videoTransceiver = isUnifiedPlan\n                    ? this.addTransceiver('video', { direction: 'recvonly' })\n                    : this.addTransceiver('video');\n            }\n            catch (e) {\n                return Promise.reject(e);\n            }\n        }\n    }\n    var promise = this._peerConnection.createOffer(options).then(function (offer) {\n        // NOTE(mmalavalli): If createOffer() is called immediately after rolling back, then we no\n        // longer need to retain the rolled back tracks to SSRCs Map.\n        self._rolledBackTracksToSSRCs.clear();\n        return new ChromeRTCSessionDescription({\n            type: offer.type,\n            sdp: updateTrackIdsToSSRCs(self._sdpFormat, self._tracksToSSRCs, offer.sdp)\n        });\n    });\n    return args.length > 1\n        ? util.legacyPromise(promise, args[0], args[1])\n        : promise;\n};\nChromeRTCPeerConnection.prototype.createDataChannel = function createDataChannel(label, dataChannelDict) {\n    dataChannelDict = shimDataChannelInit(dataChannelDict);\n    var dataChannel = this._peerConnection.createDataChannel(label, dataChannelDict);\n    shimDataChannel(dataChannel);\n    return dataChannel;\n};\nChromeRTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n    var args = [].slice.call(arguments);\n    var description = args[0];\n    // NOTE(mmalavalli): If setLocalDescription() is called immediately after rolling back,\n    // then we need to restore the rolled back tracks to SSRCs Map.\n    if (this._rolledBackTracksToSSRCs.size > 0) {\n        this._tracksToSSRCs = new Map(this._rolledBackTracksToSSRCs);\n        this._rolledBackTracksToSSRCs.clear();\n    }\n    var promise = setDescription(this, true, description);\n    return args.length > 1\n        ? util.legacyPromise(promise, args[1], args[2])\n        : promise;\n};\nChromeRTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n    var args = [].slice.call(arguments);\n    var description = args[0];\n    // NOTE(mmalavalli): If setRemoteDescription() is called immediately after rolling back,\n    // then we no longer need to retain the rolled back tracks to SSRCs Map.\n    this._rolledBackTracksToSSRCs.clear();\n    var promise = setDescription(this, false, description);\n    return args.length > 1\n        ? util.legacyPromise(promise, args[1], args[2])\n        : promise;\n};\nutil.delegateMethods(RTCPeerConnection.prototype, ChromeRTCPeerConnection.prototype, '_peerConnection');\n// NOTE(mroberts): We workaround Chrome's lack of rollback support, per the\n// workaround suggested here: https://bugs.chromium.org/p/webrtc/issues/detail?id=5738#c3\n// Namely, we \"fake\" setting the local or remote description and instead buffer\n// it. If we receive or create an answer, then we will actually apply the\n// description. Until we receive or create an answer, we will be able to\n// \"rollback\" by simply discarding the buffer description.\nfunction setDescription(peerConnection, local, description) {\n    function setPendingLocalOffer(offer) {\n        if (local) {\n            peerConnection._pendingLocalOffer = offer;\n        }\n        else {\n            peerConnection._pendingRemoteOffer = offer;\n        }\n    }\n    function clearPendingLocalOffer() {\n        if (local) {\n            peerConnection._pendingLocalOffer = null;\n        }\n        else {\n            peerConnection._pendingRemoteOffer = null;\n        }\n    }\n    var pendingLocalOffer = local ? peerConnection._pendingLocalOffer : peerConnection._pendingRemoteOffer;\n    var pendingRemoteOffer = local ? peerConnection._pendingRemoteOffer : peerConnection._pendingLocalOffer;\n    var intermediateState = local ? 'have-local-offer' : 'have-remote-offer';\n    var setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';\n    var promise;\n    if (!local && pendingRemoteOffer && description.type === 'answer') {\n        promise = setRemoteAnswer(peerConnection, description);\n    }\n    else if (description.type === 'offer') {\n        if (peerConnection.signalingState !== intermediateState && peerConnection.signalingState !== 'stable') {\n            // NOTE(mroberts): Error message copied from Firefox.\n            return Promise.reject(new Error('Cannot set ' + (local ? 'local' : 'remote') +\n                ' offer in state ' + peerConnection.signalingState));\n        }\n        // We need to save this local offer in case of a rollback. We also need to\n        // check to see if the signalingState between the ChromeRTCPeerConnection\n        // and the underlying RTCPeerConnection implementation are about to diverge.\n        // If so, we need to ensure subsequent calls to addIceCandidate will block.\n        if (!pendingLocalOffer && peerConnection._signalingStateLatch.state === 'low') {\n            peerConnection._signalingStateLatch.raise();\n        }\n        var previousSignalingState = peerConnection.signalingState;\n        setPendingLocalOffer(unwrap(description));\n        promise = Promise.resolve();\n        // Only dispatch a signalingstatechange event if we transitioned.\n        if (peerConnection.signalingState !== previousSignalingState) {\n            promise.then(function dispatchSignalingStateChangeEvent() {\n                peerConnection.dispatchEvent(new Event('signalingstatechange'));\n            });\n        }\n    }\n    else if (description.type === 'rollback') {\n        if (peerConnection.signalingState !== intermediateState) {\n            // NOTE(mroberts): Error message copied from Firefox.\n            promise = Promise.reject(new Error('Cannot rollback ' +\n                (local ? 'local' : 'remote') + ' description in ' + peerConnection.signalingState));\n        }\n        else {\n            // Reset the pending offer.\n            clearPendingLocalOffer();\n            // NOTE(mmalavalli): We store the rolled back tracks to SSRCs Map here in case\n            // setLocalDescription() is called immediately after a rollback (without calling\n            // createOffer() or createAnswer()), in which case this roll back is not due to a\n            // glare scenario and this Map should be restored.\n            peerConnection._rolledBackTracksToSSRCs = new Map(peerConnection._tracksToSSRCs);\n            peerConnection._tracksToSSRCs = new Map(peerConnection._appliedTracksToSSRCs);\n            promise = Promise.resolve();\n            promise.then(function dispatchSignalingStateChangeEvent() {\n                peerConnection.dispatchEvent(new Event('signalingstatechange'));\n            });\n        }\n    }\n    return promise || peerConnection._peerConnection[setLocalDescription](unwrap(description));\n}\nfunction setRemoteAnswer(peerConnection, answer) {\n    // Apply the pending local offer.\n    var pendingLocalOffer = peerConnection._pendingLocalOffer;\n    return peerConnection._peerConnection.setLocalDescription(pendingLocalOffer).then(function setLocalOfferSucceeded() {\n        peerConnection._pendingLocalOffer = null;\n        return peerConnection.setRemoteDescription(answer);\n    }).then(function setRemoteAnswerSucceeded() {\n        // NOTE(mroberts): The signalingStates between the ChromeRTCPeerConnection\n        // and the underlying RTCPeerConnection implementation have converged. We\n        // can unblock any pending calls to addIceCandidate now.\n        peerConnection._signalingStateLatch.lower();\n    });\n}\n/**\n * Whether a ChromeRTCPeerConnection has any RTCRtpReceivers(s) for the given\n * MediaStreamTrack kind.\n * @param {ChromeRTCPeerConnection} peerConnection\n * @param {'audio' | 'video'} kind\n * @returns {boolean}\n */\nfunction hasReceiversForTracksOfKind(peerConnection, kind) {\n    return !!peerConnection.getTransceivers().find(function (transceiver) {\n        return transceiver.receiver && transceiver.receiver.track && transceiver.receiver.track.kind === kind;\n    });\n}\nfunction unwrap(description) {\n    if (description instanceof ChromeRTCSessionDescription) {\n        if (description._description) {\n            return description._description;\n        }\n    }\n    return new RTCSessionDescription(description);\n}\n/**\n * Check whether or not we need to apply our maxPacketLifeTime shim. We are\n * pretty conservative: we'll only apply it if the legacy maxRetransmitTime\n * property is available _and_ the standard maxPacketLifeTime property is _not_\n * available (the thinking being that Chrome will land the standards-compliant\n * property).\n * @returns {boolean}\n */\nfunction needsMaxPacketLifeTimeShim() {\n    return 'maxRetransmitTime' in RTCDataChannel.prototype\n        && !('maxPacketLifeTime' in RTCDataChannel.prototype);\n}\n/**\n * Shim an RTCDataChannelInit dictionary (if necessary). This function returns\n * a copy of the original RTCDataChannelInit.\n * @param {RTCDataChannelInit} dataChannelDict\n * @returns {RTCDataChannelInit}\n */\nfunction shimDataChannelInit(dataChannelDict) {\n    dataChannelDict = Object.assign({}, dataChannelDict);\n    if (needsMaxPacketLifeTimeShim() && 'maxPacketLifeTime' in dataChannelDict) {\n        dataChannelDict.maxRetransmitTime = dataChannelDict.maxPacketLifeTime;\n    }\n    return dataChannelDict;\n}\n/**\n * Shim an RTCDataChannel (if necessary). This function mutates the\n * RTCDataChannel.\n * @param {RTCDataChannel} dataChannel\n * @returns {RTCDataChannel}\n */\nfunction shimDataChannel(dataChannel) {\n    Object.defineProperty(dataChannel, 'maxRetransmits', {\n        value: dataChannel.maxRetransmits === 65535\n            ? null\n            : dataChannel.maxRetransmits\n    });\n    if (needsMaxPacketLifeTimeShim()) {\n        // NOTE(mroberts): We can rename `maxRetransmitTime` to `maxPacketLifeTime`.\n        //\n        //   https://bugs.chromium.org/p/chromium/issues/detail?id=696681\n        //\n        Object.defineProperty(dataChannel, 'maxPacketLifeTime', {\n            value: dataChannel.maxRetransmitTime === 65535\n                ? null\n                : dataChannel.maxRetransmitTime\n        });\n    }\n    return dataChannel;\n}\n/**\n * Update the mappings from MediaStreamTrack IDs to SSRCs as indicated by both\n * the Map from MediaStreamTrack IDs to SSRCs and the SDP itself. This method\n * ensures that SSRCs never change once announced.\n * @param {'planb'|'unified'} sdpFormat\n * @param {Map<string, Set<string>>} tracksToSSRCs\n * @param {string} sdp - an SDP whose format is determined by `sdpSemantics`\n * @returns {string} updatedSdp - updated SDP\n */\nfunction updateTrackIdsToSSRCs(sdpFormat, tracksToSSRCs, sdp) {\n    return sdpFormat === 'unified'\n        ? sdpUtils.updateUnifiedPlanTrackIdsToSSRCs(tracksToSSRCs, sdp)\n        : sdpUtils.updatePlanBTrackIdsToSSRCs(tracksToSSRCs, sdp);\n}\nmodule.exports = ChromeRTCPeerConnection;\n//# sourceMappingURL=chrome.js.map"]},"metadata":{},"sourceType":"script"}