{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar MediaStreamTrack = require('./webrtc').MediaStreamTrack;\n\nvar _a = require('./util'),\n    asLocalTrack = _a.asLocalTrack,\n    asLocalTrackPublication = _a.asLocalTrackPublication,\n    trackClass = _a.trackClass;\n\nvar _b = require('./util/constants'),\n    E = _b.typeErrors,\n    trackPriority = _b.trackPriority;\n\nvar validateLocalTrack = require('./util/validate').validateLocalTrack;\n\nvar _c = require('./media/track/es5'),\n    LocalAudioTrack = _c.LocalAudioTrack,\n    LocalDataTrack = _c.LocalDataTrack,\n    LocalVideoTrack = _c.LocalVideoTrack;\n\nvar LocalAudioTrackPublication = require('./media/track/localaudiotrackpublication');\n\nvar LocalDataTrackPublication = require('./media/track/localdatatrackpublication');\n\nvar LocalVideoTrackPublication = require('./media/track/localvideotrackpublication');\n\nvar Participant = require('./participant');\n/**\n * A {@link LocalParticipant} represents the local {@link Participant} in a\n * {@link Room}.\n * @extends Participant\n * @property {Map<Track.SID, LocalAudioTrackPublication>} audioTracks -\n *    The {@link LocalParticipant}'s {@link LocalAudioTrackPublication}s\n * @property {Map<Track.SID, LocalDataTrackPublication>} dataTracks -\n *    The {@link LocalParticipant}'s {@link LocalDataTrackPublication}s\n * @property {Map<Track.SID, LocalTrackPublication>} tracks -\n *    The {@link LocalParticipant}'s {@link LocalTrackPublication}s\n * @property {Map<Track.SID, LocalVideoTrackPublication>} videoTracks -\n *    The {@link LocalParticipant}'s {@link LocalVideoTrackPublication}s\n * @property {string} signalingRegion - The geographical region of the\n *     signaling edge the {@link LocalParticipant} is connected to.\n *\n * @emits RemoteParticipant#reconnected\n * @emits RemoteParticipant#reconnecting\n * @emits LocalParticipant#trackDimensionsChanged\n * @emits LocalParticipant#trackDisabled\n * @emits LocalParticipant#trackEnabled\n * @emits LocalParticipant#trackPublicationFailed\n * @emits LocalParticipant#trackPublished\n * @emits LocalParticipant#trackStarted\n * @emits LocalParticipant#trackStopped\n */\n\n\nvar LocalParticipant =\n/** @class */\nfunction (_super) {\n  __extends(LocalParticipant, _super);\n  /**\n   * Construct a {@link LocalParticipant}.\n   * @param {ParticipantSignaling} signaling\n   * @param {Array<LocalTrack>} localTracks\n   * @param {Object} options\n   */\n\n\n  function LocalParticipant(signaling, localTracks, options) {\n    var _this = this;\n\n    options = Object.assign({\n      LocalAudioTrack: LocalAudioTrack,\n      LocalVideoTrack: LocalVideoTrack,\n      LocalDataTrack: LocalDataTrack,\n      MediaStreamTrack: MediaStreamTrack,\n      LocalAudioTrackPublication: LocalAudioTrackPublication,\n      LocalVideoTrackPublication: LocalVideoTrackPublication,\n      LocalDataTrackPublication: LocalDataTrackPublication,\n      shouldStopLocalTracks: false,\n      tracks: localTracks\n    }, options);\n    var tracksToStop = options.shouldStopLocalTracks ? new Set(localTracks.filter(function (localTrack) {\n      return localTrack.kind !== 'data';\n    })) : new Set();\n    _this = _super.call(this, signaling, options) || this;\n    Object.defineProperties(_this, {\n      _eventObserver: {\n        value: options.eventObserver\n      },\n      _LocalAudioTrack: {\n        value: options.LocalAudioTrack\n      },\n      _LocalDataTrack: {\n        value: options.LocalDataTrack\n      },\n      _LocalVideoTrack: {\n        value: options.LocalVideoTrack\n      },\n      _MediaStreamTrack: {\n        value: options.MediaStreamTrack\n      },\n      _LocalAudioTrackPublication: {\n        value: options.LocalAudioTrackPublication\n      },\n      _LocalDataTrackPublication: {\n        value: options.LocalDataTrackPublication\n      },\n      _LocalVideoTrackPublication: {\n        value: options.LocalVideoTrackPublication\n      },\n      _tracksToStop: {\n        value: tracksToStop\n      },\n      signalingRegion: {\n        enumerable: true,\n        get: function () {\n          return signaling.signalingRegion;\n        }\n      }\n    });\n\n    _this._handleTrackSignalingEvents();\n\n    return _this;\n  }\n  /**\n   * @private\n   * @param {LocalTrack} track\n   * @param {Track.ID} id\n   * @param {Track.Priority} priority\n   * @returns {?LocalTrack}\n   */\n\n\n  LocalParticipant.prototype._addTrack = function (track, id, priority) {\n    var addedTrack = _super.prototype._addTrack.call(this, track, id);\n\n    if (addedTrack && this.state !== 'disconnected') {\n      this._addLocalTrack(track, priority);\n    }\n\n    return addedTrack;\n  };\n  /**\n   * @private\n   * @param {LocalTrack} track\n   * @param {Track.Priority} priority\n   * @returns {void}\n   */\n\n\n  LocalParticipant.prototype._addLocalTrack = function (track, priority) {\n    this._signaling.addTrack(track._trackSender, track.name, priority);\n\n    this._log.info(\"Added a new \" + trackClass(track, true) + \":\", track.id);\n\n    this._log.debug(trackClass(track, true) + \":\", track);\n  };\n  /**\n   * @private\n   * @param {LocalTrack} track\n   * @param {Track.ID} id\n   * @returns {?LocalTrack}\n   */\n\n\n  LocalParticipant.prototype._removeTrack = function (track, id) {\n    var removedTrack = _super.prototype._removeTrack.call(this, track, id);\n\n    if (removedTrack && this.state !== 'disconnected') {\n      this._signaling.removeTrack(track._trackSender);\n\n      this._log.info(\"Removed a \" + trackClass(track, true) + \":\", track.id);\n\n      this._log.debug(trackClass(track, true) + \":\", track);\n    }\n\n    return removedTrack;\n  };\n  /**\n   * Get the {@link LocalTrack} events to re-emit.\n   * @private\n   * @returns {Array<Array<string>>} events\n   */\n\n\n  LocalParticipant.prototype._getTrackEvents = function () {\n    return _super.prototype._getTrackEvents.call(this).concat([['disabled', 'trackDisabled'], ['enabled', 'trackEnabled'], ['stopped', 'trackStopped']]);\n  };\n\n  LocalParticipant.prototype.toString = function () {\n    return \"[LocalParticipant #\" + this._instanceId + (this.sid ? \": \" + this.sid : '') + \"]\";\n  };\n  /**\n   * @private\n   */\n\n\n  LocalParticipant.prototype._handleTrackSignalingEvents = function () {\n    var _this = this;\n\n    var log = this._log;\n\n    if (this.state === 'disconnected') {\n      return;\n    }\n\n    var signaling = this._signaling;\n\n    function localTrackDisabled(localTrack) {\n      var trackSignaling = signaling.getPublication(localTrack._trackSender);\n\n      if (trackSignaling) {\n        trackSignaling.disable();\n        log.debug(\"Disabled the \" + trackClass(localTrack, true) + \":\", localTrack.id);\n      }\n    }\n\n    function localTrackEnabled(localTrack) {\n      var trackSignaling = signaling.getPublication(localTrack._trackSender);\n\n      if (trackSignaling) {\n        trackSignaling.enable();\n        log.debug(\"Enabled the \" + trackClass(localTrack, true) + \":\", localTrack.id);\n      }\n    }\n\n    function localTrackStopped(localTrack) {\n      // NOTE(mroberts): We shouldn't need to check for `stop`, since DataTracks\n      // do not emit \"stopped\".\n      var trackSignaling = signaling.getPublication(localTrack._trackSender);\n\n      if (trackSignaling) {\n        trackSignaling.stop();\n      }\n\n      return trackSignaling;\n    }\n\n    this.on('trackDisabled', localTrackDisabled);\n    this.on('trackEnabled', localTrackEnabled);\n    this.on('trackStopped', localTrackStopped);\n\n    this._tracks.forEach(function (track) {\n      _this._addLocalTrack(track, trackPriority.PRIORITY_STANDARD);\n\n      _this._getOrCreateLocalTrackPublication(track).catch(function (error) {\n        // Just log a warning for now.\n        log.warn(\"Failed to get or create LocalTrackPublication for \" + track + \":\", error);\n      });\n    });\n\n    var self = this;\n    signaling.on('stateChanged', function stateChanged(state) {\n      log.debug('Transitioned to state:', state);\n\n      if (state === 'disconnected') {\n        log.debug('Removing LocalTrack event listeners');\n        signaling.removeListener('stateChanged', stateChanged);\n        self.removeListener('trackDisabled', localTrackDisabled);\n        self.removeListener('trackEnabled', localTrackEnabled);\n        self.removeListener('trackStopped', localTrackStopped); // NOTE(mmalavalli): Remove the stale MediaTrackSender clones so that we\n        // do not call replaceTrack() on their RTCRtpSenders.\n\n        self._tracks.forEach(function (track) {\n          var trackSignaling = localTrackStopped(track);\n\n          if (trackSignaling) {\n            track._trackSender.removeClone(trackSignaling._trackTransceiver);\n          }\n        });\n\n        log.info(\"LocalParticipant disconnected. Stopping \" + self._tracksToStop.size + \" automatically-acquired LocalTracks\");\n\n        self._tracksToStop.forEach(function (track) {\n          track.stop();\n        });\n      } else if (state === 'connected') {\n        // NOTE(mmalavalli): Any transition to \"connected\" here is a result of\n        // successful signaling reconnection, and not a first-time establishment\n        // of the signaling connection.\n        log.info('reconnected'); // NOTE(mpatwardhan): `stateChanged` can get emitted with StateMachine locked.\n        // Do not signal  public events synchronously with lock held.\n\n        setTimeout(function () {\n          return self.emit('reconnected');\n        }, 0);\n      }\n    });\n  };\n  /**\n   * @private\n   * @param {LocalTrack} localTrack\n   * @returns {Promise<LocalTrackPublication>}\n   */\n\n\n  LocalParticipant.prototype._getOrCreateLocalTrackPublication = function (localTrack) {\n    var localTrackPublication = getTrackPublication(this.tracks, localTrack);\n\n    if (localTrackPublication) {\n      return Promise.resolve(localTrackPublication);\n    }\n\n    var log = this._log;\n    var self = this;\n\n    var trackSignaling = this._signaling.getPublication(localTrack._trackSender);\n\n    if (!trackSignaling) {\n      return Promise.reject(new Error(\"Unexpected error: The \" + localTrack + \" cannot be published\"));\n    }\n\n    function unpublish(publication) {\n      self.unpublishTrack(publication.track);\n    }\n\n    return new Promise(function (resolve, reject) {\n      function updated() {\n        var error = trackSignaling.error;\n\n        if (error) {\n          trackSignaling.removeListener('updated', updated);\n          log.warn(\"Failed to publish the \" + trackClass(localTrack, true) + \": \" + error.message);\n\n          self._removeTrack(localTrack, localTrack.id);\n\n          setTimeout(function () {\n            self.emit('trackPublicationFailed', error, localTrack);\n          });\n          reject(error);\n          return;\n        }\n\n        if (!self._tracks.has(localTrack.id)) {\n          trackSignaling.removeListener('updated', updated);\n          reject(new Error(\"The \" + localTrack + \" was unpublished\"));\n          return;\n        }\n\n        var sid = trackSignaling.sid;\n\n        if (!sid) {\n          return;\n        }\n\n        trackSignaling.removeListener('updated', updated);\n        var options = {\n          log: log,\n          LocalAudioTrackPublication: self._LocalAudioTrackPublication,\n          LocalDataTrackPublication: self._LocalDataTrackPublication,\n          LocalVideoTrackPublication: self._LocalVideoTrackPublication\n        };\n        localTrackPublication = getTrackPublication(self.tracks, localTrack);\n\n        if (!localTrackPublication) {\n          localTrackPublication = asLocalTrackPublication(localTrack, trackSignaling, unpublish, options);\n\n          self._addTrackPublication(localTrackPublication);\n        }\n\n        var state = self._signaling.state;\n\n        if (state === 'connected' || state === 'connecting') {\n          if (localTrack._processorEventObserver) {\n            localTrack._processorEventObserver.on('event', function (event) {\n              self._eventObserver.emit('event', {\n                name: event.name,\n                payload: event.data,\n                group: 'video-processor',\n                level: 'info'\n              });\n            });\n          } // NOTE(csantos): For tracks created before joining a room or already joined but about to publish it\n\n\n          if (localTrack.processedTrack) {\n            localTrack._captureFrames();\n\n            localTrack._setSenderMediaStreamTrack(true);\n          }\n        }\n\n        if (state === 'connected') {\n          setTimeout(function () {\n            self.emit('trackPublished', localTrackPublication);\n          });\n        }\n\n        resolve(localTrackPublication);\n      }\n\n      trackSignaling.on('updated', updated);\n    });\n  };\n  /**\n   * Publishes a {@link LocalTrack} to the {@link Room}.\n   * @param {LocalTrack} localTrack - The {@link LocalTrack} to publish\n   * @param {LocalTrackPublishOptions} [options] - The {@link LocalTrackPublishOptions}\n   *   for publishing the {@link LocalTrack}\n   * @returns {Promise<LocalTrackPublication>} - Resolves with the corresponding\n   *   {@link LocalTrackPublication} if successful; In a Large Group Room (Maximum\n   *   Participants greater than 50), rejects with a {@link ParticipantMaxTracksExceededError}\n   *   if either the total number of published Tracks in the Room exceeds 16, or the {@link LocalTrack}\n   *   is part of a set of {@link LocalTrack}s which along with the published Tracks exceeds 16.\n   * @throws {TypeError}\n   * @throws {RangeError}\n   * @example\n   * var Video = require('twilio-video');\n   *\n   * Video.connect(token, {\n   *   name: 'my-cool-room',\n   *   audio: true\n   * }).then(function(room) {\n   *   return Video.createLocalVideoTrack({\n   *     name: 'camera'\n   *   }).then(function(localVideoTrack) {\n   *     return room.localParticipant.publishTrack(localVideoTrack, {\n   *       priority: 'high'\n   *     });\n   *   });\n   * }).then(function(publication) {\n   *   console.log('The LocalTrack \"' + publication.trackName\n   *     + '\" was successfully published with priority \"'\n   *     * publication.priority + '\"');\n   * });\n  */\n\n  /**\n  * Publishes a MediaStreamTrack to the {@link Room}.\n  * @param {MediaStreamTrack} mediaStreamTrack - The MediaStreamTrack\n  *   to publish; if a corresponding {@link LocalAudioTrack} or\n  *   {@link LocalVideoTrack} has not yet been published, this method will\n  *   construct one\n  * @param {MediaStreamTrackPublishOptions} [options] - The options for publishing\n  *   the MediaStreamTrack\n  * @returns {Promise<LocalTrackPublication>} - Resolves with the corresponding\n  *   {@link LocalTrackPublication} if successful; In a Large Group Room (Maximum\n  *   Participants greater than 50), rejects with a {@link ParticipantMaxTracksExceededError}\n  *   if the total number of published Tracks in the Room exceeds 16, or the {@link LocalTrack}\n  *   is part of a set of {@link LocalTrack}s which along with the published Tracks exceeds 16.\n  * @throws {TypeError}\n  * @throws {RangeError}\n  * @example\n  * var Video = require('twilio-video');\n  *\n  * Video.connect(token, {\n  *   name: 'my-cool-room',\n  *   audio: true\n  * }).then(function(room) {\n  *   return navigator.mediaDevices.getUserMedia({\n  *     video: true\n  *   }).then(function(mediaStream) {\n  *     var mediaStreamTrack = mediaStream.getTracks()[0];\n  *     return room.localParticipant.publishTrack(mediaStreamTrack, {\n  *       name: 'camera',\n  *       priority: 'high'\n  *     });\n  *   });\n  * }).then(function(publication) {\n  *   console.log('The LocalTrack \"' + publication.trackName\n  *     + '\" was successfully published with priority \"'\n  *     * publication.priority + '\"');\n  * });\n  */\n\n\n  LocalParticipant.prototype.publishTrack = function (localTrackOrMediaStreamTrack, options) {\n    var trackPublication = getTrackPublication(this.tracks, localTrackOrMediaStreamTrack);\n\n    if (trackPublication) {\n      return Promise.resolve(trackPublication);\n    }\n\n    options = Object.assign({\n      log: this._log,\n      priority: trackPriority.PRIORITY_STANDARD,\n      LocalAudioTrack: this._LocalAudioTrack,\n      LocalDataTrack: this._LocalDataTrack,\n      LocalVideoTrack: this._LocalVideoTrack,\n      MediaStreamTrack: this._MediaStreamTrack\n    }, options);\n    var localTrack;\n\n    try {\n      localTrack = asLocalTrack(localTrackOrMediaStreamTrack, options);\n    } catch (error) {\n      return Promise.reject(error);\n    }\n\n    var priorityValues = Object.values(trackPriority);\n\n    if (!priorityValues.includes(options.priority)) {\n      // eslint-disable-next-line new-cap\n      return Promise.reject(E.INVALID_VALUE('LocalTrackPublishOptions.priority', priorityValues));\n    }\n\n    var addedLocalTrack = this._addTrack(localTrack, localTrack.id, options.priority) || this._tracks.get(localTrack.id);\n\n    return this._getOrCreateLocalTrackPublication(addedLocalTrack);\n  };\n  /**\n   * Publishes multiple {@link LocalTrack}s to the {@link Room}.\n   * @param {Array<LocalTrack|MediaStreamTrack>} tracks - The {@link LocalTrack}s\n   *   to publish; for any MediaStreamTracks provided, if a corresponding\n   *   {@link LocalAudioTrack} or {@link LocalVideoTrack} has not yet been\n   *   published, this method will construct one\n   * @returns {Promise<Array<LocalTrackPublication>>} - The resulting\n   *   {@link LocalTrackPublication}s if successful; In a Large Group Room (Maximum\n   *   Participants greater than 50), rejects with a {@link ParticipantMaxTracksExceededError}\n   *   if the total number of published Tracks in the Room exceeds 16, or the {@link LocalTrack}s\n   *   along with the published Tracks exceeds 16.\n   * @throws {TypeError}\n   */\n\n\n  LocalParticipant.prototype.publishTracks = function (tracks) {\n    if (!Array.isArray(tracks)) {\n      // eslint-disable-next-line new-cap\n      throw E.INVALID_TYPE('tracks', 'Array of LocalAudioTrack, LocalVideoTrack, LocalDataTrack, or MediaStreamTrack');\n    }\n\n    return Promise.all(tracks.map(this.publishTrack, this));\n  };\n\n  LocalParticipant.prototype.setBandwidthProfile = function () {\n    this._log.warn('setBandwidthProfile is not implemented yet and may be available in future versions of twilio-video.js');\n  };\n  /**\n   * Sets the {@link NetworkQualityVerbosity} for the {@link LocalParticipant} and\n   * {@link RemoteParticipant}s. It does nothing if Network Quality is not enabled\n   * while calling {@link connect}.\n   * @param {NetworkQualityConfiguration} networkQualityConfiguration - The new\n   *   {@link NetworkQualityConfiguration}; If either or both of the local and\n   *   remote {@link NetworkQualityVerbosity} values are absent, then the corresponding\n   *   existing values are retained\n   * @returns {this}\n   * @example\n   * // Update verbosity levels for both LocalParticipant and RemoteParticipants\n   * localParticipant.setNetworkQualityConfiguration({\n   *   local: 1,\n   *   remote: 2\n   * });\n   * @example\n   * // Update verbosity level for only the LocalParticipant\n   * localParticipant.setNetworkQualityConfiguration({\n   *   local: 1\n   * });\n   *  @example\n   * // Update verbosity level for only the RemoteParticipants\n   * localParticipant.setNetworkQualityConfiguration({\n   *   remote: 2\n   * });\n   */\n\n\n  LocalParticipant.prototype.setNetworkQualityConfiguration = function (networkQualityConfiguration) {\n    if (typeof networkQualityConfiguration !== 'object' || networkQualityConfiguration === null) {\n      // eslint-disable-next-line new-cap\n      throw E.INVALID_TYPE('networkQualityConfiguration', 'NetworkQualityConfiguration');\n    }\n\n    ['local', 'remote'].forEach(function (prop) {\n      if (prop in networkQualityConfiguration && (typeof networkQualityConfiguration[prop] !== 'number' || isNaN(networkQualityConfiguration[prop]))) {\n        // eslint-disable-next-line new-cap\n        throw E.INVALID_TYPE(\"networkQualityConfiguration.\" + prop, 'number');\n      }\n    });\n\n    this._signaling.setNetworkQualityConfiguration(networkQualityConfiguration);\n\n    return this;\n  };\n  /**\n   * Set the {@link LocalParticipant}'s {@link EncodingParameters}.\n   * @param {?EncodingParameters} [encodingParameters] - The new\n   *   {@link EncodingParameters}; If null, then the bitrate limits are removed;\n   *   If not specified, then the existing bitrate limits are preserved\n   * @returns {this}\n   * @throws {TypeError}\n   */\n\n\n  LocalParticipant.prototype.setParameters = function (encodingParameters) {\n    if (typeof encodingParameters !== 'undefined' && typeof encodingParameters !== 'object') {\n      // eslint-disable-next-line new-cap\n      throw E.INVALID_TYPE('encodingParameters', 'EncodingParameters, null or undefined');\n    }\n\n    if (encodingParameters) {\n      if (this._signaling.getParameters().adaptiveSimulcast && encodingParameters.maxVideoBitrate) {\n        // eslint-disable-next-line new-cap\n        throw E.INVALID_TYPE('encodingParameters', 'encodingParameters.maxVideoBitrate is not compatible with \"preferredVideoCodecs=auto\"');\n      }\n\n      ['maxAudioBitrate', 'maxVideoBitrate'].forEach(function (prop) {\n        if (typeof encodingParameters[prop] !== 'undefined' && typeof encodingParameters[prop] !== 'number' && encodingParameters[prop] !== null) {\n          // eslint-disable-next-line new-cap\n          throw E.INVALID_TYPE(\"encodingParameters.\" + prop, 'number, null or undefined');\n        }\n      });\n    } else if (encodingParameters === null) {\n      encodingParameters = {\n        maxAudioBitrate: null,\n        maxVideoBitrate: null\n      };\n    }\n\n    this._signaling.setParameters(encodingParameters);\n\n    return this;\n  };\n  /**\n   * Stops publishing a {@link LocalTrack} to the {@link Room}.\n   * @param {LocalTrack|MediaStreamTrack} track - The {@link LocalTrack}\n   *   to stop publishing; if a MediaStreamTrack is provided, this method\n   *   looks up the corresponding {@link LocalAudioTrack} or\n   *   {@link LocalVideoTrack} to stop publishing\n   * @returns {?LocalTrackPublication} - The corresponding\n   *   {@link LocalTrackPublication} if the {@link LocalTrack} was previously\n   *   published, null otherwise\n   * @throws {TypeError}\n  */\n\n\n  LocalParticipant.prototype.unpublishTrack = function (track) {\n    validateLocalTrack(track, {\n      LocalAudioTrack: this._LocalAudioTrack,\n      LocalDataTrack: this._LocalDataTrack,\n      LocalVideoTrack: this._LocalVideoTrack,\n      MediaStreamTrack: this._MediaStreamTrack\n    });\n\n    var localTrack = this._tracks.get(track.id);\n\n    if (!localTrack) {\n      return null;\n    }\n\n    var trackSignaling = this._signaling.getPublication(localTrack._trackSender);\n\n    trackSignaling.publishFailed(new Error(\"The \" + localTrack + \" was unpublished\"));\n    localTrack = this._removeTrack(localTrack, localTrack.id);\n\n    if (!localTrack) {\n      return null;\n    }\n\n    var localTrackPublication = getTrackPublication(this.tracks, localTrack);\n\n    if (localTrackPublication) {\n      this._removeTrackPublication(localTrackPublication);\n    }\n\n    return localTrackPublication;\n  };\n  /**\n   * Stops publishing multiple {@link LocalTrack}s to the {@link Room}.\n   * @param {Array<LocalTrack|MediaStreamTrack>} tracks - The {@link LocalTrack}s\n   *   to stop publishing; for any MediaStreamTracks provided, this method looks\n   *   up the corresponding {@link LocalAudioTrack} or {@link LocalVideoTrack} to\n   *   stop publishing\n   * @returns {Array<LocalTrackPublication>} - The corresponding\n   *   {@link LocalTrackPublication}s that were successfully unpublished\n   * @throws {TypeError}\n   */\n\n\n  LocalParticipant.prototype.unpublishTracks = function (tracks) {\n    var _this = this;\n\n    if (!Array.isArray(tracks)) {\n      // eslint-disable-next-line new-cap\n      throw E.INVALID_TYPE('tracks', 'Array of LocalAudioTrack, LocalVideoTrack, LocalDataTrack, or MediaStreamTrack');\n    }\n\n    return tracks.reduce(function (unpublishedTracks, track) {\n      var unpublishedTrack = _this.unpublishTrack(track);\n\n      return unpublishedTrack ? unpublishedTracks.concat(unpublishedTrack) : unpublishedTracks;\n    }, []);\n  };\n\n  return LocalParticipant;\n}(Participant);\n/**\n * The {@link LocalParticipant} has reconnected to the {@link Room} after a signaling connection disruption.\n * @event LocalParticipant#reconnected\n */\n\n/**\n * The {@link LocalParticipant} is reconnecting to the {@link Room} after a signaling connection disruption.\n * @event LocalParticipant#reconnecting\n */\n\n/**\n * One of the {@link LocalParticipant}'s {@link LocalVideoTrack}'s dimensions changed.\n * @param {LocalVideoTrack} track - The {@link LocalVideoTrack} whose dimensions changed\n * @event LocalParticipant#trackDimensionsChanged\n */\n\n/**\n * A {@link LocalTrack} was disabled by the {@link LocalParticipant}.\n * @param {LocalTrack} track - The {@link LocalTrack} that was disabled\n * @event LocalParticipant#trackDisabled\n */\n\n/**\n * A {@link LocalTrack} was enabled by the {@link LocalParticipant}.\n * @param {LocalTrack} track - The {@link LocalTrack} that was enabled\n * @event LocalParticipant#trackEnabled\n */\n\n/**\n * A {@link LocalTrack} failed to publish. Check the error message for more\n * information. In a Large Group Room (Maximum Participants greater than 50),\n * this event is raised with a {@link ParticipantMaxTracksExceededError} either\n * when attempting to publish the {@link LocalTrack} will exceed the Maximum Published\n * Tracks limit of 16, or the {@link LocalTrack} is part of a set of {@link LocalTrack}s\n * which along with the published Tracks exceeds 16.\n * @param {TwilioError} error - A {@link TwilioError} explaining why publication\n *   failed\n * @param {LocalTrack} localTrack - The {@link LocalTrack} that failed to\n *   publish\n * @event LocalParticipant#trackPublicationFailed\n */\n\n/**\n * A {@link LocalTrack} was successfully published.\n * @param {LocalTrackPublication} publication - The resulting\n *   {@link LocalTrackPublication} for the published {@link LocalTrack}\n * @event LocalParticipant#trackPublished\n */\n\n/**\n * One of the {@link LocalParticipant}'s {@link LocalTrack}s started.\n * @param {LocalTrack} track - The {@link LocalTrack} that started\n * @event LocalParticipant#trackStarted\n */\n\n/**\n * One of the {@link LocalParticipant}'s {@link LocalTrack}s stopped, either\n * because {@link LocalTrack#stop} was called or because the underlying\n * MediaStreamTrack ended).\n * @param {LocalTrack} track - The {@link LocalTrack} that stopped\n * @event LocalParticipant#trackStopped\n */\n\n/**\n * Outgoing media encoding parameters.\n * @typedef {object} EncodingParameters\n * @property {?number} [maxAudioBitrate] - Max outgoing audio bitrate (bps);\n *   If not specified, retains the existing bitrate limit; A <code>null</code> or a\n *   <code>0</code> value removes any previously set bitrate limit; This value is set\n *   as a hint for variable bitrate codecs, but will not take effect for fixed bitrate\n *   codecs; Based on our tests, Chrome, Firefox and Safari support a bitrate range of\n *   12000 bps to 256000 bps for Opus codec; This parameter has no effect on iSAC, PCMU\n *   and PCMA codecs\n * @property {?number} [maxVideoBitrate] - Max outgoing video bitrate (bps);\n *   If not specified, retains the existing bitrate limit; A <code>null</code> or\n *   a <code>0</code> value removes any previously set bitrate limit; This value is\n *   set as a hint for variable bitrate codecs, but will not take effect for fixed\n *   bitrate codecs; Based on our tests, Chrome, Firefox and Safari all seem to support\n *   an average bitrate range of 20000 bps (20 kbps) to 8000000 bps (8 mbps) for a\n *   720p VideoTrack.\n *   Note: this limit is not applied for screen share tracks published on Chrome.\n */\n\n/**\n * Options for publishing a {@link LocalTrack}.\n * @typedef {object} LocalTrackPublishOptions\n * @property {Track.Priority} [priority='standard'] - The priority with which the {@link LocalTrack}\n *   is to be published; In Group or Small Group Rooms, the appropriate bandwidth is\n *   allocated to the {@link LocalTrack} based on its {@link Track.Priority}; It has no\n *   effect in Peer-to-Peer Rooms; It defaults to \"standard\" when not provided\n */\n\n/**\n * Options for publishing a {@link MediaStreamTrack}.\n * @typedef {LocalTrackOptions} MediaStreamTrackPublishOptions\n * @property {Track.Priority} [priority='standard'] - The priority with which the {@link LocalTrack}\n *   is to be published; In Group or Small Group Rooms, the appropriate bandwidth is\n *   allocated to the {@link LocalTrack} based on its {@link Track.Priority}; It has no\n *   effect in Peer-to-Peer Rooms; It defaults to \"standard\" when not provided\n */\n\n/**\n * @private\n * @param {Map<Track.SID, LocalTrackPublication>} trackPublications\n * @param {LocalTrack|MediaStreamTrack} track\n * @returns {?LocalTrackPublication} trackPublication\n */\n\n\nfunction getTrackPublication(trackPublications, track) {\n  return Array.from(trackPublications.values()).find(function (trackPublication) {\n    return trackPublication.track === track || trackPublication.track.mediaStreamTrack === track;\n  }) || null;\n}\n\nmodule.exports = LocalParticipant;","map":null,"metadata":{},"sourceType":"script"}