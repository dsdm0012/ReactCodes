{"ast":null,"code":"'use strict';\n\nvar defer = require('./').defer;\n/**\n * An {@link AsyncVar} is an \"asynchronous variable\" which may or may not\n * contain a value of some type T. You can put a value into the {@link AsyncVar}\n * with {@link AsyncVar#put}. Callers can take a value out of the\n * {@link AsyncVar} by queueing up with {@link AsyncVar#take}. N calls to\n * {@link AsyncVar#take} require N calls to {@link AsyncVar#put} to resolve, and\n * they resolve in order.\n */\n\n\nvar AsyncVar =\n/** @class */\nfunction () {\n  /**\n   * Construct an {@link AsyncVar}.\n   */\n  function AsyncVar() {\n    Object.defineProperties(this, {\n      _deferreds: {\n        value: []\n      },\n      _hasValue: {\n        value: false,\n        writable: true\n      },\n      _value: {\n        value: null,\n        writable: true\n      }\n    });\n  }\n  /**\n   * Put a value into the {@link AsyncVar}.\n   * @param {T} value\n   * @returns {this}\n   */\n\n\n  AsyncVar.prototype.put = function (value) {\n    this._hasValue = true;\n    this._value = value;\n\n    var deferred = this._deferreds.shift();\n\n    if (deferred) {\n      deferred.resolve(value);\n    }\n\n    return this;\n  };\n  /**\n   * Take the value out of the {@link AsyncVar}.\n   * @returns {Promise<T>}\n   */\n\n\n  AsyncVar.prototype.take = function () {\n    var _this = this;\n\n    if (this._hasValue && !this._deferreds.length) {\n      this._hasValue = false;\n      return Promise.resolve(this._value);\n    }\n\n    var deferred = defer();\n\n    this._deferreds.push(deferred);\n\n    return deferred.promise.then(function (value) {\n      _this._hasValue = false;\n      return value;\n    });\n  };\n\n  return AsyncVar;\n}();\n\nmodule.exports = AsyncVar;","map":null,"metadata":{},"sourceType":"script"}