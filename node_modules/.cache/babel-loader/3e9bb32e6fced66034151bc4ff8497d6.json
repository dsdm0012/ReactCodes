{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar StateMachine = require('../../statemachine');\n\nvar TwilioConnection = require('../../twilioconnection');\n\nvar DefaultBackoff = require('../../util/backoff');\n\nvar reconnectBackoffConfig = require('../../util/constants').reconnectBackoffConfig;\n\nvar Timeout = require('../../util/timeout');\n\nvar _a = require('../../util/constants'),\n    SDK_NAME = _a.SDK_NAME,\n    SDK_VERSION = _a.SDK_VERSION,\n    SDP_FORMAT = _a.SDP_FORMAT;\n\nvar _b = require('../../util'),\n    createBandwidthProfilePayload = _b.createBandwidthProfilePayload,\n    createMediaSignalingPayload = _b.createMediaSignalingPayload,\n    createSubscribePayload = _b.createSubscribePayload,\n    getUserAgent = _b.getUserAgent,\n    isNonArrayObject = _b.isNonArrayObject;\n\nvar _c = require('../../util/twilio-video-errors'),\n    createTwilioError = _c.createTwilioError,\n    RoomCompletedError = _c.RoomCompletedError,\n    SignalingConnectionError = _c.SignalingConnectionError,\n    SignalingServerBusyError = _c.SignalingServerBusyError;\n\nvar ICE_VERSION = 1;\nvar RSP_VERSION = 2;\n/*\nTwilioConnectionTransport States\n----------------\n\n                      +-----------+\n                      |           |\n                      |  syncing  |---------+\n                      |           |         |\n                      +-----------+         |\n                         ^     |            |\n                         |     |            |\n                         |     v            v\n    +------------+    +-----------+    +--------------+\n    |            |    |           |    |              |\n    | connecting |--->| connected |--->| disconnected |\n    |            |    |           |    |              |\n    +------------+    +-----------+    +--------------+\n             |                              ^\n             |                              |\n             |                              |\n             +------------------------------+\n\n*/\n\nvar states = {\n  connecting: ['connected', 'disconnected'],\n  connected: ['disconnected', 'syncing'],\n  syncing: ['connected', 'disconnected'],\n  disconnected: []\n};\n/**\n * A {@link TwilioConnectionTransport} supports sending and receiving Room Signaling Protocol\n * (RSP) messages. It also supports RSP requests, such as Sync and Disconnect.\n * @extends StateMachine\n * @emits TwilioConnectionTransport#connected\n * @emits TwilioConnectionTransport#message\n */\n\nvar TwilioConnectionTransport =\n/** @class */\nfunction (_super) {\n  __extends(TwilioConnectionTransport, _super);\n  /**\n   * Construct a {@link TwilioConnectionTransport}.\n   * @param {?string} name\n   * @param {string} accessToken\n   * @param {ParticipantSignaling} localParticipant\n   * @param {PeerConnectionManager} peerConnectionManager\n   * @param {string} wsServer\n   * @param {object} [options]\n   */\n\n\n  function TwilioConnectionTransport(name, accessToken, localParticipant, peerConnectionManager, wsServer, options) {\n    var _this = this;\n\n    options = Object.assign({\n      Backoff: DefaultBackoff,\n      TwilioConnection: TwilioConnection,\n      iceServers: null,\n      trackPriority: true,\n      trackSwitchOff: true,\n      renderHints: true,\n      userAgent: getUserAgent()\n    }, options);\n    _this = _super.call(this, 'connecting', states) || this;\n    Object.defineProperties(_this, {\n      _accessToken: {\n        value: accessToken\n      },\n      _automaticSubscription: {\n        value: options.automaticSubscription\n      },\n      _bandwidthProfile: {\n        value: options.bandwidthProfile\n      },\n      _dominantSpeaker: {\n        value: options.dominantSpeaker\n      },\n      _adaptiveSimulcast: {\n        value: options.adaptiveSimulcast\n      },\n      _eventObserver: {\n        value: options.eventObserver,\n        writable: false\n      },\n      _renderHints: {\n        value: options.renderHints\n      },\n      _iceServersStatus: {\n        value: Array.isArray(options.iceServers) ? 'overrode' : 'acquire'\n      },\n      _localParticipant: {\n        value: localParticipant\n      },\n      _name: {\n        value: name\n      },\n      _networkQuality: {\n        value: isNonArrayObject(options.networkQuality) || options.networkQuality\n      },\n      _options: {\n        value: options\n      },\n      _peerConnectionManager: {\n        value: peerConnectionManager\n      },\n      _sessionTimer: {\n        value: null,\n        writable: true\n      },\n      _sessionTimeoutMS: {\n        value: 0,\n        writable: true\n      },\n      _reconnectBackoff: {\n        value: new options.Backoff(reconnectBackoffConfig)\n      },\n      _session: {\n        value: null,\n        writable: true\n      },\n      _trackPriority: {\n        value: options.trackPriority\n      },\n      _trackSwitchOff: {\n        value: options.trackSwitchOff\n      },\n      _twilioConnection: {\n        value: null,\n        writable: true\n      },\n      _updatesReceived: {\n        value: []\n      },\n      _updatesToSend: {\n        value: []\n      },\n      _userAgent: {\n        value: options.userAgent\n      },\n      _wsServer: {\n        value: wsServer\n      }\n    });\n    setupTransport(_this);\n    return _this;\n  }\n  /**\n   * Create a Connect, Sync or Disconnect RSP message.\n   * @private\n   * @returns {?object}\n   */\n\n\n  TwilioConnectionTransport.prototype._createConnectOrSyncOrDisconnectMessage = function () {\n    if (this.state === 'connected') {\n      return null;\n    }\n\n    if (this.state === 'disconnected') {\n      return {\n        session: this._session,\n        type: 'disconnect',\n        version: RSP_VERSION\n      };\n    }\n\n    var type = {\n      connecting: 'connect',\n      syncing: 'sync'\n    }[this.state];\n    var message = {\n      name: this._name,\n      participant: this._localParticipant.getState(),\n      peer_connections: this._peerConnectionManager.getStates(),\n      type: type,\n      version: RSP_VERSION\n    };\n\n    if (message.type === 'connect') {\n      message.ice_servers = this._iceServersStatus;\n      message.publisher = {\n        name: SDK_NAME,\n        sdk_version: SDK_VERSION,\n        user_agent: this._userAgent\n      };\n\n      if (this._bandwidthProfile) {\n        message.bandwidth_profile = createBandwidthProfilePayload(this._bandwidthProfile);\n      }\n\n      message.media_signaling = createMediaSignalingPayload(this._dominantSpeaker, this._networkQuality, this._trackPriority, this._trackSwitchOff, this._adaptiveSimulcast, this._renderHints);\n      message.subscribe = createSubscribePayload(this._automaticSubscription);\n      message.format = SDP_FORMAT;\n      message.token = this._accessToken;\n    } else if (message.type === 'sync') {\n      message.session = this._session;\n      message.token = this._accessToken;\n    } else if (message.type === 'update') {\n      message.session = this._session;\n    }\n\n    return message;\n  };\n  /**\n   * Create an \"ice\" message.\n   * @private\n   */\n\n\n  TwilioConnectionTransport.prototype._createIceMessage = function () {\n    return {\n      edge: 'roaming',\n      token: this._accessToken,\n      type: 'ice',\n      version: ICE_VERSION\n    };\n  };\n  /**\n   * Send a Connect, Sync or Disconnect RSP message.\n   * @private\n   */\n\n\n  TwilioConnectionTransport.prototype._sendConnectOrSyncOrDisconnectMessage = function () {\n    var message = this._createConnectOrSyncOrDisconnectMessage();\n\n    if (message) {\n      this._twilioConnection.sendMessage(message);\n    }\n  };\n  /**\n   * Disconnect the {@link TwilioConnectionTransport}. Returns true if calling the method resulted\n   * in disconnection.\n   * @param {TwilioError} [error]\n   * @returns {boolean}\n   */\n\n\n  TwilioConnectionTransport.prototype.disconnect = function (error) {\n    if (this.state !== 'disconnected') {\n      this.preempt('disconnected', null, [error]);\n\n      this._sendConnectOrSyncOrDisconnectMessage();\n\n      this._twilioConnection.close();\n\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Publish an RSP Update. Returns true if calling the method resulted in\n   * publishing (or eventually publishing) the update.\n   * @param {object} update\n   * @returns {boolean}\n   */\n\n\n  TwilioConnectionTransport.prototype.publish = function (update) {\n    switch (this.state) {\n      case 'connected':\n        this._twilioConnection.sendMessage(Object.assign({\n          session: this._session,\n          type: 'update',\n          version: RSP_VERSION\n        }, update));\n\n        return true;\n\n      case 'connecting':\n      case 'syncing':\n        this._updatesToSend.push(update);\n\n        return true;\n\n      case 'disconnected':\n      default:\n        return false;\n    }\n  };\n  /**\n   * Publish (or queue) an event to the Insights gateway.\n   * @param {string} group - Event group name\n   * @param {string} name - Event name\n   * @param {string} level - Event level\n   * @param {object} payload - Event payload\n   * @returns {void}\n   */\n\n\n  TwilioConnectionTransport.prototype.publishEvent = function (group, name, level, payload) {\n    this._eventObserver.emit('event', {\n      group: group,\n      name: name,\n      level: level,\n      payload: payload\n    });\n  };\n  /**\n   * Sync the {@link TwilioConnectionTransport}. Returns true if calling the method resulted in\n   * syncing.\n   * @returns {boolean}\n   */\n\n\n  TwilioConnectionTransport.prototype.sync = function () {\n    if (this.state === 'connected') {\n      this.preempt('syncing');\n\n      this._sendConnectOrSyncOrDisconnectMessage();\n\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * @private\n   * @returns {void}\n   */\n\n\n  TwilioConnectionTransport.prototype._setSession = function (session, sessionTimeout) {\n    this._session = session;\n    this._sessionTimeoutMS = sessionTimeout * 1000;\n  };\n  /**\n   * Determines if we should attempt reconnect.\n   * returns a Promise to wait on before attempting to\n   * reconnect. returns null if its not okay to reconnect.\n   * @private\n   * @returns {Promise<void>}\n   */\n\n\n  TwilioConnectionTransport.prototype._getReconnectTimer = function () {\n    var _this = this;\n\n    if (this._sessionTimeoutMS === 0) {\n      // this means either we have never connected.\n      // or we timed out while trying to reconnect\n      // In either case we do not want to reconnect.\n      return null;\n    } // start session timer\n\n\n    if (!this._sessionTimer) {\n      this._sessionTimer = new Timeout(function () {\n        // ensure that _clearReconnectTimer wasn't\n        // called while we were waiting.\n        if (_this._sessionTimer) {\n          // do not allow any more reconnect attempts.\n          _this._sessionTimeoutMS = 0;\n        }\n      }, this._sessionTimeoutMS);\n    } // return promise that waits with exponential backoff.\n\n\n    return new Promise(function (resolve) {\n      _this._reconnectBackoff.backoff(resolve);\n    });\n  };\n  /**\n   * clears the session reconnect timer.\n   *\n   * @private\n   * @returns {void}\n   */\n\n\n  TwilioConnectionTransport.prototype._clearReconnectTimer = function () {\n    this._reconnectBackoff.reset();\n\n    if (this._sessionTimer) {\n      this._sessionTimer.clear();\n\n      this._sessionTimer = null;\n    }\n  };\n\n  return TwilioConnectionTransport;\n}(StateMachine);\n/**\n * @event TwilioConnectionTransport#connected\n * @param {object} initialState\n */\n\n/**\n * @event TwilioConnectionTransport#message\n * @param {object} peerConnections\n */\n\n\nfunction reducePeerConnections(peerConnections) {\n  return Array.from(peerConnections.reduce(function (peerConnectionsById, update) {\n    var reduced = peerConnectionsById.get(update.id) || update; // First, reduce the top-level `description` property.\n\n    if (!reduced.description && update.description) {\n      reduced.description = update.description;\n    } else if (reduced.description && update.description) {\n      if (update.description.revision > reduced.description.revision) {\n        reduced.description = update.description;\n      }\n    } // Then, reduce the top-level `ice` property.\n\n\n    if (!reduced.ice && update.ice) {\n      reduced.ice = update.ice;\n    } else if (reduced.ice && update.ice) {\n      if (update.ice.revision > reduced.ice.revision) {\n        reduced.ice = update.ice;\n      }\n    } // Finally, update the map.\n\n\n    peerConnectionsById.set(reduced.id, reduced);\n    return peerConnectionsById;\n  }, new Map()).values());\n}\n\nfunction reduceUpdates(updates) {\n  return updates.reduce(function (reduced, update) {\n    // First, reduce the top-level `participant` property.\n    if (!reduced.participant && update.participant) {\n      reduced.participant = update.participant;\n    } else if (reduced.participant && update.participant) {\n      if (update.participant.revision > reduced.participant.revision) {\n        reduced.participant = update.participant;\n      }\n    } // Then, reduce the top-level `peer_connections` property.\n\n    /* eslint camelcase:0 */\n\n\n    if (!reduced.peer_connections && update.peer_connections) {\n      reduced.peer_connections = reducePeerConnections(update.peer_connections);\n    } else if (reduced.peer_connections && update.peer_connections) {\n      reduced.peer_connections = reducePeerConnections(reduced.peer_connections.concat(update.peer_connections));\n    }\n\n    return reduced;\n  }, {});\n}\n\nfunction setupTransport(transport) {\n  function createOrResetTwilioConnection() {\n    if (transport.state === 'disconnected') {\n      return;\n    }\n\n    if (transport._twilioConnection) {\n      transport._twilioConnection.removeListener('message', handleMessage);\n    }\n\n    var _iceServersStatus = transport._iceServersStatus,\n        _options = transport._options,\n        _wsServer = transport._wsServer,\n        state = transport.state;\n    var TwilioConnection = _options.TwilioConnection;\n    var twilioConnection = new TwilioConnection(_wsServer, Object.assign({\n      helloBody: state === 'connecting' && _iceServersStatus === 'acquire' ? transport._createIceMessage() : transport._createConnectOrSyncOrDisconnectMessage()\n    }, _options));\n    twilioConnection.once('close', function (reason) {\n      if (reason === TwilioConnection.CloseReason.LOCAL) {\n        disconnect();\n      } else {\n        disconnect(new Error(reason));\n      }\n    });\n    twilioConnection.on('message', handleMessage);\n    transport._twilioConnection = twilioConnection;\n  }\n\n  function disconnect(error) {\n    if (transport.state === 'disconnected') {\n      return;\n    }\n\n    if (!error) {\n      transport.disconnect();\n      return;\n    }\n\n    var reconnectTimer = transport._getReconnectTimer();\n\n    if (!reconnectTimer) {\n      var twilioError = error.message === TwilioConnection.CloseReason.BUSY ? new SignalingServerBusyError() : new SignalingConnectionError();\n      transport.disconnect(twilioError);\n      return;\n    }\n\n    if (transport.state === 'connected') {\n      transport.preempt('syncing');\n    }\n\n    reconnectTimer.then(createOrResetTwilioConnection);\n  }\n\n  function handleMessage(message) {\n    if (transport.state === 'disconnected') {\n      return;\n    }\n\n    if (message.type === 'error') {\n      transport.disconnect(createTwilioError(message.code, message.message));\n      return;\n    }\n\n    switch (transport.state) {\n      case 'connected':\n        switch (message.type) {\n          case 'connected':\n          case 'synced':\n          case 'update':\n            transport.emit('message', message);\n            return;\n\n          case 'disconnected':\n            transport.disconnect(message.status === 'completed' ? new RoomCompletedError() : null);\n            return;\n\n          default:\n            // Do nothing.\n            return;\n        }\n\n      case 'connecting':\n        switch (message.type) {\n          case 'iced':\n            transport._options.onIced(message.ice_servers).then(function () {\n              transport._sendConnectOrSyncOrDisconnectMessage();\n            });\n\n            return;\n\n          case 'connected':\n            transport._setSession(message.session, message.options.session_timeout);\n\n            transport.emit('connected', message);\n            transport.preempt('connected');\n            return;\n\n          case 'synced':\n          case 'update':\n            transport._updatesReceived.push(message);\n\n            return;\n\n          case 'disconnected':\n            transport.disconnect(message.status === 'completed' ? new RoomCompletedError() : null);\n            return;\n\n          default:\n            // Do nothing.\n            return;\n        }\n\n      case 'syncing':\n        switch (message.type) {\n          case 'connected':\n          case 'update':\n            transport._updatesReceived.push(message);\n\n            return;\n\n          case 'synced':\n            transport._clearReconnectTimer();\n\n            transport.emit('message', message);\n            transport.preempt('connected');\n            return;\n\n          case 'disconnected':\n            transport.disconnect(message.status === 'completed' ? new RoomCompletedError() : null);\n            return;\n\n          default:\n            // Do nothing.\n            return;\n        }\n\n      default:\n        // Impossible\n        return;\n    }\n  }\n\n  transport.on('stateChanged', function stateChanged(state) {\n    switch (state) {\n      case 'connected':\n        {\n          var updates = transport._updatesToSend.splice(0);\n\n          if (updates.length) {\n            transport.publish(reduceUpdates(updates));\n          }\n\n          transport._updatesReceived.splice(0).forEach(function (update) {\n            return transport.emit('message', update);\n          });\n\n          return;\n        }\n\n      case 'disconnected':\n        transport._twilioConnection.removeListener('message', handleMessage);\n\n        transport.removeListener('stateChanged', stateChanged);\n        return;\n\n      case 'syncing':\n        // Do nothing.\n        return;\n\n      default:\n        // Impossible\n        return;\n    }\n  });\n  var _options = transport._options,\n      _iceServersStatus = transport._iceServersStatus;\n  var iceServers = _options.iceServers,\n      onIced = _options.onIced;\n\n  if (_iceServersStatus === 'overrode') {\n    onIced(iceServers).then(createOrResetTwilioConnection);\n  } else {\n    createOrResetTwilioConnection();\n  }\n}\n\nmodule.exports = TwilioConnectionTransport;","map":null,"metadata":{},"sourceType":"script"}