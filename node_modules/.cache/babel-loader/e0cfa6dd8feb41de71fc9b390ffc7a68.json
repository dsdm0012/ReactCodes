{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar mixinRemoteMediaTrack = require('./remotemediatrack');\n\nvar VideoTrack = require('./videotrack');\n\nvar documentVisibilityMonitor = require('../../util/documentvisibilitymonitor.js');\n\nvar NullObserver = require('../../util/nullobserver.js').NullObserver;\n\nvar Timeout = require('../../util/timeout');\n\nvar RemoteMediaVideoTrack = mixinRemoteMediaTrack(VideoTrack);\nvar TRACK_TURN_OF_DELAY_MS = 50;\n/**\n * A {@link RemoteVideoTrack} represents a {@link VideoTrack} published to a\n * {@link Room} by a {@link RemoteParticipant}.\n * @extends VideoTrack\n * @property {boolean} isEnabled - Whether the {@link RemoteVideoTrack} is enabled\n * @property {boolean} isSwitchedOff - Whether the {@link RemoteVideoTrack} is switched off\n * @property {Track.SID} sid - The {@link RemoteVideoTrack}'s SID\n * @property {?Track.Priority} priority - The subscribe priority of the {@link RemoteVideoTrack}\n * @emits RemoteVideoTrack#dimensionsChanged\n * @emits RemoteVideoTrack#disabled\n * @emits RemoteVideoTrack#enabled\n * @emits RemoteVideoTrack#started\n * @emits RemoteVideoTrack#switchedOff\n * @emits RemoteVideoTrack#switchedOn\n */\n\nvar RemoteVideoTrack =\n/** @class */\nfunction (_super) {\n  __extends(RemoteVideoTrack, _super);\n  /**\n   * Construct a {@link RemoteVideoTrack}.\n   * @param {Track.SID} sid - The {@link RemoteVideoTrack}'s SID\n   * @param {MediaTrackReceiver} mediaTrackReceiver - A video MediaStreamTrack container\n   * @param {boolean} isEnabled - whether the {@link RemoteVideoTrack} is enabled\n   * @param {boolean} isSwitchedOff - Whether the {@link RemoteVideoTrack} is switched off\n   * @param {function(?Track.Priority): void} setPriority - Set or clear the subscribe\n   *  {@link Track.Priority} of the {@link RemoteVideoTrack}\n   * @param {function(ClientRenderHint): void} setRenderHint - Set render hints.\n   * @param {{log: Log}} options - The {@link RemoteTrack} options\n   */\n\n\n  function RemoteVideoTrack(sid, mediaTrackReceiver, isEnabled, isSwitchedOff, setPriority, setRenderHint, options) {\n    var _this = this;\n\n    options = Object.assign({\n      clientTrackSwitchOffControl: 'auto',\n      contentPreferencesMode: 'auto',\n      enableDocumentVisibilityTurnOff: true\n    }, options);\n    options = Object.assign({\n      IntersectionObserver: typeof IntersectionObserver === 'undefined' || options.clientTrackSwitchOffControl !== 'auto' ? NullObserver : IntersectionObserver,\n      ResizeObserver: typeof ResizeObserver === 'undefined' || options.contentPreferencesMode !== 'auto' ? NullObserver : ResizeObserver\n    }, options);\n    _this = _super.call(this, sid, mediaTrackReceiver, isEnabled, isSwitchedOff, setPriority, setRenderHint, options) || this;\n    Object.defineProperties(_this, {\n      _enableDocumentVisibilityTurnOff: {\n        value: options.enableDocumentVisibilityTurnOff === true && options.clientTrackSwitchOffControl === 'auto'\n      },\n      _documentVisibilityTurnOffCleanup: {\n        value: null,\n        writable: true\n      },\n      _clientTrackSwitchOffControl: {\n        value: options.clientTrackSwitchOffControl\n      },\n      _contentPreferencesMode: {\n        value: options.contentPreferencesMode\n      },\n      _invisibleElements: {\n        value: new WeakSet()\n      },\n      _elToPipCallbacks: {\n        value: new WeakMap()\n      },\n      _elToPipWindows: {\n        value: new WeakMap()\n      },\n      _turnOffTimer: {\n        value: new Timeout(function () {\n          _this._setRenderHint({\n            enabled: false\n          });\n        }, TRACK_TURN_OF_DELAY_MS, false)\n      },\n      _resizeObserver: {\n        value: new options.ResizeObserver(function (entries) {\n          // NOTE(mpatwardhan): we ignore elements in _invisibleElements\n          // to ensure that ResizeObserver does not end-up turning off a track when a fresh Video element is\n          // attached and IntersectionObserver has not had its callback executed yet.\n          var visibleElementResized = entries.find(function (entry) {\n            return !_this._invisibleElements.has(entry.target);\n          });\n\n          if (visibleElementResized) {\n            maybeUpdateDimensionHint(_this);\n          }\n        })\n      },\n      _intersectionObserver: {\n        value: new options.IntersectionObserver(function (entries) {\n          var shouldSetRenderHint = false;\n          entries.forEach(function (entry) {\n            var wasVisible = !_this._invisibleElements.has(entry.target);\n\n            if (wasVisible !== entry.isIntersecting) {\n              if (entry.isIntersecting) {\n                _this._log.debug('intersectionObserver detected: Off => On');\n\n                _this._invisibleElements.delete(entry.target);\n              } else {\n                _this._log.debug('intersectionObserver detected: On => Off');\n\n                _this._invisibleElements.add(entry.target);\n              }\n\n              shouldSetRenderHint = true;\n            }\n          });\n\n          if (shouldSetRenderHint) {\n            maybeUpdateEnabledHint(_this); // when visibility of an element changes that may cause the \"biggest\" element to change,\n            // update dimensions as well. since dimensions are cached and de-duped at signaling layer,\n            // its okay if they got  resent.\n\n            maybeUpdateDimensionHint(_this);\n          }\n        }, {\n          threshold: 0.25\n        })\n      }\n    });\n    return _this;\n  }\n  /**\n   * @private\n   */\n\n\n  RemoteVideoTrack.prototype._start = function (dummyEl) {\n    var result = _super.prototype._start.call(this, dummyEl); // NOTE(mpatwardhan): after emitting started, update turn off track if not visible.\n\n\n    maybeUpdateEnabledHint(this);\n    return result;\n  };\n  /**\n   * Request to switch on a {@link RemoteVideoTrack}, This method is applicable only for the group rooms and only when connected with\n   * clientTrackSwitchOffControl in video bandwidth profile options set to 'manual'\n   * @returns {this}\n   */\n\n\n  RemoteVideoTrack.prototype.switchOn = function () {\n    if (this._clientTrackSwitchOffControl !== 'manual') {\n      throw new Error('Invalid state. You can call switchOn only when bandwidthProfile.video.clientTrackSwitchOffControl is set to \"manual\"');\n    }\n\n    this._setRenderHint({\n      enabled: true\n    });\n\n    return this;\n  };\n  /**\n   * Request to switch off a {@link RemoteVideoTrack}, This method is applicable only for the group rooms and only when connected with\n   * clientTrackSwitchOffControl in video bandwidth profile options set to 'manual'\n   * @returns {this}\n   */\n\n\n  RemoteVideoTrack.prototype.switchOff = function () {\n    if (this._clientTrackSwitchOffControl !== 'manual') {\n      throw new Error('Invalid state. You can call switchOff only when bandwidthProfile.video.clientTrackSwitchOffControl is set to \"manual\"');\n    }\n\n    this._setRenderHint({\n      enabled: false\n    });\n\n    return this;\n  };\n  /**\n   * Set the {@link RemoteVideoTrack}'s content preferences. This method is applicable only for the group rooms and only when connected with\n   * videoContentPreferencesMode in video bandwidth profile options set to 'manual'\n   * @param {VideoContentPreferences} contentPreferences - requested preferences.\n   * @returns {this}\n   */\n\n\n  RemoteVideoTrack.prototype.setContentPreferences = function (contentPreferences) {\n    if (this._contentPreferencesMode !== 'manual') {\n      throw new Error('Invalid state. You can call switchOn only when bandwidthProfile.video.contentPreferencesMode is set to \"manual\"');\n    }\n\n    if (contentPreferences.renderDimensions) {\n      this._setRenderHint({\n        renderDimensions: contentPreferences.renderDimensions\n      });\n    }\n\n    return this;\n  };\n\n  RemoteVideoTrack.prototype._unObservePip = function (el) {\n    var pipCallbacks = this._elToPipCallbacks.get(el);\n\n    if (pipCallbacks) {\n      el.removeEventListener('enterpictureinpicture', pipCallbacks.onEnterPip);\n      el.removeEventListener('leavepictureinpicture', pipCallbacks.onLeavePip);\n\n      this._elToPipCallbacks.delete(el);\n    }\n  };\n\n  RemoteVideoTrack.prototype._observePip = function (el) {\n    var _this = this;\n\n    var pipCallbacks = this._elToPipCallbacks.get(el);\n\n    if (!pipCallbacks) {\n      var onEnterPip = function onEnterPip(event) {\n        return _this._onEnterPip(event, el);\n      };\n\n      var onLeavePip = function onLeavePip(event) {\n        return _this._onLeavePip(event, el);\n      };\n\n      var onResizePip = function onResizePip(event) {\n        return _this._onResizePip(event, el);\n      };\n\n      el.addEventListener('enterpictureinpicture', onEnterPip);\n      el.addEventListener('leavepictureinpicture', onLeavePip);\n\n      this._elToPipCallbacks.set(el, {\n        onEnterPip: onEnterPip,\n        onLeavePip: onLeavePip,\n        onResizePip: onResizePip\n      });\n    }\n  };\n\n  RemoteVideoTrack.prototype._onEnterPip = function (event, videoEl) {\n    this._log.debug('onEnterPip');\n\n    var pipWindow = event.pictureInPictureWindow;\n\n    this._elToPipWindows.set(videoEl, pipWindow);\n\n    var onResizePip = this._elToPipCallbacks.get(videoEl).onResizePip;\n\n    pipWindow.addEventListener('resize', onResizePip);\n    maybeUpdateEnabledHint(this);\n  };\n\n  RemoteVideoTrack.prototype._onLeavePip = function (event, videoEl) {\n    this._log.debug('onLeavePip');\n\n    this._elToPipWindows.delete(videoEl);\n\n    var onResizePip = this._elToPipCallbacks.get(videoEl).onResizePip;\n\n    var pipWindow = event.pictureInPictureWindow;\n    pipWindow.removeEventListener('resize', onResizePip);\n    maybeUpdateEnabledHint(this);\n  };\n\n  RemoteVideoTrack.prototype._onResizePip = function () {\n    maybeUpdateDimensionHint(this);\n  };\n\n  RemoteVideoTrack.prototype.attach = function (el) {\n    var result = _super.prototype.attach.call(this, el);\n\n    if (this._clientTrackSwitchOffControl === 'auto') {\n      // start off the element as invisible. will mark it\n      // visible (and update render hints) once intersection observer calls back.\n      this._invisibleElements.add(result);\n    }\n\n    this._intersectionObserver.observe(result);\n\n    this._resizeObserver.observe(result);\n\n    if (this._enableDocumentVisibilityTurnOff) {\n      this._documentVisibilityTurnOffCleanup = this._documentVisibilityTurnOffCleanup || setupDocumentVisibilityTurnOff(this);\n    }\n\n    this._observePip(result);\n\n    return result;\n  };\n\n  RemoteVideoTrack.prototype.detach = function (el) {\n    var _this = this;\n\n    var result = _super.prototype.detach.call(this, el);\n\n    var elements = Array.isArray(result) ? result : [result];\n    elements.forEach(function (element) {\n      _this._intersectionObserver.unobserve(element);\n\n      _this._resizeObserver.unobserve(element);\n\n      _this._invisibleElements.delete(element);\n\n      _this._unObservePip(element);\n    });\n\n    if (this._attachments.size === 0) {\n      if (this._documentVisibilityTurnOffCleanup) {\n        this._documentVisibilityTurnOffCleanup();\n\n        this._documentVisibilityTurnOffCleanup = null;\n      }\n    }\n\n    maybeUpdateEnabledHint(this);\n    maybeUpdateDimensionHint(this);\n    return result;\n  };\n  /**\n   * Add a {@link VideoProcessor} to allow for custom processing of video frames belonging to a VideoTrack.\n   * When a Participant un-publishes and re-publishes a VideoTrack, a new RemoteVideoTrack is created and\n   * any VideoProcessors attached to the previous RemoteVideoTrack would have to be re-added again.\n   * Only Chrome supports this as of now. Calling this API from a non-supported browser will result in a log warning.\n   * @param {VideoProcessor} processor - The {@link VideoProcessor} to use.\n   * @returns {this}\n   * @example\n   * class GrayScaleProcessor {\n   *   constructor(percentage) {\n   *     this.percentage = percentage;\n   *   }\n   *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n   *     const context = outputFrameBuffer.getContext('2d');\n   *     context.filter = `grayscale(${this.percentage}%)`;\n   *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n   *   }\n   * }\n   *\n   * const grayscaleProcessor = new GrayScaleProcessor(100);\n   *\n   * Array.from(room.participants.values()).forEach(participant => {\n   *   const remoteVideoTrack = Array.from(participant.videoTracks.values())[0].track;\n   *   remoteVideoTrack.addProcessor(grayscaleProcessor);\n   * });\n   */\n\n\n  RemoteVideoTrack.prototype.addProcessor = function () {\n    return _super.prototype.addProcessor.apply(this, arguments);\n  };\n  /**\n   * Remove the previously added {@link VideoProcessor} using `addProcessor` API.\n   * @param {VideoProcessor} processor - The {@link VideoProcessor} to remove.\n   * @returns {this}\n   * @example\n   * class GrayScaleProcessor {\n   *   constructor(percentage) {\n   *     this.percentage = percentage;\n   *   }\n   *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n   *     const context = outputFrameBuffer.getContext('2d');\n   *     context.filter = `grayscale(${this.percentage}%)`;\n   *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n   *   }\n   * }\n   *\n   * const grayscaleProcessor = new GrayScaleProcessor(100);\n   *\n   * Array.from(room.participants.values()).forEach(participant => {\n   *   const remoteVideoTrack = Array.from(participant.videoTracks.values())[0].track;\n   *   remoteVideoTrack.addProcessor(grayscaleProcessor);\n   * });\n   *\n   * document.getElementById('remove-button').onclick = () => {\n   *   Array.from(room.participants.values()).forEach(participant => {\n   *     const remoteVideoTrack = Array.from(participant.videoTracks.values())[0].track;\n   *     remoteVideoTrack.removeProcessor(grayscaleProcessor);\n   *   });\n   * }\n   */\n\n\n  RemoteVideoTrack.prototype.removeProcessor = function () {\n    return _super.prototype.removeProcessor.apply(this, arguments);\n  };\n\n  RemoteVideoTrack.prototype.toString = function () {\n    return \"[RemoteVideoTrack #\" + this._instanceId + \": \" + this.sid + \"]\";\n  };\n  /**\n   * Update the subscribe {@link Track.Priority} of the {@link RemoteVideoTrack}.\n   * @param {?Track.Priority} priority - the new subscribe {@link Track.Priority};\n   *   If <code>null</code>, then the subscribe {@link Track.Priority} is cleared, which\n   *   means the {@link Track.Priority} set by the publisher is now the effective priority.\n   * @returns {this}\n   * @throws {RangeError}\n   */\n\n\n  RemoteVideoTrack.prototype.setPriority = function (priority) {\n    return _super.prototype.setPriority.call(this, priority);\n  };\n\n  return RemoteVideoTrack;\n}(RemoteMediaVideoTrack);\n\nfunction setupDocumentVisibilityTurnOff(removeVideoTrack) {\n  function onVisibilityChanged() {\n    maybeUpdateEnabledHint(removeVideoTrack);\n  }\n\n  documentVisibilityMonitor.onVisibilityChange(1, onVisibilityChanged);\n  return function () {\n    documentVisibilityMonitor.offVisibilityChange(1, onVisibilityChanged);\n  };\n}\n\nfunction maybeUpdateEnabledHint(remoteVideoTrack) {\n  if (remoteVideoTrack._clientTrackSwitchOffControl !== 'auto') {\n    return;\n  }\n\n  var visibleElements = remoteVideoTrack._getAllAttachedElements().filter(function (el) {\n    return !remoteVideoTrack._invisibleElements.has(el);\n  });\n\n  var pipWindows = remoteVideoTrack._getAllAttachedElements().filter(function (el) {\n    return remoteVideoTrack._elToPipWindows.has(el);\n  }); // even when document is invisible we may have track playing in pip window.\n\n\n  var enabled = pipWindows.length > 0 || document.visibilityState === 'visible' && visibleElements.length > 0;\n\n  if (enabled === true) {\n    remoteVideoTrack._turnOffTimer.clear();\n\n    remoteVideoTrack._setRenderHint({\n      enabled: true\n    });\n  } else if (!remoteVideoTrack._turnOffTimer.isSet) {\n    // set the track to be turned off after some delay.\n    remoteVideoTrack._turnOffTimer.start();\n  }\n}\n\nfunction maybeUpdateDimensionHint(remoteVideoTrack) {\n  if (remoteVideoTrack._contentPreferencesMode !== 'auto') {\n    return;\n  }\n\n  var visibleElements = remoteVideoTrack._getAllAttachedElements().filter(function (el) {\n    return !remoteVideoTrack._invisibleElements.has(el);\n  });\n\n  var pipElements = remoteVideoTrack._getAllAttachedElements().map(function (el) {\n    var pipWindow = remoteVideoTrack._elToPipWindows.get(el);\n\n    return pipWindow ? {\n      clientHeight: pipWindow.height,\n      clientWidth: pipWindow.width\n    } : {\n      clientHeight: 0,\n      clientWidth: 0\n    };\n  });\n\n  var totalElements = visibleElements.concat(pipElements);\n\n  if (totalElements.length > 0) {\n    var _a = __read(totalElements.sort(function (el1, el2) {\n      return el2.clientHeight + el2.clientWidth - el1.clientHeight - el1.clientWidth - 1;\n    }), 1),\n        _b = _a[0],\n        clientHeight = _b.clientHeight,\n        clientWidth = _b.clientWidth;\n\n    var renderDimensions = {\n      height: clientHeight,\n      width: clientWidth\n    };\n\n    remoteVideoTrack._setRenderHint({\n      renderDimensions: renderDimensions\n    });\n  }\n}\n/**\n * @typedef {object} VideoContentPreferences\n * @property {VideoTrack.Dimensions} [renderDimensions] - Render Dimensions to request for the {@link RemoteVideoTrack}.\n */\n\n/**\n * The {@link RemoteVideoTrack}'s dimensions changed.\n * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} whose\n *   dimensions changed\n * @event RemoteVideoTrack#dimensionsChanged\n */\n\n/**\n * The {@link RemoteVideoTrack} was disabled, i.e. \"paused\".\n * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} that was\n *   disabled\n * @event RemoteVideoTrack#disabled\n */\n\n/**\n * The {@link RemoteVideoTrack} was enabled, i.e. \"resumed\".\n * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} that was\n *   enabled\n * @event RemoteVideoTrack#enabled\n */\n\n/**\n * The {@link RemoteVideoTrack} started. This means there is enough video data\n * to begin playback.\n * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} that started\n * @event RemoteVideoTrack#started\n */\n\n/**\n * A {@link RemoteVideoTrack} was switched off.\n * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} that was\n *   switched off\n * @event RemoteVideoTrack#switchedOff\n */\n\n/**\n * A {@link RemoteVideoTrack} was switched on.\n * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} that was\n *   switched on\n * @event RemoteVideoTrack#switchedOn\n */\n\n\nmodule.exports = RemoteVideoTrack;","map":null,"metadata":{},"sourceType":"script"}