{"ast":null,"code":"/* eslint new-cap:0 */\n'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar getUserMedia = require('../../webrtc').getUserMedia;\n\nvar _a = require('../../webrtc/util'),\n    guessBrowser = _a.guessBrowser,\n    isIOSChrome = _a.isIOSChrome;\n\nvar _b = require('../../util'),\n    capitalize = _b.capitalize,\n    defer = _b.defer,\n    isUserMediaTrack = _b.isUserMediaTrack,\n    waitForSometime = _b.waitForSometime,\n    waitForEvent = _b.waitForEvent;\n\nvar ILLEGAL_INVOKE = require('../../util/constants').typeErrors.ILLEGAL_INVOKE;\n\nvar detectSilentAudio = require('../../util/detectsilentaudio');\n\nvar detectSilentVideo = require('../../util/detectsilentvideo');\n\nvar documentVisibilityMonitor = require('../../util/documentvisibilitymonitor.js');\n\nvar localMediaRestartDeferreds = require('../../util/localmediarestartdeferreds');\n\nvar gUMSilentTrackWorkaround = require('../../webaudio/workaround180748');\n\nvar MediaTrackSender = require('./sender');\n\nfunction mixinLocalMediaTrack(AudioOrVideoTrack) {\n  /**\n   * A {@link LocalMediaTrack} represents audio or video that your\n   * {@link LocalParticipant} is sending to a {@link Room}. As such, it can be\n   * enabled and disabled with {@link LocalMediaTrack#enable} and\n   * {@link LocalMediaTrack#disable} or stopped completely with\n   * {@link LocalMediaTrack#stop}.\n   * @emits LocalMediaTrack#stopped\n   */\n  return (\n    /** @class */\n    function (_super) {\n      __extends(LocalMediaTrack, _super);\n      /**\n       * Construct a {@link LocalMediaTrack} from a MediaStreamTrack.\n       * @param {MediaStreamTrack} mediaStreamTrack - The underlying MediaStreamTrack\n       * @param {LocalTrackOptions} [options] - {@link LocalTrack} options\n       */\n\n\n      function LocalMediaTrack(mediaStreamTrack, options) {\n        var _this = this; // NOTE(mpatwardhan): by default workaround for WebKitBug1208516 will be enabled on Safari browsers\n        // although the bug is seen  mainly on iOS devices, we do not have a reliable way to tell iOS from MacOs\n        // userAgent on iOS pretends its macOs if Safari is set to request desktop pages.\n\n\n        var workaroundWebKitBug1208516 = (guessBrowser() === 'safari' || isIOSChrome()) && isUserMediaTrack(mediaStreamTrack) && typeof document === 'object' && typeof document.addEventListener === 'function' && typeof document.visibilityState === 'string';\n        options = Object.assign({\n          getUserMedia: getUserMedia,\n          isCreatedByCreateLocalTracks: false,\n          workaroundWebKitBug1208516: workaroundWebKitBug1208516,\n          gUMSilentTrackWorkaround: gUMSilentTrackWorkaround\n        }, options);\n        var mediaTrackSender = new MediaTrackSender(mediaStreamTrack);\n        var kind = mediaTrackSender.kind;\n        _this = _super.call(this, mediaTrackSender, options) || this;\n        Object.defineProperties(_this, {\n          _constraints: {\n            value: typeof options[kind] === 'object' ? options[kind] : {},\n            writable: true\n          },\n          _getUserMedia: {\n            value: options.getUserMedia\n          },\n          _gUMSilentTrackWorkaround: {\n            value: options.gUMSilentTrackWorkaround\n          },\n          _workaroundWebKitBug1208516: {\n            value: options.workaroundWebKitBug1208516\n          },\n          _workaroundWebKitBug1208516Cleanup: {\n            value: null,\n            writable: true\n          },\n          _didCallEnd: {\n            value: false,\n            writable: true\n          },\n          _isCreatedByCreateLocalTracks: {\n            value: options.isCreatedByCreateLocalTracks\n          },\n          _trackSender: {\n            value: mediaTrackSender\n          },\n          id: {\n            enumerable: true,\n            value: mediaTrackSender.id\n          },\n          isEnabled: {\n            enumerable: true,\n            get: function get() {\n              return mediaTrackSender.enabled;\n            }\n          },\n          isStopped: {\n            enumerable: true,\n            get: function get() {\n              return mediaTrackSender.readyState === 'ended';\n            }\n          }\n        }); // NOTE(mpatwardhan): As a workaround for WebKit bug: https://bugs.webkit.org/show_bug.cgi?id=208516,\n        // upon foregrounding, re-acquire new MediaStreamTrack if the existing one is ended or muted.\n\n        if (_this._workaroundWebKitBug1208516) {\n          _this._workaroundWebKitBug1208516Cleanup = restartWhenInadvertentlyStopped(_this);\n        }\n\n        return _this;\n      }\n      /**\n       * @private\n       */\n\n\n      LocalMediaTrack.prototype._end = function () {\n        if (this._didCallEnd) {\n          return;\n        }\n\n        _super.prototype._end.call(this);\n\n        this._didCallEnd = true;\n        this.emit('stopped', this);\n      };\n      /**\n       * @private\n       */\n\n\n      LocalMediaTrack.prototype._initialize = function () {\n        if (this._didCallEnd) {\n          this._didCallEnd = false;\n        }\n\n        _super.prototype._initialize.call(this);\n      };\n      /**\n       * @private\n       */\n\n\n      LocalMediaTrack.prototype._reacquireTrack = function (constraints) {\n        var _a;\n\n        var _b = this,\n            getUserMedia = _b._getUserMedia,\n            gUMSilentTrackWorkaround = _b._gUMSilentTrackWorkaround,\n            log = _b._log,\n            kind = _b.mediaStreamTrack.kind;\n\n        log.info('Re-acquiring the MediaStreamTrack');\n        log.debug('Constraints:', constraints);\n        var gUMConstraints = Object.assign({\n          audio: false,\n          video: false\n        }, (_a = {}, _a[kind] = constraints, _a));\n        var gUMPromise = this._workaroundWebKitBug1208516Cleanup ? gUMSilentTrackWorkaround(log, getUserMedia, gUMConstraints) : getUserMedia(gUMConstraints);\n        return gUMPromise.then(function (mediaStream) {\n          return mediaStream.getTracks()[0];\n        });\n      };\n      /**\n       * @private\n       */\n\n\n      LocalMediaTrack.prototype._restart = function (constraints) {\n        var _this = this;\n\n        var log = this._log;\n        constraints = constraints || this._constraints; // NOTE(mmalavalli): If we try and restart a silent MediaStreamTrack\n        // without stopping it first, then a NotReadableError is raised in case of\n        // video, or the restarted audio will still be silent. Hence, we stop the\n        // MediaStreamTrack here.\n\n        this._stop();\n\n        return this._reacquireTrack(constraints).catch(function (error) {\n          log.error('Failed to re-acquire the MediaStreamTrack:', {\n            error: error,\n            constraints: constraints\n          });\n          throw error;\n        }).then(function (newMediaStreamTrack) {\n          log.info('Re-acquired the MediaStreamTrack');\n          log.debug('MediaStreamTrack:', newMediaStreamTrack);\n          _this._constraints = Object.assign({}, constraints);\n          return _this._setMediaStreamTrack(newMediaStreamTrack);\n        });\n      };\n      /**\n       * @private\n       */\n\n\n      LocalMediaTrack.prototype._setMediaStreamTrack = function (mediaStreamTrack) {\n        var _this = this; // NOTE(mpatwardhan): Preserve the value of the \"enabled\" flag.\n\n\n        mediaStreamTrack.enabled = this.mediaStreamTrack.enabled; // NOTE(mmalavalli): Stop the current MediaStreamTrack. If not already\n        // stopped, this should fire a \"stopped\" event.\n\n        this._stop(); // NOTE(csantos): If there's an unprocessedTrack, this means RTCRtpSender has\n        // the processedTrack already set, we don't want to replace that.\n\n\n        return (this._unprocessedTrack ? Promise.resolve().then(function () {\n          _this._unprocessedTrack = mediaStreamTrack;\n        }) : this._trackSender.setMediaStreamTrack(mediaStreamTrack).catch(function (error) {\n          _this._log.warn('setMediaStreamTrack failed:', {\n            error: error,\n            mediaStreamTrack: mediaStreamTrack\n          });\n        })).then(function () {\n          _this._initialize();\n\n          _this._getAllAttachedElements().forEach(function (el) {\n            return _this._attach(el);\n          });\n        });\n      };\n      /**\n       * @private\n       */\n\n\n      LocalMediaTrack.prototype._stop = function () {\n        this.mediaStreamTrack.stop();\n\n        this._end();\n\n        return this;\n      };\n\n      LocalMediaTrack.prototype.enable = function (enabled) {\n        enabled = typeof enabled === 'boolean' ? enabled : true;\n\n        if (enabled !== this.mediaStreamTrack.enabled) {\n          this._log.info((enabled ? 'En' : 'Dis') + \"abling\");\n\n          this.mediaStreamTrack.enabled = enabled;\n          this.emit(enabled ? 'enabled' : 'disabled', this);\n        }\n\n        return this;\n      };\n\n      LocalMediaTrack.prototype.disable = function () {\n        return this.enable(false);\n      };\n\n      LocalMediaTrack.prototype.restart = function (constraints) {\n        var _this = this;\n\n        var kind = this.kind;\n\n        if (!this._isCreatedByCreateLocalTracks) {\n          return Promise.reject(ILLEGAL_INVOKE('restart', 'can only be called on a' + (\" Local\" + capitalize(kind) + \"Track that is created using createLocalTracks\") + (\" or createLocal\" + capitalize(kind) + \"Track.\")));\n        }\n\n        if (this._workaroundWebKitBug1208516Cleanup) {\n          this._workaroundWebKitBug1208516Cleanup();\n\n          this._workaroundWebKitBug1208516Cleanup = null;\n        }\n\n        var promise = this._restart(constraints);\n\n        if (this._workaroundWebKitBug1208516) {\n          promise = promise.finally(function () {\n            _this._workaroundWebKitBug1208516Cleanup = restartWhenInadvertentlyStopped(_this);\n          });\n        }\n\n        return promise;\n      };\n\n      LocalMediaTrack.prototype.stop = function () {\n        this._log.info('Stopping');\n\n        if (this._workaroundWebKitBug1208516Cleanup) {\n          this._workaroundWebKitBug1208516Cleanup();\n\n          this._workaroundWebKitBug1208516Cleanup = null;\n        }\n\n        return this._stop();\n      };\n\n      return LocalMediaTrack;\n    }(AudioOrVideoTrack)\n  );\n}\n/**\n * Restart the given {@link LocalMediaTrack} if it has been inadvertently stopped.\n * @private\n * @param {LocalAudioTrack|LocalVideoTrack} localMediaTrack\n * @returns {function} Clean up listeners attached by the workaround\n */\n\n\nfunction restartWhenInadvertentlyStopped(localMediaTrack) {\n  var log = localMediaTrack._log,\n      kind = localMediaTrack.kind;\n  var detectSilence = {\n    audio: detectSilentAudio,\n    video: detectSilentVideo\n  }[kind];\n  var el = localMediaTrack._dummyEl,\n      mediaStreamTrack = localMediaTrack.mediaStreamTrack;\n  var trackChangeInProgress = null;\n\n  function checkSilence() {\n    // The dummy element is paused, so play it and then detect silence.\n    return el.play().then(function () {\n      return detectSilence(el);\n    }).then(function (isSilent) {\n      if (isSilent) {\n        log.warn('Silence detected');\n      } else {\n        log.info('Non-silence detected');\n      }\n\n      return isSilent;\n    }).catch(function (error) {\n      log.warn('Failed to detect silence:', error);\n    }).finally(function () {\n      // Pause the dummy element again.\n      el.pause();\n    });\n  }\n\n  function shouldReacquireTrack() {\n    var _workaroundWebKitBug1208516Cleanup = localMediaTrack._workaroundWebKitBug1208516Cleanup,\n        isStopped = localMediaTrack.isStopped,\n        muted = localMediaTrack.mediaStreamTrack.muted;\n    var isInadvertentlyStopped = isStopped && !!_workaroundWebKitBug1208516Cleanup; // NOTE(mmalavalli): Restart the LocalMediaTrack if:\n    // 1. The app is foregrounded, and\n    // 2. A restart is not already in progress, and\n    // 3. The LocalMediaTrack is either muted, inadvertently stopped or silent\n\n    return Promise.resolve().then(function () {\n      return document.visibilityState === 'visible' && !trackChangeInProgress && (muted || isInadvertentlyStopped || checkSilence());\n    });\n  }\n\n  function maybeRestart() {\n    return Promise.race([waitForEvent(mediaStreamTrack, 'unmute'), waitForSometime(50)]).then(function () {\n      return shouldReacquireTrack();\n    }).then(function (shouldReacquire) {\n      if (shouldReacquire && !trackChangeInProgress) {\n        trackChangeInProgress = defer();\n\n        localMediaTrack._restart().finally(function () {\n          el = localMediaTrack._dummyEl;\n          removeMediaStreamTrackListeners();\n          mediaStreamTrack = localMediaTrack.mediaStreamTrack;\n          addMediaStreamTrackListeners();\n          trackChangeInProgress.resolve();\n          trackChangeInProgress = null;\n        }).catch(function (error) {\n          log.error('failed to restart track: ', error);\n        });\n      } // NOTE(mmalavalli): If the MediaStreamTrack ends before the DOM is visible,\n      // then this makes sure that visibility callback for phase 2 is called only\n      // after the MediaStreamTrack is re-acquired.\n\n\n      var promise = trackChangeInProgress && trackChangeInProgress.promise || Promise.resolve();\n      return promise.finally(function () {\n        return localMediaRestartDeferreds.resolveDeferred(kind);\n      });\n    }).catch(function (ex) {\n      log.error(\"error in maybeRestart: \" + ex.message);\n    });\n  }\n\n  function onMute() {\n    var log = localMediaTrack._log,\n        kind = localMediaTrack.kind;\n    log.info('Muted');\n    log.debug('LocalMediaTrack:', localMediaTrack); // NOTE(mmalavalli): When a LocalMediaTrack is muted without the app being\n    // backgrounded, and the inadvertently paused elements are played before it\n    // is restarted, it never gets unmuted due to the WebKit Bug 213853. Hence,\n    // setting this Deferred will make sure that the inadvertently paused elements\n    // are played only after the LocalMediaTrack is unmuted.\n    //\n    // Bug: https://bugs.webkit.org/show_bug.cgi?id=213853\n    //\n\n    localMediaRestartDeferreds.startDeferred(kind);\n  }\n\n  function addMediaStreamTrackListeners() {\n    mediaStreamTrack.addEventListener('ended', maybeRestart);\n    mediaStreamTrack.addEventListener('mute', onMute);\n    mediaStreamTrack.addEventListener('unmute', maybeRestart);\n  }\n\n  function removeMediaStreamTrackListeners() {\n    mediaStreamTrack.removeEventListener('ended', maybeRestart);\n    mediaStreamTrack.removeEventListener('mute', onMute);\n    mediaStreamTrack.removeEventListener('unmute', maybeRestart);\n  } // NOTE(mpatwardhan): listen for document visibility callback on phase 1.\n  // this ensures that we acquire media tracks before RemoteMediaTrack\n  // tries to `play` them (in phase 2). This order is important because\n  // play can fail on safari if audio is not being captured.\n\n\n  var onVisibilityChange = function onVisibilityChange(isVisible) {\n    return isVisible ? maybeRestart() : false;\n  };\n\n  documentVisibilityMonitor.onVisibilityChange(1, onVisibilityChange);\n  addMediaStreamTrackListeners();\n  return function () {\n    documentVisibilityMonitor.offVisibilityChange(1, onVisibilityChange);\n    removeMediaStreamTrackListeners();\n  };\n}\n\nmodule.exports = mixinLocalMediaTrack;","map":null,"metadata":{},"sourceType":"script"}