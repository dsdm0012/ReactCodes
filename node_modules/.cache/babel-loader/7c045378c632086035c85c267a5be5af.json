{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nvar guessBrowser = require('../../webrtc/util').guessBrowser;\n\nvar PeerConnectionV2 = require('./peerconnection');\n\nvar MediaTrackSender = require('../../media/track/sender');\n\nvar QueueingEventEmitter = require('../../queueingeventemitter');\n\nvar util = require('../../util');\n\nvar MediaConnectionError = require('../../util/twilio-video-errors').MediaConnectionError;\n\nvar isFirefox = guessBrowser() === 'firefox';\n/**\n * {@link PeerConnectionManager} manages multiple {@link PeerConnectionV2}s.\n * @extends QueueingEventEmitter\n * @emits PeerConnectionManager#candidates\n * @emits PeerConnectionManager#connectionStateChanged\n * @emits PeerConnectionManager#description\n * @emits PeerConnectionManager#iceConnectionStateChanged\n * @emits PeerConnectionManager#trackAdded\n */\n\nvar PeerConnectionManager =\n/** @class */\nfunction (_super) {\n  __extends(PeerConnectionManager, _super);\n  /**\n   * Construct {@link PeerConnectionManager}.\n   * @param {EncodingParametersImpl} encodingParameters\n   * @param {PreferredCodecs} preferredCodecs\n   * @param {object} options\n   */\n\n\n  function PeerConnectionManager(encodingParameters, preferredCodecs, options) {\n    var _this = _super.call(this) || this;\n\n    options = Object.assign({\n      audioContextFactory: isFirefox ? require('../../webaudio/audiocontext') : null,\n      PeerConnectionV2: PeerConnectionV2\n    }, options);\n    var audioContext = options.audioContextFactory ? options.audioContextFactory.getOrCreate(_this) : null; // NOTE(mroberts): If we're using an AudioContext, we don't need to specify\n    // `offerToReceiveAudio` in RTCOfferOptions.\n\n    var offerOptions = audioContext ? {\n      offerToReceiveVideo: true\n    } : {\n      offerToReceiveAudio: true,\n      offerToReceiveVideo: true\n    };\n    Object.defineProperties(_this, {\n      _audioContextFactory: {\n        value: options.audioContextFactory\n      },\n      _closedPeerConnectionIds: {\n        value: new Set()\n      },\n      _configuration: {\n        writable: true,\n        value: null\n      },\n      _configurationDeferred: {\n        writable: true,\n        value: util.defer()\n      },\n      _connectionState: {\n        value: 'new',\n        writable: true\n      },\n      _dummyAudioTrackSender: {\n        value: audioContext ? new MediaTrackSender(createDummyAudioMediaStreamTrack(audioContext)) : null\n      },\n      _encodingParameters: {\n        value: encodingParameters\n      },\n      _iceConnectionState: {\n        writable: true,\n        value: 'new'\n      },\n      _dataTrackSenders: {\n        writable: true,\n        value: new Set()\n      },\n      _lastConnectionState: {\n        value: 'new',\n        writable: true\n      },\n      _lastIceConnectionState: {\n        writable: true,\n        value: 'new'\n      },\n      _mediaTrackSenders: {\n        writable: true,\n        value: new Set()\n      },\n      _offerOptions: {\n        value: offerOptions\n      },\n      _peerConnections: {\n        value: new Map()\n      },\n      _preferredCodecs: {\n        value: preferredCodecs\n      },\n      _sessionTimeout: {\n        value: null,\n        writable: true\n      },\n      _PeerConnectionV2: {\n        value: options.PeerConnectionV2\n      }\n    });\n    return _this;\n  }\n\n  PeerConnectionManager.prototype.setEffectiveAdaptiveSimulcast = function (effectiveAdaptiveSimulcast) {\n    this._peerConnections.forEach(function (pc) {\n      return pc.setEffectiveAdaptiveSimulcast(effectiveAdaptiveSimulcast);\n    });\n\n    this._preferredCodecs.video.forEach(function (cs) {\n      if ('adaptiveSimulcast' in cs) {\n        cs.adaptiveSimulcast = effectiveAdaptiveSimulcast;\n      }\n    });\n  };\n\n  Object.defineProperty(PeerConnectionManager.prototype, \"connectionState\", {\n    /**\n     * A summarized RTCPeerConnectionState across all the\n     * {@link PeerConnectionManager}'s underlying {@link PeerConnectionV2}s.\n     * @property {RTCPeerConnectionState}\n     */\n    get: function () {\n      return this._connectionState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PeerConnectionManager.prototype, \"iceConnectionState\", {\n    /**\n     * A summarized RTCIceConnectionState across all the\n     * {@link PeerConnectionManager}'s underlying {@link PeerConnectionV2}s.\n     * @property {RTCIceConnectionState}\n     */\n    get: function () {\n      return this._iceConnectionState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Close the {@link PeerConnectionV2}s which are no longer relevant.\n   * @param {Array<object>} peerConnectionStates\n   * @returns {this}\n   */\n\n  PeerConnectionManager.prototype._closeAbsentPeerConnections = function (peerConnectionStates) {\n    var peerConnectionIds = new Set(peerConnectionStates.map(function (peerConnectionState) {\n      return peerConnectionState.id;\n    }));\n\n    this._peerConnections.forEach(function (peerConnection) {\n      if (!peerConnectionIds.has(peerConnection.id)) {\n        peerConnection._close();\n      }\n    });\n\n    return this;\n  };\n  /**\n   * Get the {@link PeerConnectionManager}'s configuration.\n   * @private\n   * @returns {Promise<object>}\n   */\n\n\n  PeerConnectionManager.prototype._getConfiguration = function () {\n    return this._configurationDeferred.promise;\n  };\n  /**\n   * Get or create a {@link PeerConnectionV2}.\n   * @private\n   * @param {string} id\n   * @param {object} [configuration]\n   * @returns {PeerConnectionV2}\n   */\n\n\n  PeerConnectionManager.prototype._getOrCreate = function (id, configuration) {\n    var _this = this;\n\n    var self = this;\n\n    var peerConnection = this._peerConnections.get(id);\n\n    if (!peerConnection) {\n      var PeerConnectionV2_1 = this._PeerConnectionV2;\n      var options = Object.assign({\n        dummyAudioMediaStreamTrack: this._dummyAudioTrackSender ? this._dummyAudioTrackSender.track : null,\n        offerOptions: this._offerOptions\n      }, this._sessionTimeout ? {\n        sessionTimeout: this._sessionTimeout\n      } : {}, configuration);\n\n      try {\n        peerConnection = new PeerConnectionV2_1(id, this._encodingParameters, this._preferredCodecs, options);\n      } catch (e) {\n        throw new MediaConnectionError();\n      }\n\n      this._peerConnections.set(peerConnection.id, peerConnection);\n\n      peerConnection.on('candidates', this.queue.bind(this, 'candidates'));\n      peerConnection.on('description', this.queue.bind(this, 'description'));\n      peerConnection.on('trackAdded', this.queue.bind(this, 'trackAdded'));\n      peerConnection.on('stateChanged', function stateChanged(state) {\n        if (state === 'closed') {\n          peerConnection.removeListener('stateChanged', stateChanged);\n\n          self._dataTrackSenders.forEach(function (sender) {\n            return peerConnection.removeDataTrackSender(sender);\n          });\n\n          self._mediaTrackSenders.forEach(function (sender) {\n            return peerConnection.removeMediaTrackSender(sender);\n          });\n\n          self._peerConnections.delete(peerConnection.id);\n\n          self._closedPeerConnectionIds.add(peerConnection.id);\n\n          updateConnectionState(self);\n          updateIceConnectionState(self);\n        }\n      });\n      peerConnection.on('connectionStateChanged', function () {\n        return updateConnectionState(_this);\n      });\n      peerConnection.on('iceConnectionStateChanged', function () {\n        return updateIceConnectionState(_this);\n      });\n\n      this._dataTrackSenders.forEach(peerConnection.addDataTrackSender, peerConnection);\n\n      this._mediaTrackSenders.forEach(peerConnection.addMediaTrackSender, peerConnection);\n\n      updateIceConnectionState(this);\n    }\n\n    return peerConnection;\n  };\n  /**\n   * Close all the {@link PeerConnectionV2}s in this {@link PeerConnectionManager}.\n   * @returns {this}\n   */\n\n\n  PeerConnectionManager.prototype.close = function () {\n    this._peerConnections.forEach(function (peerConnection) {\n      peerConnection.close();\n    });\n\n    if (this._dummyAudioTrackSender) {\n      this._dummyAudioTrackSender.stop();\n    }\n\n    if (this._audioContextFactory) {\n      this._audioContextFactory.release(this);\n    }\n\n    updateIceConnectionState(this);\n    return this;\n  };\n  /**\n   * Create a new {@link PeerConnectionV2} on this {@link PeerConnectionManager}.\n   * Then, create a new offer with the newly-created {@link PeerConnectionV2}.\n   * @return {Promise<this>}\n   */\n\n\n  PeerConnectionManager.prototype.createAndOffer = function () {\n    var _this = this;\n\n    return this._getConfiguration().then(function (configuration) {\n      var id;\n\n      do {\n        id = util.makeUUID();\n      } while (_this._peerConnections.has(id));\n\n      return _this._getOrCreate(id, configuration);\n    }).then(function (peerConnection) {\n      return peerConnection.offer();\n    }).then(function () {\n      return _this;\n    });\n  };\n  /**\n   * Get the {@link DataTrackReceiver}s and {@link MediaTrackReceiver}s of all\n   * the {@link PeerConnectionV2}s.\n   * @returns {Array<DataTrackReceiver|MediaTrackReceiver>} trackReceivers\n   */\n\n\n  PeerConnectionManager.prototype.getTrackReceivers = function () {\n    return util.flatMap(this._peerConnections, function (peerConnection) {\n      return peerConnection.getTrackReceivers();\n    });\n  };\n  /**\n   * Get the states of all {@link PeerConnectionV2}s.\n   * @returns {Array<object>}\n   */\n\n\n  PeerConnectionManager.prototype.getStates = function () {\n    var peerConnectionStates = [];\n\n    this._peerConnections.forEach(function (peerConnection) {\n      var peerConnectionState = peerConnection.getState();\n\n      if (peerConnectionState) {\n        peerConnectionStates.push(peerConnectionState);\n      }\n    });\n\n    return peerConnectionStates;\n  };\n  /**\n   * Set the {@link PeerConnectionManager}'s configuration.\n   * @param {object} configuration\n   * @returns {this}\n   */\n\n\n  PeerConnectionManager.prototype.setConfiguration = function (configuration) {\n    if (this._configuration) {\n      this._configurationDeferred = util.defer();\n\n      this._peerConnections.forEach(function (peerConnection) {\n        peerConnection.setConfiguration(configuration);\n      });\n    }\n\n    this._configuration = configuration;\n\n    this._configurationDeferred.resolve(configuration);\n\n    return this;\n  };\n  /**\n   * Set the ICE reconnect timeout period for all {@link PeerConnectionV2}s.\n   * @param {number} period - Period in milliseconds.\n   * @returns {this}\n   */\n\n\n  PeerConnectionManager.prototype.setIceReconnectTimeout = function (period) {\n    if (this._sessionTimeout === null) {\n      this._peerConnections.forEach(function (peerConnection) {\n        peerConnection.setIceReconnectTimeout(period);\n      });\n\n      this._sessionTimeout = period;\n    }\n\n    return this;\n  };\n  /**\n   * Set the {@link DataTrackSender}s and {@link MediaTrackSender}s on the\n   * {@link PeerConnectionManager}'s underlying {@link PeerConnectionV2}s.\n   * @param {Array<DataTrackSender|MediaTrackSender>} trackSenders\n   * @returns {this}\n   */\n\n\n  PeerConnectionManager.prototype.setTrackSenders = function (trackSenders) {\n    var dataTrackSenders = new Set(trackSenders.filter(function (trackSender) {\n      return trackSender.kind === 'data';\n    }));\n    var mediaTrackSenders = new Set(trackSenders.filter(function (trackSender) {\n      return trackSender && (trackSender.kind === 'audio' || trackSender.kind === 'video');\n    }));\n    var changes = getTrackSenderChanges(this, dataTrackSenders, mediaTrackSenders);\n    this._dataTrackSenders = dataTrackSenders;\n    this._mediaTrackSenders = mediaTrackSenders;\n    applyTrackSenderChanges(this, changes);\n    return this;\n  };\n  /**\n   * Update the {@link PeerConnectionManager}.\n   * @param {Array<object>} peerConnectionStates\n   * @param {boolean} [synced=false]\n   * @returns {Promise<this>}\n   */\n\n\n  PeerConnectionManager.prototype.update = function (peerConnectionStates, synced) {\n    var _this = this;\n\n    if (synced === void 0) {\n      synced = false;\n    }\n\n    if (synced) {\n      this._closeAbsentPeerConnections(peerConnectionStates);\n    }\n\n    return this._getConfiguration().then(function (configuration) {\n      return Promise.all(peerConnectionStates.map(function (peerConnectionState) {\n        if (_this._closedPeerConnectionIds.has(peerConnectionState.id)) {\n          return null;\n        }\n\n        var peerConnection = _this._getOrCreate(peerConnectionState.id, configuration);\n\n        return peerConnection.update(peerConnectionState);\n      }));\n    }).then(function () {\n      return _this;\n    });\n  };\n  /**\n   * Get the {@link PeerConnectionManager}'s media statistics.\n   * @returns {Promise.<Map<PeerConnectionV2#id, StandardizedStatsResponse>>}\n   */\n\n\n  PeerConnectionManager.prototype.getStats = function () {\n    var peerConnections = Array.from(this._peerConnections.values());\n    return Promise.all(peerConnections.map(function (peerConnection) {\n      return peerConnection.getStats().then(function (response) {\n        return [peerConnection.id, response];\n      });\n    })).then(function (responses) {\n      return new Map(responses);\n    });\n  };\n\n  return PeerConnectionManager;\n}(QueueingEventEmitter);\n/**\n * Create a dummy audio MediaStreamTrack with the given AudioContext.\n * @private\n * @param {AudioContext} audioContext\n * @return {MediaStreamTrack}\n */\n\n\nfunction createDummyAudioMediaStreamTrack(audioContext) {\n  var mediaStreamDestination = audioContext.createMediaStreamDestination();\n  return mediaStreamDestination.stream.getAudioTracks()[0];\n}\n/**\n * @event {PeerConnectionManager#candidates}\n * @param {object} candidates\n */\n\n/**\n * @event {PeerConnectionManager#connectionStateChanged}\n */\n\n/**\n * @event {PeerConnectionManager#description}\n * @param {object} description\n */\n\n/**\n * @event {PeerConnectionManager#iceConnectionStateChanged}\n */\n\n/**\n * @event {PeerConnectionManager#trackAdded}\n * @param {MediaStreamTrack|DataTrackReceiver} mediaStreamTrackOrDataTrackReceiver\n */\n\n/**\n * Apply {@link TrackSenderChanges}.\n * @param {PeerConnectionManager} peerConnectionManager\n * @param {TrackSenderChanges} changes\n * @returns {void}\n */\n\n\nfunction applyTrackSenderChanges(peerConnectionManager, changes) {\n  if (changes.data.add.size || changes.data.remove.size || changes.media.add.size || changes.media.remove.size) {\n    peerConnectionManager._peerConnections.forEach(function (peerConnection) {\n      changes.data.remove.forEach(peerConnection.removeDataTrackSender, peerConnection);\n      changes.media.remove.forEach(peerConnection.removeMediaTrackSender, peerConnection);\n      changes.data.add.forEach(peerConnection.addDataTrackSender, peerConnection);\n      changes.media.add.forEach(peerConnection.addMediaTrackSender, peerConnection);\n\n      if (changes.media.add.size || changes.media.remove.size || changes.data.add.size && !peerConnection.isApplicationSectionNegotiated) {\n        peerConnection.offer();\n      }\n    });\n  }\n}\n/**\n * @interface DataTrackSenderChanges\n * @property {Set<DataTrackSender>} add\n * @property {Set<DataTrackSender>} remove\n */\n\n/**\n * Get the {@Link DataTrackSender} changes.\n * @param {PeerConnectionManager} peerConnectionManager\n * @param {Array<DataTrackSender>} dataTrackSenders\n * @returns {DataTrackSenderChanges} changes\n */\n\n\nfunction getDataTrackSenderChanges(peerConnectionManager, dataTrackSenders) {\n  var dataTrackSendersToAdd = util.difference(dataTrackSenders, peerConnectionManager._dataTrackSenders);\n  var dataTrackSendersToRemove = util.difference(peerConnectionManager._dataTrackSenders, dataTrackSenders);\n  return {\n    add: dataTrackSendersToAdd,\n    remove: dataTrackSendersToRemove\n  };\n}\n/**\n * @interface TrackSenderChanges\n * @property {DataTrackSenderChanges} data\n * @property {MediaTrackSenderChanges} media\n */\n\n/**\n * Get {@link DataTrackSender} and {@link MediaTrackSender} changes.\n * @param {PeerConnectionManager} peerConnectionManager\n * @param {Array<DataTrackSender>} dataTrackSenders\n * @param {Array<MediaTrackSender>} mediaTrackSenders\n * @returns {TrackSenderChanges} changes\n */\n\n\nfunction getTrackSenderChanges(peerConnectionManager, dataTrackSenders, mediaTrackSenders) {\n  return {\n    data: getDataTrackSenderChanges(peerConnectionManager, dataTrackSenders),\n    media: getMediaTrackSenderChanges(peerConnectionManager, mediaTrackSenders)\n  };\n}\n/**\n * @interface MediaTrackSenderChanges\n * @property {Set<MediaTrackSender>} add\n * @property {Set<MediaTrackSender>} remove\n */\n\n/**\n * Get the {@link MediaTrackSender} changes.\n * @param {PeerConnectionManager} peerConnectionManager\n * @param {Array<MediaTrackSender>} mediaTrackSenders\n * @returns {MediaTrackSenderChanges} changes\n */\n\n\nfunction getMediaTrackSenderChanges(peerConnectionManager, mediaTrackSenders) {\n  var mediaTrackSendersToAdd = util.difference(mediaTrackSenders, peerConnectionManager._mediaTrackSenders);\n  var mediaTrackSendersToRemove = util.difference(peerConnectionManager._mediaTrackSenders, mediaTrackSenders);\n  return {\n    add: mediaTrackSendersToAdd,\n    remove: mediaTrackSendersToRemove\n  };\n}\n/**\n * This object maps RTCIceConnectionState and RTCPeerConnectionState values to a \"rank\".\n */\n\n\nvar toRank = {\n  new: 0,\n  checking: 1,\n  connecting: 2,\n  connected: 3,\n  completed: 4,\n  disconnected: -1,\n  failed: -2,\n  closed: -3\n};\n/**\n * This object maps \"rank\" back to RTCIceConnectionState or RTCPeerConnectionState values.\n */\n\nvar fromRank;\n/**\n * `Object.keys` is not supported in older browsers, so we can't just\n * synchronously call it in this module; we need to defer invoking it until we\n * know we're in a modern environment (i.e., anything that supports WebRTC).\n * @returns {object} fromRank\n */\n\nfunction createFromRank() {\n  return Object.keys(toRank).reduce(function (fromRank, state) {\n    var _a;\n\n    return Object.assign(fromRank, (_a = {}, _a[toRank[state]] = state, _a));\n  }, {});\n}\n/**\n * Summarize RTCIceConnectionStates or RTCPeerConnectionStates.\n * @param {Array<RTCIceConnectionState>|Array<RTCPeerConnectionState>} states\n * @returns {RTCIceConnectionState|RTCPeerConnectionState} summary\n */\n\n\nfunction summarizeIceOrPeerConnectionStates(states) {\n  if (!states.length) {\n    return 'new';\n  }\n\n  fromRank = fromRank || createFromRank();\n  return states.reduce(function (state1, state2) {\n    return fromRank[Math.max(toRank[state1], toRank[state2])];\n  });\n}\n/**\n * Update the {@link PeerConnectionManager}'s `iceConnectionState`, and emit an\n * \"iceConnectionStateChanged\" event, if necessary.\n * @param {PeerConnectionManager} pcm\n * @returns {void}\n */\n\n\nfunction updateIceConnectionState(pcm) {\n  pcm._lastIceConnectionState = pcm.iceConnectionState;\n  pcm._iceConnectionState = summarizeIceOrPeerConnectionStates(__spreadArray([], __read(pcm._peerConnections.values())).map(function (pcv2) {\n    return pcv2.iceConnectionState;\n  }));\n\n  if (pcm.iceConnectionState !== pcm._lastIceConnectionState) {\n    pcm.emit('iceConnectionStateChanged');\n  }\n}\n/**\n * Update the {@link PeerConnectionManager}'s `connectionState`, and emit a\n * \"connectionStateChanged\" event, if necessary.\n * @param {PeerConnectionManager} pcm\n * @returns {void}\n */\n\n\nfunction updateConnectionState(pcm) {\n  pcm._lastConnectionState = pcm.connectionState;\n  pcm._connectionState = summarizeIceOrPeerConnectionStates(__spreadArray([], __read(pcm._peerConnections.values())).map(function (pcv2) {\n    return pcv2.connectionState;\n  }));\n\n  if (pcm.connectionState !== pcm._lastConnectionState) {\n    pcm.emit('connectionStateChanged');\n  }\n}\n\nmodule.exports = PeerConnectionManager;","map":null,"metadata":{},"sourceType":"script"}