{"ast":null,"code":"/* globals RTCPeerConnection */\n'use strict';\n\nvar EventTarget = require('../util/eventtarget');\n\nvar FirefoxRTCSessionDescription = require('../rtcsessiondescription/firefox');\n\nvar inherits = require('../../vendor/inherits');\n\nvar updateTracksToSSRCs = require('../util/sdp').updateUnifiedPlanTrackIdsToSSRCs;\n\nvar util = require('../util'); // NOTE(mroberts): This is a short-lived workaround. Checking the user agent\n// string might not fix every affected Firefox instance, but it should be good\n// enough for this bug.\n\n\nvar needsWorkaroundForBug1480277 = typeof navigator === 'object' && navigator.userAgent && (navigator.userAgent.match(/Firefox\\/61/) || navigator.userAgent.match(/Firefox\\/62/)); // NOTE(mroberts): This class wraps Firefox's RTCPeerConnection implementation.\n// It provides some functionality not currently present in Firefox, namely the\n// abilities to\n//\n//   1. Call setLocalDescription and setRemoteDescription with new offers in\n//      signalingStates \"have-local-offer\" and \"have-remote-offer\",\n//      respectively.\n//\n//   2. The ability to call createOffer in signalingState \"have-local-offer\".\n//\n// Both of these are implemented using rollbacks to workaround the following\n// bug:\n//\n//   https://bugzilla.mozilla.org/show_bug.cgi?id=1072388\n//\n// We also provide a workaround for a bug where Firefox may change the\n// previously-negotiated DTLS role in an answer, which breaks Chrome:\n//\n//     https://bugzilla.mozilla.org/show_bug.cgi?id=1240897\n//\n\nfunction FirefoxRTCPeerConnection(configuration) {\n  if (!(this instanceof FirefoxRTCPeerConnection)) {\n    return new FirefoxRTCPeerConnection(configuration);\n  }\n\n  EventTarget.call(this);\n  util.interceptEvent(this, 'signalingstatechange');\n  /* eslint new-cap:0 */\n\n  var peerConnection = new RTCPeerConnection(configuration);\n  Object.defineProperties(this, {\n    _initiallyNegotiatedDtlsRole: {\n      value: null,\n      writable: true\n    },\n    _isClosed: {\n      value: false,\n      writable: true\n    },\n    _peerConnection: {\n      value: peerConnection\n    },\n    _rollingBack: {\n      value: false,\n      writable: true\n    },\n    _tracksToSSRCs: {\n      value: new Map()\n    },\n    iceGatheringState: {\n      enumerable: true,\n      get: function get() {\n        return this._isClosed ? 'complete' : this._peerConnection.iceGatheringState;\n      }\n    },\n    localDescription: {\n      enumerable: true,\n      get: function get() {\n        return overwriteWithInitiallyNegotiatedDtlsRole(this._peerConnection.localDescription, this._initiallyNegotiatedDtlsRole);\n      }\n    },\n    signalingState: {\n      enumerable: true,\n      get: function get() {\n        return this._isClosed ? 'closed' : this._peerConnection.signalingState;\n      }\n    }\n  });\n  var self = this;\n  var previousSignalingState;\n  peerConnection.addEventListener('signalingstatechange', function onsignalingstatechange() {\n    if (!self._rollingBack && self.signalingState !== previousSignalingState) {\n      previousSignalingState = self.signalingState; // NOTE(mmalavalli): In Firefox, 'signalingstatechange' event is\n      // triggered synchronously in the same tick after\n      // RTCPeerConnection#close() is called. So we mimic Chrome's behavior\n      // by triggering 'signalingstatechange' on the next tick.\n\n      var dispatchEventToSelf = self.dispatchEvent.apply.bind(self.dispatchEvent, self, arguments);\n\n      if (self._isClosed) {\n        setTimeout(dispatchEventToSelf);\n      } else {\n        dispatchEventToSelf();\n      }\n    }\n  });\n  util.proxyProperties(RTCPeerConnection.prototype, this, peerConnection);\n}\n\ninherits(FirefoxRTCPeerConnection, EventTarget); // NOTE(mmalavalli): Firefox throws a TypeError when the PeerConnection's\n// prototype's \"peerIdentity\" property is accessed. In order to overcome\n// this, we ignore this property while delegating methods.\n// Reference: https://bugzilla.mozilla.org/show_bug.cgi?id=1363815\n\nObject.defineProperty(FirefoxRTCPeerConnection.prototype, 'peerIdentity', {\n  enumerable: true,\n  value: Promise.resolve({\n    idp: '',\n    name: ''\n  })\n});\n\nif (needsWorkaroundForBug1480277) {\n  FirefoxRTCPeerConnection.prototype.addTrack = function addTrack() {\n    var track = arguments[0];\n\n    var sender = this._peerConnection.addTrack.apply(this._peerConnection, arguments);\n\n    sender.replaceTrack(track);\n    return sender;\n  };\n}\n\nFirefoxRTCPeerConnection.prototype.createAnswer = function createAnswer() {\n  var args = [].slice.call(arguments);\n  var promise;\n  var self = this;\n  promise = this._peerConnection.createAnswer().then(function createAnswerSucceeded(answer) {\n    saveInitiallyNegotiatedDtlsRole(self, answer);\n    return overwriteWithInitiallyNegotiatedDtlsRole(answer, self._initiallyNegotiatedDtlsRole);\n  });\n  return typeof args[0] === 'function' ? util.legacyPromise(promise, args[0], args[1]) : promise;\n}; // NOTE(mroberts): The WebRTC spec allows you to call createOffer from any\n// signalingState other than \"closed\"; however, Firefox has not yet implemented\n// this (https://bugzilla.mozilla.org/show_bug.cgi?id=1072388). We workaround\n// this by rolling back if we are in state \"have-local-offer\" or\n// \"have-remote-offer\". This is acceptable for our use case because we will\n// apply the newly-created offer almost immediately; however, this may be\n// unacceptable for other use cases.\n\n\nFirefoxRTCPeerConnection.prototype.createOffer = function createOffer() {\n  var args = [].slice.call(arguments);\n  var options = (args.length > 1 ? args[2] : args[0]) || {};\n  var promise;\n  var self = this;\n\n  if (this.signalingState === 'have-local-offer' || this.signalingState === 'have-remote-offer') {\n    var local = this.signalingState === 'have-local-offer';\n    promise = rollback(this, local, function rollbackSucceeded() {\n      return self.createOffer(options);\n    });\n  } else {\n    promise = self._peerConnection.createOffer(options);\n  }\n\n  promise = promise.then(function (offer) {\n    return new FirefoxRTCSessionDescription({\n      type: offer.type,\n      sdp: updateTracksToSSRCs(self._tracksToSSRCs, offer.sdp)\n    });\n  });\n  return args.length > 1 ? util.legacyPromise(promise, args[0], args[1]) : promise;\n}; // NOTE(mroberts): While Firefox will reject the Promise returned by\n// setLocalDescription when called from signalingState \"have-local-offer\" with\n// an answer, it still updates the .localDescription property. We workaround\n// this by explicitly handling this case.\n\n\nFirefoxRTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n  var args = [].slice.call(arguments);\n  var description = args[0];\n  var promise;\n\n  if (description && description.type === 'answer' && this.signalingState === 'have-local-offer') {\n    promise = Promise.reject(new Error('Cannot set local answer in state have-local-offer'));\n  }\n\n  if (promise) {\n    return args.length > 1 ? util.legacyPromise(promise, args[1], args[2]) : promise;\n  }\n\n  return this._peerConnection.setLocalDescription.apply(this._peerConnection, args);\n}; // NOTE(mroberts): The WebRTC spec allows you to call setRemoteDescription with\n// an offer multiple times in signalingState \"have-remote-offer\"; however,\n// Firefox has not yet implemented this (https://bugzilla.mozilla.org/show_bug.cgi?id=1072388).\n// We workaround this by rolling back if we are in state \"have-remote-offer\".\n// This is acceptable for our use case; however, this may be unacceptable for\n// other use cases.\n//\n// While Firefox will reject the Promise returned by setRemoteDescription when\n// called from signalingState \"have-remote-offer\" with an answer, it sill\n// updates the .remoteDescription property. We workaround this by explicitly\n// handling this case.\n\n\nFirefoxRTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n  var args = [].slice.call(arguments);\n  var description = args[0];\n  var promise;\n  var self = this;\n\n  if (description && this.signalingState === 'have-remote-offer') {\n    if (description.type === 'answer') {\n      promise = Promise.reject(new Error('Cannot set remote answer in state have-remote-offer'));\n    } else if (description.type === 'offer') {\n      promise = rollback(this, false, function rollbackSucceeded() {\n        return self._peerConnection.setRemoteDescription(description);\n      });\n    }\n  }\n\n  if (!promise) {\n    promise = this._peerConnection.setRemoteDescription(description);\n  }\n\n  promise = promise.then(function setRemoteDescriptionSucceeded() {\n    saveInitiallyNegotiatedDtlsRole(self, description, true);\n  });\n  return args.length > 1 ? util.legacyPromise(promise, args[1], args[2]) : promise;\n}; // NOTE(mroberts): The WebRTC spec specifies that the PeerConnection's internal\n// isClosed slot should immediately be set to true; however, in Firefox it\n// occurs in the next tick. We workaround this by tracking isClosed manually.\n\n\nFirefoxRTCPeerConnection.prototype.close = function close() {\n  if (this.signalingState !== 'closed') {\n    this._isClosed = true;\n\n    this._peerConnection.close();\n  }\n};\n\nutil.delegateMethods(RTCPeerConnection.prototype, FirefoxRTCPeerConnection.prototype, '_peerConnection');\n\nfunction rollback(peerConnection, local, onceRolledBack) {\n  var setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';\n  peerConnection._rollingBack = true;\n  return peerConnection._peerConnection[setLocalDescription](new FirefoxRTCSessionDescription({\n    type: 'rollback'\n  })).then(onceRolledBack).then(function onceRolledBackSucceeded(result) {\n    peerConnection._rollingBack = false;\n    return result;\n  }, function rollbackOrOnceRolledBackFailed(error) {\n    peerConnection._rollingBack = false;\n    throw error;\n  });\n}\n/**\n * Extract the initially negotiated DTLS role out of an RTCSessionDescription's\n * sdp property and save it on the FirefoxRTCPeerConnection if and only if\n *\n *   1. A DTLS role was not already saved on the FirefoxRTCPeerConnection, and\n *   2. The description is an answer.\n *\n * @private\n * @param {FirefoxRTCPeerConnection} peerConnection\n * @param {RTCSessionDescription} description\n * @param {boolean} [remote=false] - if true, save the inverse of the DTLS role,\n *   e.g. \"active\" instead of \"passive\" and vice versa\n * @returns {undefined}\n */\n\n\nfunction saveInitiallyNegotiatedDtlsRole(peerConnection, description, remote) {\n  // NOTE(mroberts): JSEP specifies that offers always offer \"actpass\" as the\n  // DTLS role. We need to inspect answers to figure out the negotiated DTLS\n  // role.\n  if (peerConnection._initiallyNegotiatedDtlsRole || description.type === 'offer') {\n    return;\n  }\n\n  var match = description.sdp.match(/a=setup:([a-z]+)/);\n\n  if (!match) {\n    return;\n  }\n\n  var dtlsRole = match[1];\n  peerConnection._initiallyNegotiatedDtlsRole = remote ? {\n    active: 'passive',\n    passive: 'active'\n  }[dtlsRole] : dtlsRole;\n}\n/**\n * Overwrite the DTLS role in the sdp property of an RTCSessionDescription if\n * and only if\n *\n *   1. The description is an answer, and\n *   2. A DTLS role is provided.\n *\n * @private\n * @param {RTCSessionDescription} [description]\n * @param {string} [dtlsRole] - one of \"active\" or \"passive\"\n * @returns {?RTCSessionDescription} description\n */\n\n\nfunction overwriteWithInitiallyNegotiatedDtlsRole(description, dtlsRole) {\n  if (description && description.type === 'answer' && dtlsRole) {\n    return new FirefoxRTCSessionDescription({\n      type: description.type,\n      sdp: description.sdp.replace(/a=setup:[a-z]+/g, 'a=setup:' + dtlsRole)\n    });\n  }\n\n  return description;\n}\n\nmodule.exports = FirefoxRTCPeerConnection;","map":{"version":3,"sources":["../../../lib/webrtc/rtcpeerconnection/firefox.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/* globals RTCPeerConnection */\n'use strict';\nvar EventTarget = require('../util/eventtarget');\nvar FirefoxRTCSessionDescription = require('../rtcsessiondescription/firefox');\nvar inherits = require('../../vendor/inherits');\nvar updateTracksToSSRCs = require('../util/sdp').updateUnifiedPlanTrackIdsToSSRCs;\nvar util = require('../util');\n// NOTE(mroberts): This is a short-lived workaround. Checking the user agent\n// string might not fix every affected Firefox instance, but it should be good\n// enough for this bug.\nvar needsWorkaroundForBug1480277 = typeof navigator === 'object'\n    && navigator.userAgent\n    && (navigator.userAgent.match(/Firefox\\/61/) || navigator.userAgent.match(/Firefox\\/62/));\n// NOTE(mroberts): This class wraps Firefox's RTCPeerConnection implementation.\n// It provides some functionality not currently present in Firefox, namely the\n// abilities to\n//\n//   1. Call setLocalDescription and setRemoteDescription with new offers in\n//      signalingStates \"have-local-offer\" and \"have-remote-offer\",\n//      respectively.\n//\n//   2. The ability to call createOffer in signalingState \"have-local-offer\".\n//\n// Both of these are implemented using rollbacks to workaround the following\n// bug:\n//\n//   https://bugzilla.mozilla.org/show_bug.cgi?id=1072388\n//\n// We also provide a workaround for a bug where Firefox may change the\n// previously-negotiated DTLS role in an answer, which breaks Chrome:\n//\n//     https://bugzilla.mozilla.org/show_bug.cgi?id=1240897\n//\nfunction FirefoxRTCPeerConnection(configuration) {\n    if (!(this instanceof FirefoxRTCPeerConnection)) {\n        return new FirefoxRTCPeerConnection(configuration);\n    }\n    EventTarget.call(this);\n    util.interceptEvent(this, 'signalingstatechange');\n    /* eslint new-cap:0 */\n    var peerConnection = new RTCPeerConnection(configuration);\n    Object.defineProperties(this, {\n        _initiallyNegotiatedDtlsRole: {\n            value: null,\n            writable: true\n        },\n        _isClosed: {\n            value: false,\n            writable: true\n        },\n        _peerConnection: {\n            value: peerConnection\n        },\n        _rollingBack: {\n            value: false,\n            writable: true\n        },\n        _tracksToSSRCs: {\n            value: new Map()\n        },\n        iceGatheringState: {\n            enumerable: true,\n            get: function () {\n                return this._isClosed ? 'complete' : this._peerConnection.iceGatheringState;\n            }\n        },\n        localDescription: {\n            enumerable: true,\n            get: function () {\n                return overwriteWithInitiallyNegotiatedDtlsRole(this._peerConnection.localDescription, this._initiallyNegotiatedDtlsRole);\n            }\n        },\n        signalingState: {\n            enumerable: true,\n            get: function () {\n                return this._isClosed ? 'closed' : this._peerConnection.signalingState;\n            }\n        }\n    });\n    var self = this;\n    var previousSignalingState;\n    peerConnection.addEventListener('signalingstatechange', function onsignalingstatechange() {\n        if (!self._rollingBack && self.signalingState !== previousSignalingState) {\n            previousSignalingState = self.signalingState;\n            // NOTE(mmalavalli): In Firefox, 'signalingstatechange' event is\n            // triggered synchronously in the same tick after\n            // RTCPeerConnection#close() is called. So we mimic Chrome's behavior\n            // by triggering 'signalingstatechange' on the next tick.\n            var dispatchEventToSelf = self.dispatchEvent.apply.bind(self.dispatchEvent, self, arguments);\n            if (self._isClosed) {\n                setTimeout(dispatchEventToSelf);\n            }\n            else {\n                dispatchEventToSelf();\n            }\n        }\n    });\n    util.proxyProperties(RTCPeerConnection.prototype, this, peerConnection);\n}\ninherits(FirefoxRTCPeerConnection, EventTarget);\n// NOTE(mmalavalli): Firefox throws a TypeError when the PeerConnection's\n// prototype's \"peerIdentity\" property is accessed. In order to overcome\n// this, we ignore this property while delegating methods.\n// Reference: https://bugzilla.mozilla.org/show_bug.cgi?id=1363815\nObject.defineProperty(FirefoxRTCPeerConnection.prototype, 'peerIdentity', {\n    enumerable: true,\n    value: Promise.resolve({\n        idp: '',\n        name: ''\n    })\n});\nif (needsWorkaroundForBug1480277) {\n    FirefoxRTCPeerConnection.prototype.addTrack = function addTrack() {\n        var track = arguments[0];\n        var sender = this._peerConnection.addTrack.apply(this._peerConnection, arguments);\n        sender.replaceTrack(track);\n        return sender;\n    };\n}\nFirefoxRTCPeerConnection.prototype.createAnswer = function createAnswer() {\n    var args = [].slice.call(arguments);\n    var promise;\n    var self = this;\n    promise = this._peerConnection.createAnswer().then(function createAnswerSucceeded(answer) {\n        saveInitiallyNegotiatedDtlsRole(self, answer);\n        return overwriteWithInitiallyNegotiatedDtlsRole(answer, self._initiallyNegotiatedDtlsRole);\n    });\n    return typeof args[0] === 'function'\n        ? util.legacyPromise(promise, args[0], args[1])\n        : promise;\n};\n// NOTE(mroberts): The WebRTC spec allows you to call createOffer from any\n// signalingState other than \"closed\"; however, Firefox has not yet implemented\n// this (https://bugzilla.mozilla.org/show_bug.cgi?id=1072388). We workaround\n// this by rolling back if we are in state \"have-local-offer\" or\n// \"have-remote-offer\". This is acceptable for our use case because we will\n// apply the newly-created offer almost immediately; however, this may be\n// unacceptable for other use cases.\nFirefoxRTCPeerConnection.prototype.createOffer = function createOffer() {\n    var args = [].slice.call(arguments);\n    var options = (args.length > 1 ? args[2] : args[0]) || {};\n    var promise;\n    var self = this;\n    if (this.signalingState === 'have-local-offer' ||\n        this.signalingState === 'have-remote-offer') {\n        var local = this.signalingState === 'have-local-offer';\n        promise = rollback(this, local, function rollbackSucceeded() {\n            return self.createOffer(options);\n        });\n    }\n    else {\n        promise = self._peerConnection.createOffer(options);\n    }\n    promise = promise.then(function (offer) {\n        return new FirefoxRTCSessionDescription({\n            type: offer.type,\n            sdp: updateTracksToSSRCs(self._tracksToSSRCs, offer.sdp)\n        });\n    });\n    return args.length > 1\n        ? util.legacyPromise(promise, args[0], args[1])\n        : promise;\n};\n// NOTE(mroberts): While Firefox will reject the Promise returned by\n// setLocalDescription when called from signalingState \"have-local-offer\" with\n// an answer, it still updates the .localDescription property. We workaround\n// this by explicitly handling this case.\nFirefoxRTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n    var args = [].slice.call(arguments);\n    var description = args[0];\n    var promise;\n    if (description && description.type === 'answer' && this.signalingState === 'have-local-offer') {\n        promise = Promise.reject(new Error('Cannot set local answer in state have-local-offer'));\n    }\n    if (promise) {\n        return args.length > 1\n            ? util.legacyPromise(promise, args[1], args[2])\n            : promise;\n    }\n    return this._peerConnection.setLocalDescription.apply(this._peerConnection, args);\n};\n// NOTE(mroberts): The WebRTC spec allows you to call setRemoteDescription with\n// an offer multiple times in signalingState \"have-remote-offer\"; however,\n// Firefox has not yet implemented this (https://bugzilla.mozilla.org/show_bug.cgi?id=1072388).\n// We workaround this by rolling back if we are in state \"have-remote-offer\".\n// This is acceptable for our use case; however, this may be unacceptable for\n// other use cases.\n//\n// While Firefox will reject the Promise returned by setRemoteDescription when\n// called from signalingState \"have-remote-offer\" with an answer, it sill\n// updates the .remoteDescription property. We workaround this by explicitly\n// handling this case.\nFirefoxRTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n    var args = [].slice.call(arguments);\n    var description = args[0];\n    var promise;\n    var self = this;\n    if (description && this.signalingState === 'have-remote-offer') {\n        if (description.type === 'answer') {\n            promise = Promise.reject(new Error('Cannot set remote answer in state have-remote-offer'));\n        }\n        else if (description.type === 'offer') {\n            promise = rollback(this, false, function rollbackSucceeded() {\n                return self._peerConnection.setRemoteDescription(description);\n            });\n        }\n    }\n    if (!promise) {\n        promise = this._peerConnection.setRemoteDescription(description);\n    }\n    promise = promise.then(function setRemoteDescriptionSucceeded() {\n        saveInitiallyNegotiatedDtlsRole(self, description, true);\n    });\n    return args.length > 1\n        ? util.legacyPromise(promise, args[1], args[2])\n        : promise;\n};\n// NOTE(mroberts): The WebRTC spec specifies that the PeerConnection's internal\n// isClosed slot should immediately be set to true; however, in Firefox it\n// occurs in the next tick. We workaround this by tracking isClosed manually.\nFirefoxRTCPeerConnection.prototype.close = function close() {\n    if (this.signalingState !== 'closed') {\n        this._isClosed = true;\n        this._peerConnection.close();\n    }\n};\nutil.delegateMethods(RTCPeerConnection.prototype, FirefoxRTCPeerConnection.prototype, '_peerConnection');\nfunction rollback(peerConnection, local, onceRolledBack) {\n    var setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';\n    peerConnection._rollingBack = true;\n    return peerConnection._peerConnection[setLocalDescription](new FirefoxRTCSessionDescription({\n        type: 'rollback'\n    })).then(onceRolledBack).then(function onceRolledBackSucceeded(result) {\n        peerConnection._rollingBack = false;\n        return result;\n    }, function rollbackOrOnceRolledBackFailed(error) {\n        peerConnection._rollingBack = false;\n        throw error;\n    });\n}\n/**\n * Extract the initially negotiated DTLS role out of an RTCSessionDescription's\n * sdp property and save it on the FirefoxRTCPeerConnection if and only if\n *\n *   1. A DTLS role was not already saved on the FirefoxRTCPeerConnection, and\n *   2. The description is an answer.\n *\n * @private\n * @param {FirefoxRTCPeerConnection} peerConnection\n * @param {RTCSessionDescription} description\n * @param {boolean} [remote=false] - if true, save the inverse of the DTLS role,\n *   e.g. \"active\" instead of \"passive\" and vice versa\n * @returns {undefined}\n */\nfunction saveInitiallyNegotiatedDtlsRole(peerConnection, description, remote) {\n    // NOTE(mroberts): JSEP specifies that offers always offer \"actpass\" as the\n    // DTLS role. We need to inspect answers to figure out the negotiated DTLS\n    // role.\n    if (peerConnection._initiallyNegotiatedDtlsRole || description.type === 'offer') {\n        return;\n    }\n    var match = description.sdp.match(/a=setup:([a-z]+)/);\n    if (!match) {\n        return;\n    }\n    var dtlsRole = match[1];\n    peerConnection._initiallyNegotiatedDtlsRole = remote ? {\n        active: 'passive',\n        passive: 'active'\n    }[dtlsRole] : dtlsRole;\n}\n/**\n * Overwrite the DTLS role in the sdp property of an RTCSessionDescription if\n * and only if\n *\n *   1. The description is an answer, and\n *   2. A DTLS role is provided.\n *\n * @private\n * @param {RTCSessionDescription} [description]\n * @param {string} [dtlsRole] - one of \"active\" or \"passive\"\n * @returns {?RTCSessionDescription} description\n */\nfunction overwriteWithInitiallyNegotiatedDtlsRole(description, dtlsRole) {\n    if (description && description.type === 'answer' && dtlsRole) {\n        return new FirefoxRTCSessionDescription({\n            type: description.type,\n            sdp: description.sdp.replace(/a=setup:[a-z]+/g, 'a=setup:' + dtlsRole)\n        });\n    }\n    return description;\n}\nmodule.exports = FirefoxRTCPeerConnection;\n//# sourceMappingURL=firefox.js.map"]},"metadata":{},"sourceType":"script"}