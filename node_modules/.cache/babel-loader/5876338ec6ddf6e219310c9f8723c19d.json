{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nvar EventEmitter = require('./eventemitter');\n\nvar RemoteAudioTrack = require('./media/track/remoteaudiotrack');\n\nvar RemoteAudioTrackPublication = require('./media/track/remoteaudiotrackpublication');\n\nvar RemoteDataTrack = require('./media/track/remotedatatrack');\n\nvar RemoteDataTrackPublication = require('./media/track/remotedatatrackpublication');\n\nvar RemoteVideoTrack = require('./media/track/remotevideotrack');\n\nvar RemoteVideoTrackPublication = require('./media/track/remotevideotrackpublication');\n\nvar util = require('./util');\n\nvar nInstances = 0;\n/**\n * {@link NetworkQualityLevel} is a value from 0â€“5, inclusive, representing the\n * quality of a network connection.\n * @typedef {number} NetworkQualityLevel\n */\n\n/**\n * @extends EventEmitter\n * @property {Map<Track.SID, AudioTrackPublication>} audioTracks -\n *    The {@link Participant}'s {@link AudioTrackPublication}s\n * @property {Map<Track.SID, DataTrackPublication>} dataTracks -\n *    The {@link Participant}'s {@link DataTrackPublication}s.\n * @property {Participant.Identity} identity - The identity of the {@link Participant}\n * @property {?NetworkQualityLevel} networkQualityLevel - The\n *    {@link Participant}'s current {@link NetworkQualityLevel}, if any\n * @property {?NetworkQualityStats} networkQualityStats - The\n *    {@link Participant}'s current {@link NetworkQualityStats}, if any\n * @property {Participant.SID} sid - The {@link Participant}'s SID\n * @property {string} state - \"connected\", \"disconnected\" or \"reconnecting\"\n * @property {Map<Track.SID, TrackPublication>} tracks -\n *    The {@link Participant}'s {@link TrackPublication}s\n * @property {Map<Track.SID, VideoTrackPublication>} videoTracks -\n *    The {@link Participant}'s {@link VideoTrackPublication}s\n * @emits Participant#disconnected\n * @emits Participant#networkQualityLevelChanged\n * @emits Participant#reconnected\n * @emits Participant#reconnecting\n * @emits Participant#trackDimensionsChanged\n * @emits Participant#trackStarted\n */\n\nvar Participant =\n/** @class */\nfunction (_super) {\n  __extends(Participant, _super);\n  /**\n   * Construct a {@link Participant}.\n   * @param {ParticipantSignaling} signaling\n   * @param {object} [options]\n   */\n\n\n  function Participant(signaling, options) {\n    var _this = _super.call(this) || this;\n\n    options = Object.assign({\n      RemoteAudioTrack: RemoteAudioTrack,\n      RemoteAudioTrackPublication: RemoteAudioTrackPublication,\n      RemoteDataTrack: RemoteDataTrack,\n      RemoteDataTrackPublication: RemoteDataTrackPublication,\n      RemoteVideoTrack: RemoteVideoTrack,\n      RemoteVideoTrackPublication: RemoteVideoTrackPublication,\n      tracks: []\n    }, options);\n    var indexed = indexTracksById(options.tracks);\n    var log = options.log.createLog('default', _this);\n    var audioTracks = new Map(indexed.audioTracks);\n    var dataTracks = new Map(indexed.dataTracks);\n    var tracks = new Map(indexed.tracks);\n    var videoTracks = new Map(indexed.videoTracks);\n    Object.defineProperties(_this, {\n      _RemoteAudioTrack: {\n        value: options.RemoteAudioTrack\n      },\n      _RemoteAudioTrackPublication: {\n        value: options.RemoteAudioTrackPublication\n      },\n      _RemoteDataTrack: {\n        value: options.RemoteDataTrack\n      },\n      _RemoteDataTrackPublication: {\n        value: options.RemoteDataTrackPublication\n      },\n      _RemoteVideoTrack: {\n        value: options.RemoteVideoTrack\n      },\n      _RemoteVideoTrackPublication: {\n        value: options.RemoteVideoTrackPublication\n      },\n      _audioTracks: {\n        value: audioTracks\n      },\n      _dataTracks: {\n        value: dataTracks\n      },\n      _instanceId: {\n        value: ++nInstances\n      },\n      _clientTrackSwitchOffControl: {\n        value: options.clientTrackSwitchOffControl\n      },\n      _contentPreferencesMode: {\n        value: options.contentPreferencesMode\n      },\n      _log: {\n        value: log\n      },\n      _signaling: {\n        value: signaling\n      },\n      _tracks: {\n        value: tracks\n      },\n      _trackEventReemitters: {\n        value: new Map()\n      },\n      _trackPublicationEventReemitters: {\n        value: new Map()\n      },\n      _trackSignalingUpdatedEventCallbacks: {\n        value: new Map()\n      },\n      _videoTracks: {\n        value: videoTracks\n      },\n      audioTracks: {\n        enumerable: true,\n        value: new Map()\n      },\n      dataTracks: {\n        enumerable: true,\n        value: new Map()\n      },\n      identity: {\n        enumerable: true,\n        get: function () {\n          return signaling.identity;\n        }\n      },\n      networkQualityLevel: {\n        enumerable: true,\n        get: function () {\n          return signaling.networkQualityLevel;\n        }\n      },\n      networkQualityStats: {\n        enumerable: true,\n        get: function () {\n          return signaling.networkQualityStats;\n        }\n      },\n      sid: {\n        enumerable: true,\n        get: function () {\n          return signaling.sid;\n        }\n      },\n      state: {\n        enumerable: true,\n        get: function () {\n          return signaling.state;\n        }\n      },\n      tracks: {\n        enumerable: true,\n        value: new Map()\n      },\n      videoTracks: {\n        enumerable: true,\n        value: new Map()\n      }\n    });\n\n    _this._tracks.forEach(reemitTrackEvents.bind(null, _this));\n\n    signaling.on('networkQualityLevelChanged', function () {\n      return _this.emit('networkQualityLevelChanged', _this.networkQualityLevel, _this.networkQualityStats && (_this.networkQualityStats.audio || _this.networkQualityStats.video) ? _this.networkQualityStats : null);\n    });\n    reemitSignalingStateChangedEvents(_this, signaling);\n    log.info(\"Created a new Participant\" + (_this.identity ? \": \" + _this.identity : ''));\n    return _this;\n  }\n  /**\n   * Get the {@link RemoteTrack} events to re-emit.\n   * @private\n   * @returns {Array<Array<string>>} events\n   */\n\n\n  Participant.prototype._getTrackEvents = function () {\n    return [['dimensionsChanged', 'trackDimensionsChanged'], ['message', 'trackMessage'], ['started', 'trackStarted']];\n  };\n  /**\n   * @private\n   */\n\n\n  Participant.prototype._getTrackPublicationEvents = function () {\n    return [];\n  };\n\n  Participant.prototype.toString = function () {\n    return \"[Participant #\" + this._instanceId + \": \" + this.sid + \"]\";\n  };\n  /**\n   * @private\n   * @param {RemoteTrack} track\n   * @param {Track.ID} id\n   * @returns {?RemoteTrack}\n   */\n\n\n  Participant.prototype._addTrack = function (track, id) {\n    var log = this._log;\n\n    if (this._tracks.has(id)) {\n      return null;\n    }\n\n    this._tracks.set(id, track);\n\n    var tracksByKind = {\n      audio: this._audioTracks,\n      video: this._videoTracks,\n      data: this._dataTracks\n    }[track.kind];\n    tracksByKind.set(id, track);\n    reemitTrackEvents(this, track, id);\n    log.info(\"Added a new \" + util.trackClass(track) + \":\", id);\n    log.debug(util.trackClass(track) + \":\", track);\n    return track;\n  };\n  /**\n   * @private\n   * @param {RemoteTrackPublication} publication\n   * @returns {?RemoteTrackPublication}\n   */\n\n\n  Participant.prototype._addTrackPublication = function (publication) {\n    var log = this._log;\n\n    if (this.tracks.has(publication.trackSid)) {\n      return null;\n    }\n\n    this.tracks.set(publication.trackSid, publication);\n    var trackPublicationsByKind = {\n      audio: this.audioTracks,\n      data: this.dataTracks,\n      video: this.videoTracks\n    }[publication.kind];\n    trackPublicationsByKind.set(publication.trackSid, publication);\n    reemitTrackPublicationEvents(this, publication);\n    log.info(\"Added a new \" + util.trackPublicationClass(publication) + \":\", publication.trackSid);\n    log.debug(util.trackPublicationClass(publication) + \":\", publication);\n    return publication;\n  };\n  /**\n   * @private\n   */\n\n\n  Participant.prototype._handleTrackSignalingEvents = function () {\n    var _a = this,\n        log = _a._log,\n        clientTrackSwitchOffControl = _a._clientTrackSwitchOffControl,\n        contentPreferencesMode = _a._contentPreferencesMode;\n\n    var self = this;\n\n    if (this.state === 'disconnected') {\n      return;\n    }\n\n    var RemoteAudioTrack = this._RemoteAudioTrack;\n    var RemoteAudioTrackPublication = this._RemoteAudioTrackPublication;\n    var RemoteVideoTrack = this._RemoteVideoTrack;\n    var RemoteVideoTrackPublication = this._RemoteVideoTrackPublication;\n    var RemoteDataTrack = this._RemoteDataTrack;\n    var RemoteDataTrackPublication = this._RemoteDataTrackPublication;\n    var participantSignaling = this._signaling;\n\n    function trackSignalingAdded(signaling) {\n      var RemoteTrackPublication = {\n        audio: RemoteAudioTrackPublication,\n        data: RemoteDataTrackPublication,\n        video: RemoteVideoTrackPublication\n      }[signaling.kind];\n      var publication = new RemoteTrackPublication(signaling, {\n        log: log\n      });\n\n      self._addTrackPublication(publication);\n\n      var isSubscribed = signaling.isSubscribed;\n\n      if (isSubscribed) {\n        trackSignalingSubscribed(signaling);\n      }\n\n      self._trackSignalingUpdatedEventCallbacks.set(signaling.sid, function () {\n        if (isSubscribed !== signaling.isSubscribed) {\n          isSubscribed = signaling.isSubscribed;\n\n          if (isSubscribed) {\n            trackSignalingSubscribed(signaling);\n            return;\n          }\n\n          trackSignalingUnsubscribed(signaling);\n        }\n      });\n\n      signaling.on('updated', self._trackSignalingUpdatedEventCallbacks.get(signaling.sid));\n    }\n\n    function trackSignalingRemoved(signaling) {\n      if (signaling.isSubscribed) {\n        signaling.setTrackTransceiver(null);\n      }\n\n      var updated = self._trackSignalingUpdatedEventCallbacks.get(signaling.sid);\n\n      if (updated) {\n        signaling.removeListener('updated', updated);\n\n        self._trackSignalingUpdatedEventCallbacks.delete(signaling.sid);\n      }\n\n      var publication = self.tracks.get(signaling.sid);\n\n      if (publication) {\n        self._removeTrackPublication(publication);\n      }\n    }\n\n    function trackSignalingSubscribed(signaling) {\n      var isEnabled = signaling.isEnabled,\n          name = signaling.name,\n          kind = signaling.kind,\n          sid = signaling.sid,\n          trackTransceiver = signaling.trackTransceiver,\n          isSwitchedOff = signaling.isSwitchedOff;\n      var RemoteTrack = {\n        audio: RemoteAudioTrack,\n        video: RemoteVideoTrack,\n        data: RemoteDataTrack\n      }[kind];\n      var publication = self.tracks.get(sid); // NOTE(mroberts): It should never be the case that the TrackSignaling and\n      // MediaStreamTrack or DataTrackReceiver kinds disagree; however, just in\n      // case, we handle it here.\n\n      if (!RemoteTrack || kind !== trackTransceiver.kind) {\n        return;\n      }\n\n      var options = {\n        log: log,\n        name: name,\n        clientTrackSwitchOffControl: clientTrackSwitchOffControl,\n        contentPreferencesMode: contentPreferencesMode\n      };\n\n      var setPriority = function (newPriority) {\n        return participantSignaling.updateSubscriberTrackPriority(sid, newPriority);\n      };\n\n      var setRenderHint = function (renderHint) {\n        if (signaling.isSubscribed) {\n          participantSignaling.updateTrackRenderHint(sid, renderHint);\n        }\n      };\n\n      var track = kind === 'data' ? new RemoteTrack(sid, trackTransceiver, options) : new RemoteTrack(sid, trackTransceiver, isEnabled, isSwitchedOff, setPriority, setRenderHint, options);\n\n      self._addTrack(track, publication, trackTransceiver.id);\n    }\n\n    function trackSignalingUnsubscribed(signaling) {\n      var _a = __read(Array.from(self._tracks.entries()).find(function (_a) {\n        var _b = __read(_a, 2),\n            track = _b[1];\n\n        return track.sid === signaling.sid;\n      }), 2),\n          id = _a[0],\n          track = _a[1];\n\n      var publication = self.tracks.get(signaling.sid);\n\n      if (track) {\n        self._removeTrack(track, publication, id);\n      }\n    }\n\n    participantSignaling.on('trackAdded', trackSignalingAdded);\n    participantSignaling.on('trackRemoved', trackSignalingRemoved);\n    participantSignaling.tracks.forEach(trackSignalingAdded);\n    participantSignaling.on('stateChanged', function stateChanged(state) {\n      if (state === 'disconnected') {\n        log.debug('Removing event listeners');\n        participantSignaling.removeListener('stateChanged', stateChanged);\n        participantSignaling.removeListener('trackAdded', trackSignalingAdded);\n        participantSignaling.removeListener('trackRemoved', trackSignalingRemoved);\n      } else if (state === 'connected') {\n        // NOTE(mmalavalli): Any transition to \"connected\" here is a result of\n        // successful signaling reconnection, and not a first-time establishment\n        // of the signaling connection.\n        log.info('reconnected'); // NOTE(mpatwardhan): `stateChanged` can get emitted with StateMachine locked.\n        // Do not signal  public events synchronously with lock held.\n\n        setTimeout(function () {\n          return self.emit('reconnected');\n        }, 0);\n      }\n    });\n  };\n  /**\n   * @private\n   * @param {RemoteTrack} track\n   * @param {Track.ID} id\n   * @returns {?RemoteTrack}\n   */\n\n\n  Participant.prototype._removeTrack = function (track, id) {\n    if (!this._tracks.has(id)) {\n      return null;\n    }\n\n    this._tracks.delete(id);\n\n    var tracksByKind = {\n      audio: this._audioTracks,\n      video: this._videoTracks,\n      data: this._dataTracks\n    }[track.kind];\n    tracksByKind.delete(id);\n    var reemitters = this._trackEventReemitters.get(id) || new Map();\n    reemitters.forEach(function (reemitter, event) {\n      track.removeListener(event, reemitter);\n    });\n    var log = this._log;\n    log.info(\"Removed a \" + util.trackClass(track) + \":\", id);\n    log.debug(util.trackClass(track) + \":\", track);\n    return track;\n  };\n  /**\n   * @private\n   * @param {RemoteTrackPublication} publication\n   * @returns {?RemoteTrackPublication}\n   */\n\n\n  Participant.prototype._removeTrackPublication = function (publication) {\n    publication = this.tracks.get(publication.trackSid);\n\n    if (!publication) {\n      return null;\n    }\n\n    this.tracks.delete(publication.trackSid);\n    var trackPublicationsByKind = {\n      audio: this.audioTracks,\n      data: this.dataTracks,\n      video: this.videoTracks\n    }[publication.kind];\n    trackPublicationsByKind.delete(publication.trackSid);\n    var reemitters = this._trackPublicationEventReemitters.get(publication.trackSid) || new Map();\n    reemitters.forEach(function (reemitter, event) {\n      publication.removeListener(event, reemitter);\n    });\n    var log = this._log;\n    log.info(\"Removed a \" + util.trackPublicationClass(publication) + \":\", publication.trackSid);\n    log.debug(util.trackPublicationClass(publication) + \":\", publication);\n    return publication;\n  };\n\n  Participant.prototype.toJSON = function () {\n    return util.valueToJSON(this);\n  };\n\n  return Participant;\n}(EventEmitter);\n/**\n * A {@link Participant.SID} is a 34-character string starting with \"PA\"\n * that uniquely identifies a {@link Participant}.\n * @type string\n * @typedef Participant.SID\n */\n\n/**\n * A {@link Participant.Identity} is a string that identifies a\n * {@link Participant}. You can think of it like a name.\n * @typedef {string} Participant.Identity\n */\n\n/**\n * The {@link Participant} has disconnected.\n * @param {Participant} participant - The {@link Participant} that disconnected.\n * @event Participant#disconnected\n */\n\n/**\n * The {@link Participant}'s {@link NetworkQualityLevel} changed.\n * @param {NetworkQualityLevel} networkQualityLevel - The new\n *   {@link NetworkQualityLevel}\n * @param {?NetworkQualityStats} networkQualityStats - The {@link NetworkQualityStats}\n *   based on which {@link NetworkQualityLevel} is calculated, if any\n * @event Participant#networkQualityLevelChanged\n */\n\n/**\n * The {@link Participant} has reconnected to the {@link Room} after a signaling connection disruption.\n * @event Participant#reconnected\n */\n\n/**\n * The {@link Participant} is reconnecting to the {@link Room} after a signaling connection disruption.\n * @event Participant#reconnecting\n */\n\n/**\n * One of the {@link Participant}'s {@link VideoTrack}'s dimensions changed.\n * @param {VideoTrack} track - The {@link VideoTrack} whose dimensions changed\n * @event Participant#trackDimensionsChanged\n */\n\n/**\n * One of the {@link Participant}'s {@link Track}s started.\n * @param {Track} track - The {@link Track} that started\n * @event Participant#trackStarted\n */\n\n/**\n * Indexed {@link Track}s by {@link Track.ID}.\n * @typedef {object} IndexedTracks\n * @property {Array<{0: Track.ID, 1: AudioTrack}>} audioTracks - Indexed\n *   {@link AudioTrack}s\n * @property {Array<{0: Track.ID, 1: DataTrack}>} dataTracks - Indexed\n *   {@link DataTrack}s\n * @property {Array<{0: Track.ID, 1: Track}>} tracks - Indexed {@link Track}s\n * @property {Array<{0: Track.ID, 1: VideoTrack}>} videoTracks - Indexed\n *   {@link VideoTrack}s\n * @private\n */\n\n/**\n * Index tracks by {@link Track.ID}.\n * @param {Array<Track>} tracks\n * @returns {IndexedTracks}\n * @private\n */\n\n\nfunction indexTracksById(tracks) {\n  var indexedTracks = tracks.map(function (track) {\n    return [track.id, track];\n  });\n  var indexedAudioTracks = indexedTracks.filter(function (keyValue) {\n    return keyValue[1].kind === 'audio';\n  });\n  var indexedVideoTracks = indexedTracks.filter(function (keyValue) {\n    return keyValue[1].kind === 'video';\n  });\n  var indexedDataTracks = indexedTracks.filter(function (keyValue) {\n    return keyValue[1].kind === 'data';\n  });\n  return {\n    audioTracks: indexedAudioTracks,\n    dataTracks: indexedDataTracks,\n    tracks: indexedTracks,\n    videoTracks: indexedVideoTracks\n  };\n}\n/**\n * Re-emit {@link ParticipantSignaling} 'stateChanged' events.\n * @param {Participant} participant\n * @param {ParticipantSignaling} signaling\n * @private\n */\n\n\nfunction reemitSignalingStateChangedEvents(participant, signaling) {\n  var log = participant._log;\n\n  if (participant.state === 'disconnected') {\n    return;\n  } // Reemit state transition events from the ParticipantSignaling.\n\n\n  signaling.on('stateChanged', function stateChanged(state) {\n    log.debug('Transitioned to state:', state);\n    participant.emit(state, participant);\n\n    if (state === 'disconnected') {\n      log.debug('Removing Track event reemitters');\n      signaling.removeListener('stateChanged', stateChanged);\n\n      participant._tracks.forEach(function (track) {\n        var reemitters = participant._trackEventReemitters.get(track.id);\n\n        if (track && reemitters) {\n          reemitters.forEach(function (reemitter, event) {\n            track.removeListener(event, reemitter);\n          });\n        }\n      }); // eslint-disable-next-line no-warning-comments\n      // TODO(joma): Removing this introduced unit test failures in the RemoteParticipant.\n      // Investigate further before removing.\n\n\n      signaling.tracks.forEach(function (trackSignaling) {\n        var track = participant._tracks.get(trackSignaling.id);\n\n        var reemitters = participant._trackEventReemitters.get(trackSignaling.id);\n\n        if (track && reemitters) {\n          reemitters.forEach(function (reemitter, event) {\n            track.removeListener(event, reemitter);\n          });\n        }\n      });\n\n      participant._trackEventReemitters.clear();\n\n      participant.tracks.forEach(function (publication) {\n        participant._trackPublicationEventReemitters.get(publication.trackSid).forEach(function (reemitter, event) {\n          publication.removeListener(event, reemitter);\n        });\n      });\n\n      participant._trackPublicationEventReemitters.clear();\n    }\n  });\n}\n/**\n * Re-emit {@link Track} events.\n * @param {Participant} participant\n * @param {Track} track\n * @param {Track.ID} id\n * @private\n */\n\n\nfunction reemitTrackEvents(participant, track, id) {\n  var trackEventReemitters = new Map();\n\n  if (participant.state === 'disconnected') {\n    return;\n  }\n\n  participant._getTrackEvents().forEach(function (eventPair) {\n    var trackEvent = eventPair[0];\n    var participantEvent = eventPair[1];\n    trackEventReemitters.set(trackEvent, function () {\n      var args = [participantEvent].concat([].slice.call(arguments));\n      return participant.emit.apply(participant, __spreadArray([], __read(args)));\n    });\n    track.on(trackEvent, trackEventReemitters.get(trackEvent));\n  });\n\n  participant._trackEventReemitters.set(id, trackEventReemitters);\n}\n/**\n * Re-emit {@link TrackPublication} events.\n * @private\n * @param {Participant} participant\n * @param {TrackPublication} publication\n */\n\n\nfunction reemitTrackPublicationEvents(participant, publication) {\n  var publicationEventReemitters = new Map();\n\n  if (participant.state === 'disconnected') {\n    return;\n  }\n\n  participant._getTrackPublicationEvents().forEach(function (_a) {\n    var _b = __read(_a, 2),\n        publicationEvent = _b[0],\n        participantEvent = _b[1];\n\n    publicationEventReemitters.set(publicationEvent, function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      participant.emit.apply(participant, __spreadArray(__spreadArray([participantEvent], __read(args)), [publication]));\n    });\n    publication.on(publicationEvent, publicationEventReemitters.get(publicationEvent));\n  });\n\n  participant._trackPublicationEventReemitters.set(publication.trackSid, publicationEventReemitters);\n}\n\nmodule.exports = Participant;","map":null,"metadata":{},"sourceType":"script"}