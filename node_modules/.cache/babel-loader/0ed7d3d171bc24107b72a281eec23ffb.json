{"ast":null,"code":"'use strict';\n\nvar _a = require('../../util/constants'),\n    ICE_ACTIVITY_CHECK_PERIOD_MS = _a.ICE_ACTIVITY_CHECK_PERIOD_MS,\n    ICE_INACTIVITY_THRESHOLD_MS = _a.ICE_INACTIVITY_THRESHOLD_MS;\n/**\n * Monitors a {@link RTCPeerConnection}'s stats and notifies\n * caller when inactivity is detected.\n */\n\n\nvar IceConnectionMonitor =\n/** @class */\nfunction () {\n  /**\n   * Construct an {@link IceConnectionMonitor}.\n   * @param {RTCPeerConnection} peerConnection\n   * @param {object} [options]\n   */\n  function IceConnectionMonitor(peerConnection, options) {\n    options = Object.assign({\n      activityCheckPeriodMs: ICE_ACTIVITY_CHECK_PERIOD_MS,\n      inactivityThresholdMs: ICE_INACTIVITY_THRESHOLD_MS\n    }, options);\n    Object.defineProperties(this, {\n      _activityCheckPeriodMs: {\n        value: options.activityCheckPeriodMs\n      },\n      _inactivityThresholdMs: {\n        value: options.inactivityThresholdMs\n      },\n      _lastActivity: {\n        value: null,\n        writable: true\n      },\n      _peerConnection: {\n        value: peerConnection\n      },\n      _timer: {\n        value: null,\n        writable: true\n      },\n      _onIceConnectionStateChanged: {\n        value: null,\n        writable: true\n      }\n    });\n  }\n\n  IceConnectionMonitor.prototype._getActivePairStat = function (stats) {\n    var statsArray = Array.from(stats.values());\n    var activePairStats = statsArray.find(function (stat) {\n      return stat.type === 'candidate-pair' && stat.nominated;\n    }); // NOTE(mpatwardhan): sometimes (JSDK-2667) after getting disconnected while switching network\n    // we may not find active pair. Treat this as 0 bytesReceived so that we count it towards inactivity.\n\n    return activePairStats || {\n      bytesReceived: 0,\n      timestamp: Math.round(new Date().getTime())\n    };\n  };\n  /**\n   * Get ICE connection stats, and extract received and send bytes.\n   * @returns Promise<?RTCIceCandidatePairStats>\n   */\n\n\n  IceConnectionMonitor.prototype._getIceConnectionStats = function () {\n    var _this = this;\n\n    return this._peerConnection.getStats().then(function (stats) {\n      return _this._getActivePairStat(stats);\n    }).catch(function () {\n      return null;\n    });\n  };\n  /**\n   * schedules/un-schedules inactivity callback.\n   */\n\n\n  IceConnectionMonitor.prototype._scheduleInactivityCallback = function (callback) {\n    var _this = this;\n\n    if (callback && this._onIceConnectionStateChanged === null) {\n      // schedule callback\n      this._onIceConnectionStateChanged = function () {\n        if (_this._peerConnection.iceConnectionState === 'disconnected') {\n          // eslint-disable-next-line callback-return\n          callback();\n        }\n      };\n\n      this._peerConnection.addEventListener('iceconnectionstatechange', this._onIceConnectionStateChanged);\n    } else if (!callback && this._onIceConnectionStateChanged) {\n      // unschedule callback\n      this._peerConnection.removeEventListener('iceconnectionstatechange', this._onIceConnectionStateChanged);\n\n      this._onIceConnectionStateChanged = null;\n    }\n  };\n  /**\n   * Start monitoring the ICE connection.\n   * Monitors bytes received on active ice connection pair,\n   * invokes onIceConnectionInactive when inactivity is detected.\n   * @param {function} onIceConnectionInactive\n   */\n\n\n  IceConnectionMonitor.prototype.start = function (onIceConnectionInactive) {\n    var _this = this;\n\n    this.stop();\n    this._timer = setInterval(function () {\n      _this._getIceConnectionStats().then(function (iceStats) {\n        if (!iceStats) {\n          return;\n        } // NOTE(mpatwardhan): We look at bytesReceived on active candidate pair as an indication of active ice connection.\n        // As per spec (https://w3c.github.io/webrtc-stats/#dom-rtcicecandidatepairstats-bytesreceived) this value\n        // includes RTCP traffic and is +ve even when there are no tracks subscribed to.\n\n\n        if (!_this._lastActivity || _this._lastActivity.bytesReceived !== iceStats.bytesReceived) {\n          _this._lastActivity = iceStats; // detected activity, cancel scheduled callback if any.\n\n          _this._scheduleInactivityCallback(null);\n        }\n\n        if (iceStats.timestamp - _this._lastActivity.timestamp >= _this._inactivityThresholdMs) {\n          // detected inactivity.\n          if (_this._peerConnection.iceConnectionState === 'disconnected') {\n            onIceConnectionInactive();\n          } else if (_this._onIceConnectionStateChanged === null) {\n            _this._scheduleInactivityCallback(onIceConnectionInactive);\n          }\n        }\n      });\n    }, this._activityCheckPeriodMs);\n  };\n  /**\n   * Stop monitoring the ICE connection state.\n   * @returns {void}\n   */\n\n\n  IceConnectionMonitor.prototype.stop = function () {\n    this._scheduleInactivityCallback(null);\n\n    if (this._timer !== null) {\n      clearInterval(this._timer);\n      this._timer = null;\n      this._lastActivity = null;\n    }\n  };\n\n  return IceConnectionMonitor;\n}();\n\nmodule.exports = IceConnectionMonitor;","map":null,"metadata":{},"sourceType":"script"}