{"ast":null,"code":"'use strict';\n\nvar CancelablePromise = require('../../util/cancelablepromise');\n\nvar DefaultPeerConnectionManager = require('./peerconnectionmanager');\n\nvar DefaultRoomV2 = require('./room');\n\nvar DefaultTransport = require('./twilioconnectiontransport');\n\nvar _a = require('../../util/twilio-video-errors'),\n    SignalingConnectionDisconnectedError = _a.SignalingConnectionDisconnectedError,\n    SignalingIncomingMessageInvalidError = _a.SignalingIncomingMessageInvalidError;\n\nvar _b = require('../../util'),\n    flatMap = _b.flatMap,\n    createRoomConnectEventPayload = _b.createRoomConnectEventPayload;\n\nfunction createCancelableRoomSignalingPromise(token, wsServer, localParticipant, encodingParameters, preferredCodecs, options) {\n  options = Object.assign({\n    PeerConnectionManager: DefaultPeerConnectionManager,\n    RoomV2: DefaultRoomV2,\n    Transport: DefaultTransport\n  }, options);\n  var adaptiveSimulcast = preferredCodecs.video[0] && preferredCodecs.video[0].adaptiveSimulcast === true;\n  var PeerConnectionManager = options.PeerConnectionManager,\n      RoomV2 = options.RoomV2,\n      Transport = options.Transport,\n      iceServers = options.iceServers,\n      log = options.log;\n  var peerConnectionManager = new PeerConnectionManager(encodingParameters, preferredCodecs, options);\n  var trackSenders = flatMap(localParticipant.tracks, function (trackV2) {\n    return [trackV2.trackTransceiver];\n  });\n  peerConnectionManager.setTrackSenders(trackSenders);\n  var cancellationError = new Error('Canceled');\n  var transport;\n  var cancelablePromise = new CancelablePromise(function (resolve, reject, isCanceled) {\n    var onIced = function (iceServers) {\n      if (isCanceled()) {\n        reject(cancellationError);\n        return Promise.reject(cancellationError);\n      }\n\n      log.debug('Got ICE servers:', iceServers);\n      options.iceServers = iceServers;\n      peerConnectionManager.setConfiguration(options);\n      return peerConnectionManager.createAndOffer().then(function () {\n        if (isCanceled()) {\n          reject(cancellationError);\n          throw cancellationError;\n        }\n\n        log.debug('createAndOffer() succeeded.'); // NOTE(mmalavalli): PeerConnectionManager#createAndOffer() queues the\n        // initial offer in the event queue for the 'description' event. So,\n        // we are dequeueing to prevent the spurious 'update' message sent by\n        // the client after connecting to a room.\n\n        peerConnectionManager.dequeue('description');\n      }).catch(function (error) {\n        log.error('createAndOffer() failed:', error);\n        reject(error);\n        throw error;\n      });\n    };\n\n    var automaticSubscription = options.automaticSubscription,\n        bandwidthProfile = options.bandwidthProfile,\n        dominantSpeaker = options.dominantSpeaker,\n        environment = options.environment,\n        eventObserver = options.eventObserver,\n        loggerName = options.loggerName,\n        logLevel = options.logLevel,\n        name = options.name,\n        networkMonitor = options.networkMonitor,\n        networkQuality = options.networkQuality,\n        realm = options.realm,\n        sdpSemantics = options.sdpSemantics; // decide which msp channels to request\n    // dominantSpeaker, networkQuality\n\n    var trackPriority = !!bandwidthProfile;\n    var trackSwitchOff = !!bandwidthProfile;\n    var renderHints = !!bandwidthProfile && (options.clientTrackSwitchOffControl !== 'disabled' || options.contentPreferencesMode !== 'disabled');\n    var transportOptions = Object.assign({\n      adaptiveSimulcast: adaptiveSimulcast,\n      automaticSubscription: automaticSubscription,\n      dominantSpeaker: dominantSpeaker,\n      environment: environment,\n      eventObserver: eventObserver,\n      loggerName: loggerName,\n      logLevel: logLevel,\n      networkMonitor: networkMonitor,\n      networkQuality: networkQuality,\n      iceServers: iceServers,\n      onIced: onIced,\n      realm: realm,\n      renderHints: renderHints,\n      sdpSemantics: sdpSemantics,\n      trackPriority: trackPriority,\n      trackSwitchOff: trackSwitchOff\n    }, bandwidthProfile ? {\n      bandwidthProfile: bandwidthProfile\n    } : {});\n    transport = new Transport(name, token, localParticipant, peerConnectionManager, wsServer, transportOptions);\n    var connectEventPayload = createRoomConnectEventPayload(options);\n    eventObserver.emit('event', connectEventPayload);\n    transport.once('connected', function (initialState) {\n      log.debug('Transport connected:', initialState);\n\n      if (isCanceled()) {\n        reject(cancellationError);\n        return;\n      }\n\n      var localParticipantState = initialState.participant;\n\n      if (!localParticipantState) {\n        reject(new SignalingIncomingMessageInvalidError());\n        return;\n      }\n\n      var signalingRegion = initialState.options.signaling_region;\n      localParticipant.setSignalingRegion(signalingRegion);\n      resolve(new RoomV2(localParticipant, initialState, transport, peerConnectionManager, options));\n    });\n    transport.once('stateChanged', function (state, error) {\n      if (state === 'disconnected') {\n        transport = null;\n        reject(error || new SignalingConnectionDisconnectedError());\n      } else {\n        log.debug('Transport state changed:', state);\n      }\n    });\n  }, function () {\n    if (transport) {\n      transport.disconnect();\n      transport = null;\n    }\n  });\n  cancelablePromise.catch(function () {\n    if (transport) {\n      transport.disconnect();\n      transport = null;\n    }\n\n    peerConnectionManager.close();\n  });\n  return cancelablePromise;\n}\n\nmodule.exports = createCancelableRoomSignalingPromise;","map":null,"metadata":{},"sourceType":"script"}