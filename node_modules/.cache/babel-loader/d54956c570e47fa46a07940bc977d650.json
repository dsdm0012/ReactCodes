{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nvar StateMachine = require('./statemachine');\n\nvar _a = require('./util'),\n    buildLogLevels = _a.buildLogLevels,\n    makeUUID = _a.makeUUID;\n\nvar Log = require('./util/log');\n\nvar NetworkMonitor = require('./util/networkmonitor');\n\nvar Timeout = require('./util/timeout');\n\nvar nInstances = 0;\n/*\n  TwilioConnection states\n  -----------------------\n\n       ------------------------------------------\n       |                                        |\n       |                                        v\n  +---------+       +--------------+       +----------+\n  |  early  | ----> |  connecting  | ----> |  closed  |\n  +---------+       +--------------+       +----------+\n    ^                     | ^ |                 ^ ^\n    | --------------------- | |                 | |\n    | | --------------------- |                 | |\n    | | | --------------------|------------------ |\n    | v | |                   v                   |\n  +----------+           +--------+               |\n  | waiting  | --------> |  open  | ---------------\n  +----------+           +--------+\n */\n\nvar states = {\n  closed: [],\n  connecting: ['closed', 'open', 'waiting'],\n  early: ['closed', 'connecting'],\n  open: ['closed'],\n  waiting: ['closed', 'connecting', 'early', 'open']\n};\nvar events = {\n  closed: 'close',\n  open: 'open',\n  waiting: 'waiting'\n};\nvar TCMP_VERSION = 2;\nvar DEFAULT_MAX_CONSECUTIVE_MISSED_HEARTBEATS = 3;\nvar DEFAULT_MAX_CONSECUTIVE_FAILED_HELLOS = 3;\nvar DEFAULT_MAX_REQUESTED_HEARTBEAT_TIMEOUT = 5000;\nvar DEFAULT_OPEN_TIMEOUT = 15000;\nvar DEFAULT_WELCOME_TIMEOUT = 5000;\nvar OUTGOING_HEARTBEAT_OFFSET = 200;\nvar WS_CLOSE_NORMAL = 1000;\nvar WS_CLOSE_WELCOME_TIMEOUT = 3000;\nvar WS_CLOSE_HEARTBEATS_MISSED = 3001;\nvar WS_CLOSE_HELLO_FAILED = 3002;\nvar WS_CLOSE_SEND_FAILED = 3003;\nvar WS_CLOSE_NETWORK_CHANGED = 3004;\nvar WS_CLOSE_BUSY_WAIT = 3005;\nvar WS_CLOSE_SERVER_BUSY = 3006;\nvar WS_CLOSE_OPEN_TIMEOUT = 3007;\nvar toplevel = globalThis;\nvar WebSocket = toplevel.WebSocket ? toplevel.WebSocket : require('ws');\nvar CloseReason = {\n  BUSY: 'busy',\n  FAILED: 'failed',\n  LOCAL: 'local',\n  REMOTE: 'remote',\n  TIMEOUT: 'timeout'\n};\nvar wsCloseCodesToCloseReasons = new Map([[WS_CLOSE_WELCOME_TIMEOUT, CloseReason.TIMEOUT], [WS_CLOSE_HEARTBEATS_MISSED, CloseReason.TIMEOUT], [WS_CLOSE_HELLO_FAILED, CloseReason.FAILED], [WS_CLOSE_SEND_FAILED, CloseReason.FAILED], [WS_CLOSE_NETWORK_CHANGED, CloseReason.TIMEOUT], [WS_CLOSE_SERVER_BUSY, CloseReason.BUSY], [WS_CLOSE_OPEN_TIMEOUT, CloseReason.TIMEOUT]]);\n/**\n * A {@link TwilioConnection} represents a WebSocket connection\n * to a Twilio Connections Messaging Protocol (TCMP) server.\n * @fires TwilioConnection#close\n * @fires TwilioConnection#error\n * @fires TwilioConnection#message\n * @fires TwilioConnection#open\n * @fires TwilioConnection#waiting\n */\n\nvar TwilioConnection =\n/** @class */\nfunction (_super) {\n  __extends(TwilioConnection, _super);\n  /**\n   * Construct a {@link TwilioConnection}.\n   * @param {string} serverUrl - TCMP server url\n   * @param {TwilioConnectionOptions} options - {@link TwilioConnection} options\n   */\n\n\n  function TwilioConnection(serverUrl, options) {\n    var _this = _super.call(this, 'early', states) || this;\n\n    options = Object.assign({\n      helloBody: null,\n      maxConsecutiveFailedHellos: DEFAULT_MAX_CONSECUTIVE_FAILED_HELLOS,\n      maxConsecutiveMissedHeartbeats: DEFAULT_MAX_CONSECUTIVE_MISSED_HEARTBEATS,\n      requestedHeartbeatTimeout: DEFAULT_MAX_REQUESTED_HEARTBEAT_TIMEOUT,\n      openTimeout: DEFAULT_OPEN_TIMEOUT,\n      welcomeTimeout: DEFAULT_WELCOME_TIMEOUT,\n      Log: Log,\n      WebSocket: WebSocket\n    }, options);\n    var logLevels = buildLogLevels(options.logLevel);\n    var log = new options.Log('default', _this, logLevels, options.loggerName);\n    var networkMonitor = options.networkMonitor ? new NetworkMonitor(function () {\n      var type = networkMonitor.type;\n      var reason = \"Network changed\" + (type ? \" to \" + type : '');\n      log.debug(reason);\n\n      _this._close({\n        code: WS_CLOSE_NETWORK_CHANGED,\n        reason: reason\n      });\n    }) : null;\n    Object.defineProperties(_this, {\n      _busyWaitTimeout: {\n        value: null,\n        writable: true\n      },\n      _consecutiveHeartbeatsMissed: {\n        value: 0,\n        writable: true\n      },\n      _cookie: {\n        value: null,\n        writable: true\n      },\n      _eventObserver: {\n        value: options.eventObserver\n      },\n      _heartbeatTimeout: {\n        value: null,\n        writable: true\n      },\n      _hellosLeft: {\n        value: options.maxConsecutiveFailedHellos,\n        writable: true\n      },\n      _instanceId: {\n        value: ++nInstances\n      },\n      _log: {\n        value: log\n      },\n      _messageQueue: {\n        value: []\n      },\n      _networkMonitor: {\n        value: networkMonitor\n      },\n      _options: {\n        value: options\n      },\n      _openTimeout: {\n        value: null,\n        writable: true\n      },\n      _sendHeartbeatTimeout: {\n        value: null,\n        writable: true\n      },\n      _serverUrl: {\n        value: serverUrl\n      },\n      _welcomeTimeout: {\n        value: null,\n        writable: true\n      },\n      _ws: {\n        value: null,\n        writable: true\n      }\n    });\n    var eventsToLevels = {\n      connecting: 'info',\n      early: 'info',\n      open: 'info',\n      waiting: 'warning',\n      closed: 'info'\n    };\n\n    _this.on('stateChanged', function (state) {\n      var args = [];\n\n      for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n      }\n\n      if (state in events) {\n        _this.emit.apply(_this, __spreadArray([events[state]], __read(args)));\n      }\n\n      var event = {\n        name: state,\n        group: 'signaling',\n        level: eventsToLevels[_this.state]\n      };\n\n      if (state === 'closed') {\n        var _a = __read(args, 1),\n            reason = _a[0];\n\n        event.payload = {\n          reason: reason\n        };\n        event.level = reason === CloseReason.LOCAL ? 'info' : 'error';\n      }\n\n      _this._eventObserver.emit('event', event);\n    });\n\n    _this._eventObserver.emit('event', {\n      name: _this.state,\n      group: 'signaling',\n      level: eventsToLevels[_this.state]\n    });\n\n    _this._connect();\n\n    return _this;\n  }\n\n  TwilioConnection.prototype.toString = function () {\n    return \"[TwilioConnection #\" + this._instanceId + \": \" + this._ws.url + \"]\";\n  };\n  /**\n   * Close the {@link TwilioConnection}.\n   * @param {{code: number, reason: string}} event\n   * @private\n   */\n\n\n  TwilioConnection.prototype._close = function (_a) {\n    var code = _a.code,\n        reason = _a.reason;\n\n    if (this.state === 'closed') {\n      return;\n    }\n\n    if (this._openTimeout) {\n      this._openTimeout.clear();\n    }\n\n    if (this._welcomeTimeout) {\n      this._welcomeTimeout.clear();\n    }\n\n    if (this._heartbeatTimeout) {\n      this._heartbeatTimeout.clear();\n    }\n\n    if (this._sendHeartbeatTimeout) {\n      this._sendHeartbeatTimeout.clear();\n    }\n\n    if (this._networkMonitor) {\n      this._networkMonitor.stop();\n    }\n\n    if (this._busyWaitTimeout && code !== WS_CLOSE_BUSY_WAIT) {\n      this._busyWaitTimeout.clear();\n    }\n\n    this._messageQueue.splice(0);\n\n    var log = this._log;\n\n    if (code === WS_CLOSE_NORMAL) {\n      log.debug('Closed');\n      this.transition('closed', null, [CloseReason.LOCAL]);\n    } else {\n      log.warn(\"Closed: \" + code + \" - \" + reason);\n\n      if (code !== WS_CLOSE_BUSY_WAIT) {\n        this.transition('closed', null, [wsCloseCodesToCloseReasons.get(code) || CloseReason.REMOTE]);\n      }\n    }\n\n    var readyState = this._ws.readyState;\n    var WebSocket = this._options.WebSocket;\n\n    if (readyState !== WebSocket.CLOSING && readyState !== WebSocket.CLOSED) {\n      this._ws.close(code, reason);\n    }\n  };\n  /**\n   * Connect to the TCMP server.\n   * @private\n   */\n\n\n  TwilioConnection.prototype._connect = function () {\n    var _this = this;\n\n    var log = this._log;\n\n    if (this.state === 'waiting') {\n      this.transition('early');\n    } else if (this.state !== 'early') {\n      log.warn(\"Unexpected state \\\"\" + this.state + \"\\\" for connecting to the\" + ' TCMP server.');\n      return;\n    }\n\n    this._ws = new this._options.WebSocket(this._serverUrl);\n    var ws = this._ws;\n    log.debug('Created a new WebSocket:', ws);\n    ws.addEventListener('close', function (event) {\n      return _this._close(event);\n    });\n    var openTimeout = this._options.openTimeout; // Add a timeout for getting the onopen event on the WebSocket (15 sec). After that, attempt to reconnect only if this is not the first attempt.\n\n    this._openTimeout = new Timeout(function () {\n      var reason = \"Failed to open in \" + openTimeout + \" ms\";\n\n      _this._close({\n        code: WS_CLOSE_OPEN_TIMEOUT,\n        reason: reason\n      });\n    }, openTimeout);\n    ws.addEventListener('open', function () {\n      log.debug('WebSocket opened:', ws);\n\n      _this._openTimeout.clear();\n\n      _this._startHandshake();\n\n      if (_this._networkMonitor) {\n        _this._networkMonitor.start();\n      }\n    });\n    ws.addEventListener('message', function (message) {\n      log.debug(\"Incoming: \" + message.data);\n\n      try {\n        message = JSON.parse(message.data);\n      } catch (error) {\n        _this.emit('error', error);\n\n        return;\n      }\n\n      switch (message.type) {\n        case 'bad':\n          _this._handleBad(message);\n\n          break;\n\n        case 'busy':\n          _this._handleBusy(message);\n\n          break;\n\n        case 'bye':\n          // Do nothing.\n          break;\n\n        case 'msg':\n          _this._handleMessage(message);\n\n        // NOTE(mpatwardhan): Each incoming message should be treated as an incoming\n        // heartbeat intentionally falling through to 'heartbeat' case.\n        // eslint-disable-next-line no-fallthrough\n\n        case 'heartbeat':\n          _this._handleHeartbeat();\n\n          break;\n\n        case 'welcome':\n          _this._handleWelcome(message);\n\n          break;\n\n        default:\n          _this._log.debug(\"Unknown message type: \" + message.type);\n\n          _this.emit('error', new Error(\"Unknown message type: \" + message.type));\n\n          break;\n      }\n    });\n  };\n  /**\n   * Handle an incoming \"bad\" message.\n   * @param {{reason: string}} message\n   * @private\n   */\n\n\n  TwilioConnection.prototype._handleBad = function (_a) {\n    var reason = _a.reason;\n    var log = this._log;\n\n    if (!['connecting', 'open'].includes(this.state)) {\n      log.warn(\"Unexpected state \\\"\" + this.state + \"\\\" for handling a \\\"bad\\\" message\" + ' from the TCMP server.');\n      return;\n    }\n\n    if (this.state === 'connecting') {\n      log.warn(\"Closing: \" + WS_CLOSE_HELLO_FAILED + \" - \" + reason);\n\n      this._close({\n        code: WS_CLOSE_HELLO_FAILED,\n        reason: reason\n      });\n\n      return;\n    }\n\n    log.debug(\"Error: \" + reason);\n    this.emit('error', new Error(reason));\n  };\n  /**\n   * Handle an incoming \"busy\" message.\n   * @param {{cookie: ?string, keepAlive: boolean, retryAfter: number}} message\n   * @private\n   */\n\n\n  TwilioConnection.prototype._handleBusy = function (_a) {\n    var _this = this;\n\n    var cookie = _a.cookie,\n        keepAlive = _a.keepAlive,\n        retryAfter = _a.retryAfter;\n    var log = this._log;\n\n    if (!['connecting', 'waiting'].includes(this.state)) {\n      log.warn(\"Unexpected state \\\"\" + this.state + \"\\\" for handling a \\\"busy\\\" message\" + ' from the TCMP server.');\n      return;\n    }\n\n    if (this._busyWaitTimeout) {\n      this._busyWaitTimeout.clear();\n    }\n\n    if (this._welcomeTimeout) {\n      this._welcomeTimeout.clear();\n    }\n\n    var reason = retryAfter < 0 ? 'Received terminal \"busy\" message' : \"Received \\\"busy\\\" message, retrying after \" + retryAfter + \" ms\";\n\n    if (retryAfter < 0) {\n      log.warn(\"Closing: \" + WS_CLOSE_SERVER_BUSY + \" - \" + reason);\n\n      this._close({\n        code: WS_CLOSE_SERVER_BUSY,\n        reason: reason\n      });\n\n      return;\n    }\n\n    var maxConsecutiveFailedHellos = this._options.maxConsecutiveFailedHellos;\n    this._hellosLeft = maxConsecutiveFailedHellos;\n    this._cookie = cookie || null;\n\n    if (keepAlive) {\n      log.warn(reason);\n      this._busyWaitTimeout = new Timeout(function () {\n        return _this._startHandshake();\n      }, retryAfter);\n    } else {\n      log.warn(\"Closing: \" + WS_CLOSE_BUSY_WAIT + \" - \" + reason);\n\n      this._close({\n        code: WS_CLOSE_BUSY_WAIT,\n        reason: reason\n      });\n\n      this._busyWaitTimeout = new Timeout(function () {\n        return _this._connect();\n      }, retryAfter);\n    }\n\n    this.transition('waiting', null, [keepAlive, retryAfter]);\n  };\n  /**\n   * Handle an incoming \"heartbeat\" message.\n   * @private\n   */\n\n\n  TwilioConnection.prototype._handleHeartbeat = function () {\n    if (this.state !== 'open') {\n      this._log.warn(\"Unexpected state \\\"\" + this.state + \"\\\" for handling a \\\"heartbeat\\\"\" + ' message from the TCMP server.');\n\n      return;\n    }\n\n    this._heartbeatTimeout.reset();\n  };\n  /**\n   * Handle a missed \"heartbeat\" message.\n   * @private\n   */\n\n\n  TwilioConnection.prototype._handleHeartbeatTimeout = function () {\n    if (this.state !== 'open') {\n      return;\n    }\n\n    var log = this._log;\n    var maxConsecutiveMissedHeartbeats = this._options.maxConsecutiveMissedHeartbeats;\n    log.debug(\"Consecutive heartbeats missed: \" + maxConsecutiveMissedHeartbeats);\n    var reason = \"Missed \" + maxConsecutiveMissedHeartbeats + \" \\\"heartbeat\\\" messages\";\n    log.warn(\"Closing: \" + WS_CLOSE_HEARTBEATS_MISSED + \" - \" + reason);\n\n    this._close({\n      code: WS_CLOSE_HEARTBEATS_MISSED,\n      reason: reason\n    });\n  };\n  /**\n   * Handle an incoming \"msg\" message.\n   * @param {{body: object}} message\n   * @private\n   */\n\n\n  TwilioConnection.prototype._handleMessage = function (_a) {\n    var body = _a.body;\n\n    if (this.state !== 'open') {\n      this._log.warn(\"Unexpected state \\\"\" + this.state + \"\\\" for handling a \\\"msg\\\" message\" + ' from the TCMP server.');\n\n      return;\n    }\n\n    this.emit('message', body);\n  };\n  /**\n   * Handle an incoming \"welcome\" message.\n   * @param {{ negotiatedTimeout: number }} message\n   * @private\n   */\n\n\n  TwilioConnection.prototype._handleWelcome = function (_a) {\n    var _this = this;\n\n    var negotiatedTimeout = _a.negotiatedTimeout;\n    var log = this._log;\n\n    if (!['connecting', 'waiting'].includes(this.state)) {\n      log.warn(\"Unexpected state \\\"\" + this.state + \"\\\" for handling a \\\"welcome\\\"\" + ' message from the TCMP server.');\n      return;\n    }\n\n    if (this.state === 'waiting') {\n      log.debug('Received \"welcome\" message, no need to retry connection.');\n\n      this._busyWaitTimeout.clear();\n    }\n\n    var maxConsecutiveMissedHeartbeats = this._options.maxConsecutiveMissedHeartbeats;\n    var heartbeatTimeout = negotiatedTimeout * maxConsecutiveMissedHeartbeats;\n    var outgoingHeartbeatTimeout = negotiatedTimeout - OUTGOING_HEARTBEAT_OFFSET;\n\n    this._welcomeTimeout.clear();\n\n    this._heartbeatTimeout = new Timeout(function () {\n      return _this._handleHeartbeatTimeout();\n    }, heartbeatTimeout);\n\n    this._messageQueue.splice(0).forEach(function (message) {\n      return _this._send(message);\n    });\n\n    this._sendHeartbeatTimeout = new Timeout(function () {\n      return _this._sendHeartbeat();\n    }, outgoingHeartbeatTimeout);\n    this.transition('open');\n  };\n  /**\n   * Handle a missed \"welcome\" message.\n   * @private\n   */\n\n\n  TwilioConnection.prototype._handleWelcomeTimeout = function () {\n    if (this.state !== 'connecting') {\n      return;\n    }\n\n    var log = this._log;\n\n    if (this._hellosLeft <= 0) {\n      var reason = 'All handshake attempts failed';\n      log.warn(\"Closing: \" + WS_CLOSE_WELCOME_TIMEOUT + \" - \" + reason);\n\n      this._close({\n        code: WS_CLOSE_WELCOME_TIMEOUT,\n        reason: reason\n      });\n\n      return;\n    }\n\n    var maxConsecutiveFailedHellos = this._options.maxConsecutiveFailedHellos;\n    log.warn(\"Handshake attempt \" + (maxConsecutiveFailedHellos - this._hellosLeft) + \" failed\");\n\n    this._startHandshake();\n  };\n  /**\n   * Send a message to the TCMP server.\n   * @param {*} message\n   * @private\n   */\n\n\n  TwilioConnection.prototype._send = function (message) {\n    var readyState = this._ws.readyState;\n    var WebSocket = this._options.WebSocket;\n\n    if (readyState === WebSocket.OPEN) {\n      var data = JSON.stringify(message);\n\n      this._log.debug(\"Outgoing: \" + data);\n\n      try {\n        this._ws.send(data);\n\n        if (this._sendHeartbeatTimeout) {\n          // Each outgoing message is to be treated as an outgoing heartbeat.\n          this._sendHeartbeatTimeout.reset();\n        }\n      } catch (error) {\n        var reason = 'Failed to send message';\n\n        this._log.warn(\"Closing: \" + WS_CLOSE_SEND_FAILED + \" - \" + reason);\n\n        this._close({\n          code: WS_CLOSE_SEND_FAILED,\n          reason: reason\n        });\n      }\n    }\n  };\n  /**\n   * Send a \"heartbeat\" message.\n   * @private\n   */\n\n\n  TwilioConnection.prototype._sendHeartbeat = function () {\n    if (this.state === 'closed') {\n      return;\n    }\n\n    this._send({\n      type: 'heartbeat'\n    });\n  };\n  /**\n   * Send a \"hello\" message.\n   * @private\n   */\n\n\n  TwilioConnection.prototype._sendHello = function () {\n    var _a = this._options,\n        helloBody = _a.helloBody,\n        timeout = _a.requestedHeartbeatTimeout;\n    var hello = {\n      id: makeUUID(),\n      timeout: timeout,\n      type: 'hello',\n      version: TCMP_VERSION\n    };\n\n    if (this._cookie) {\n      hello.cookie = this._cookie;\n    }\n\n    if (helloBody) {\n      hello.body = helloBody;\n    }\n\n    this._send(hello);\n  };\n  /**\n   * Send or enqueue a message.\n   * @param {*} message\n   * @private\n   */\n\n\n  TwilioConnection.prototype._sendOrEnqueue = function (message) {\n    var _this = this;\n\n    if (this.state === 'closed') {\n      return;\n    }\n\n    var sendOrEnqueue = this.state === 'open' ? function (message) {\n      return _this._send(message);\n    } : function (message) {\n      return _this._messageQueue.push(message);\n    };\n    sendOrEnqueue(message);\n  };\n  /**\n   * Start the TCMP handshake.\n   * @private\n   */\n\n\n  TwilioConnection.prototype._startHandshake = function () {\n    var _this = this;\n\n    if (['early', 'waiting'].includes(this.state)) {\n      this.transition('connecting');\n    }\n\n    if (this.state !== 'connecting') {\n      return;\n    }\n\n    this._hellosLeft--;\n\n    this._sendHello();\n\n    var welcomeTimeout = this._options.welcomeTimeout;\n    this._welcomeTimeout = new Timeout(function () {\n      return _this._handleWelcomeTimeout();\n    }, welcomeTimeout);\n  };\n  /**\n   * Close the {@link TwilioConnection}.\n   * @returns {void}\n   */\n\n\n  TwilioConnection.prototype.close = function () {\n    if (this.state === 'closed') {\n      return;\n    }\n\n    this._sendOrEnqueue({\n      type: 'bye'\n    });\n\n    this._close({\n      code: WS_CLOSE_NORMAL,\n      reason: 'Normal'\n    });\n  };\n  /**\n   * Send a \"msg\" message.\n   * @param {*} body\n   * @returns {void}\n   */\n\n\n  TwilioConnection.prototype.sendMessage = function (body) {\n    this._sendOrEnqueue({\n      body: body,\n      type: 'msg'\n    });\n  };\n\n  return TwilioConnection;\n}(StateMachine);\n/**\n * A unique string depicting the reason for the {@link TwilioConnection} being closed.\n * @enum {string}\n */\n\n\nTwilioConnection.CloseReason = CloseReason;\n/**\n * A {@link TwilioConnection} was closed.\n * @event TwilioConnection#close\n * @param {CloseReason} reason - The reason for the {@link TwilioConnection} being closed\n */\n\n/**\n * A {@link TwilioConnection} received an error from the TCMP server.\n * @event TwilioConnection#error\n * @param {Error} error - The TCMP server error\n */\n\n/**\n * A {@link TwilioConnection} received a message from the TCMP server.\n * @event TwilioConnection#message\n * @param {*} body - Message body\n */\n\n/**\n * A {@link TwilioConnection} completed a hello/welcome handshake with the TCMP server.\n * @event TwilioConnection#open\n */\n\n/**\n * A {@link TwilioConnection} received a \"busy\" message from the TCMP server.\n * @event TwilioConnection#waiting\n * @param {boolean} keepAlive - true if the WebSocket connection is retained\n * @param {number} retryAfter - delay in milliseconds after which a retry is attempted\n */\n\n/**\n * {@link TwilioConnection} options\n * @typedef {object} TwilioConnectionOptions\n * @property {EventObserver} [eventObserver] - Optional event observer\n * @property {*} [helloBody=null] - Optional body for \"hello\" message\n * @property {LogLevel} [logLevel=warn] - Log level of the {@link TwilioConnection}\n * @property {number} [maxConsecutiveFailedHellos=3] - Max. number of consecutive failed \"hello\"s\n * @property {number} [maxConsecutiveMissedHeartbeats=3] - Max. number of (effective) consecutive \"heartbeat\" messages that can be missed\n * @property {number} [requestedHeartbeatTimeout=5000] - \"heartbeat\" timeout (ms) requested by the {@link TwilioConnection}\n * @property {number} [welcomeTimeout=5000] - Time (ms) to wait for the \"welcome\" message after sending the \"hello\" message\n */\n\nmodule.exports = TwilioConnection;","map":null,"metadata":{},"sourceType":"script"}