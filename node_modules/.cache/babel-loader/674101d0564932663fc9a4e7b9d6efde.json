{"ast":null,"code":"'use strict';\n\nvar defer = require('./').defer;\n\nvar states = {\n  high: new Set(['low']),\n  low: new Set(['high'])\n};\n/**\n * Construct a {@link Latch}.\n * @class\n * @classdesc A {@link Latch} has two states (\"high\" and \"low\") and methods for\n * transitioning between them ({@link Latch#raise} and {@link Latch#lower}).\n * @param {string} [initialState=\"low\"] - either \"high\" or \"low\"\n */\n\nfunction Latch(initialState) {\n  if (!(this instanceof Latch)) {\n    return new Latch(initialState);\n  }\n\n  var state = initialState || 'low';\n  Object.defineProperties(this, {\n    _state: {\n      set: function set(_state) {\n        if (state !== _state) {\n          state = _state;\n\n          var whenDeferreds = this._whenDeferreds.get(state);\n\n          whenDeferreds.forEach(function (deferred) {\n            deferred.resolve(this);\n          }, this);\n          whenDeferreds.clear();\n        }\n      },\n      get: function get() {\n        return state;\n      }\n    },\n    _whenDeferreds: {\n      value: new Map([['high', new Set()], ['low', new Set()]])\n    },\n    state: {\n      enumerable: true,\n      get: function get() {\n        return this._state;\n      }\n    }\n  });\n}\n/**\n * Transition to \"low\".\n * @returns {this}\n * @throws {Error}\n */\n\n\nLatch.prototype.lower = function lower() {\n  return this.transition('low');\n};\n/**\n * Transition to \"high\".\n * @returns {this}\n * @throws {Error}\n */\n\n\nLatch.prototype.raise = function raise() {\n  return this.transition('high');\n};\n/**\n * Transition to a new state.\n * @param {string} newState\n * @returns {this}\n * @throws {Error}\n */\n\n\nLatch.prototype.transition = function transition(newState) {\n  if (!states[this.state].has(newState)) {\n    throw createUnreachableStateError(this.state, newState);\n  }\n\n  this._state = newState;\n  return this;\n};\n/**\n * Return a Promise that resolves when the {@link Latch} transitions to\n * the specified state.\n * @param {string} state\n * @returns {Promise<this>}\n */\n\n\nLatch.prototype.when = function when(state) {\n  if (this.state === state) {\n    return Promise.resolve(this);\n  }\n\n  if (!states[this.state].has(state)) {\n    return Promise.reject(createUnreachableStateError(this.state, state));\n  }\n\n  var deferred = defer();\n\n  this._whenDeferreds.get(state).add(deferred);\n\n  return deferred.promise;\n};\n/**\n * Create an unreachable state Error.\n * @param {string} from - state to be transitioned from\n * @param {string} to - state to be transitioned to\n * @return {Error}\n */\n\n\nfunction createUnreachableStateError(from, to) {\n  return new Error('Cannot transition from \"' + from + '\" to \"' + to + '\"');\n}\n\nmodule.exports = Latch;","map":{"version":3,"sources":["../../../lib/webrtc/util/latch.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["'use strict';\nvar defer = require('./').defer;\nvar states = {\n    high: new Set(['low']),\n    low: new Set(['high'])\n};\n/**\n * Construct a {@link Latch}.\n * @class\n * @classdesc A {@link Latch} has two states (\"high\" and \"low\") and methods for\n * transitioning between them ({@link Latch#raise} and {@link Latch#lower}).\n * @param {string} [initialState=\"low\"] - either \"high\" or \"low\"\n */\nfunction Latch(initialState) {\n    if (!(this instanceof Latch)) {\n        return new Latch(initialState);\n    }\n    var state = initialState || 'low';\n    Object.defineProperties(this, {\n        _state: {\n            set: function (_state) {\n                if (state !== _state) {\n                    state = _state;\n                    var whenDeferreds = this._whenDeferreds.get(state);\n                    whenDeferreds.forEach(function (deferred) {\n                        deferred.resolve(this);\n                    }, this);\n                    whenDeferreds.clear();\n                }\n            },\n            get: function () {\n                return state;\n            }\n        },\n        _whenDeferreds: {\n            value: new Map([\n                ['high', new Set()],\n                ['low', new Set()]\n            ])\n        },\n        state: {\n            enumerable: true,\n            get: function () {\n                return this._state;\n            }\n        }\n    });\n}\n/**\n * Transition to \"low\".\n * @returns {this}\n * @throws {Error}\n */\nLatch.prototype.lower = function lower() {\n    return this.transition('low');\n};\n/**\n * Transition to \"high\".\n * @returns {this}\n * @throws {Error}\n */\nLatch.prototype.raise = function raise() {\n    return this.transition('high');\n};\n/**\n * Transition to a new state.\n * @param {string} newState\n * @returns {this}\n * @throws {Error}\n */\nLatch.prototype.transition = function transition(newState) {\n    if (!states[this.state].has(newState)) {\n        throw createUnreachableStateError(this.state, newState);\n    }\n    this._state = newState;\n    return this;\n};\n/**\n * Return a Promise that resolves when the {@link Latch} transitions to\n * the specified state.\n * @param {string} state\n * @returns {Promise<this>}\n */\nLatch.prototype.when = function when(state) {\n    if (this.state === state) {\n        return Promise.resolve(this);\n    }\n    if (!states[this.state].has(state)) {\n        return Promise.reject(createUnreachableStateError(this.state, state));\n    }\n    var deferred = defer();\n    this._whenDeferreds.get(state).add(deferred);\n    return deferred.promise;\n};\n/**\n * Create an unreachable state Error.\n * @param {string} from - state to be transitioned from\n * @param {string} to - state to be transitioned to\n * @return {Error}\n */\nfunction createUnreachableStateError(from, to) {\n    return new Error('Cannot transition from \"' + from + '\" to \"' + to + '\"');\n}\nmodule.exports = Latch;\n//# sourceMappingURL=latch.js.map"]},"metadata":{},"sourceType":"script"}