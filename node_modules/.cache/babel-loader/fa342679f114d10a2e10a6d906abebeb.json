{"ast":null,"code":"/* globals RTCPeerConnection, RTCRtpTransceiver */\n'use strict';\n\nvar flatMap = require('./').flatMap;\n\nvar guessBrowser = require('./').guessBrowser; // NOTE(mmalavalli): We cache Chrome's sdpSemantics support in order to prevent\n// instantiation of more than one RTCPeerConnection.\n\n\nvar isSdpSemanticsSupported = null;\n/**\n * Check if Chrome supports specifying sdpSemantics for an RTCPeerConnection.\n * @return {boolean}\n */\n\nfunction checkIfSdpSemanticsIsSupported() {\n  if (typeof isSdpSemanticsSupported === 'boolean') {\n    return isSdpSemanticsSupported;\n  }\n\n  if (typeof RTCPeerConnection === 'undefined') {\n    isSdpSemanticsSupported = false;\n    return isSdpSemanticsSupported;\n  }\n\n  try {\n    // eslint-disable-next-line no-new\n    new RTCPeerConnection({\n      sdpSemantics: 'foo'\n    });\n    isSdpSemanticsSupported = false;\n  } catch (e) {\n    isSdpSemanticsSupported = true;\n  }\n\n  return isSdpSemanticsSupported;\n} // NOTE(mmalavalli): We cache Chrome's SDP format in order to prevent\n// instantiation of more than one RTCPeerConnection.\n\n\nvar chromeSdpFormat = null;\n/**\n * Get Chrome's default SDP format.\n * @returns {'planb'|'unified'}\n */\n\nfunction getChromeDefaultSdpFormat() {\n  if (!chromeSdpFormat) {\n    if (typeof RTCPeerConnection !== 'undefined' && 'addTransceiver' in RTCPeerConnection.prototype) {\n      try {\n        new RTCPeerConnection().addTransceiver('audio');\n        chromeSdpFormat = 'unified';\n      } catch (e) {\n        chromeSdpFormat = 'planb';\n      }\n    } else {\n      chromeSdpFormat = 'planb';\n    }\n  }\n\n  return chromeSdpFormat;\n}\n/**\n * Get Chrome's SDP format.\n * @param {'plan-b'|'unified-plan'} [sdpSemantics]\n * @returns {'planb'|'unified'}\n */\n\n\nfunction getChromeSdpFormat(sdpSemantics) {\n  if (!sdpSemantics || !checkIfSdpSemanticsIsSupported()) {\n    return getChromeDefaultSdpFormat();\n  }\n\n  return {\n    'plan-b': 'planb',\n    'unified-plan': 'unified'\n  }[sdpSemantics];\n}\n/**\n * Get Safari's default SDP format.\n * @returns {'planb'|'unified'}\n */\n\n\nfunction getSafariSdpFormat() {\n  return typeof RTCRtpTransceiver !== 'undefined' && 'currentDirection' in RTCRtpTransceiver.prototype ? 'unified' : 'planb';\n}\n/**\n * Get the browser's default SDP format.\n * @param {'plan-b'|'unified-plan'} [sdpSemantics]\n * @returns {'planb'|'unified'}\n */\n\n\nfunction getSdpFormat(sdpSemantics) {\n  return {\n    chrome: getChromeSdpFormat(sdpSemantics),\n    firefox: 'unified',\n    safari: getSafariSdpFormat()\n  }[guessBrowser()] || null;\n}\n/**\n * Match a pattern across lines, returning the first capture group for any\n * matches.\n * @param {string} pattern\n * @param {string} lines\n * @returns {Set<string>} matches\n */\n\n\nfunction getMatches(pattern, lines) {\n  var matches = lines.match(new RegExp(pattern, 'gm')) || [];\n  return matches.reduce(function (results, line) {\n    var match = line.match(new RegExp(pattern));\n    return match ? results.add(match[1]) : results;\n  }, new Set());\n}\n/**\n * Get a Set of MediaStreamTrack IDs from an SDP.\n * @param {string} pattern\n * @param {string} sdp\n * @returns {Set<string>}\n */\n\n\nfunction getTrackIds(pattern, sdp) {\n  return getMatches(pattern, sdp);\n}\n/**\n * Get a Set of MediaStreamTrack IDs from a Plan B SDP.\n * @param {string} sdp - Plan B SDP\n * @returns {Set<string>} trackIds\n */\n\n\nfunction getPlanBTrackIds(sdp) {\n  return getTrackIds('^a=ssrc:[0-9]+ +msid:.+ +(.+) *$', sdp);\n}\n/**\n * Get a Set of MediaStreamTrack IDs from a Unified Plan SDP.\n * @param {string} sdp - Unified Plan SDP\n * @returns {Set<string>} trackIds\n */\n\n\nfunction getUnifiedPlanTrackIds(sdp) {\n  return getTrackIds('^a=msid:.+ +(.+) *$', sdp);\n}\n/**\n * Get a Set of SSRCs for a MediaStreamTrack from a Plan B SDP.\n * @param {string} sdp - Plan B SDP\n * @param {string} trackId - MediaStreamTrack ID\n * @returns {Set<string>}\n */\n\n\nfunction getPlanBSSRCs(sdp, trackId) {\n  var pattern = '^a=ssrc:([0-9]+) +msid:[^ ]+ +' + trackId + ' *$';\n  return getMatches(pattern, sdp);\n}\n/**\n * Get the m= sections of a particular kind and direction from an sdp.\n * @param {string} sdp -  sdp string\n * @param {string} [kind] - Pattern for matching kind\n * @param {string} [direction] - Pattern for matching direction\n * @returns {Array<string>} mediaSections\n */\n\n\nfunction getMediaSections(sdp, kind, direction) {\n  kind = kind || '.*';\n  direction = direction || '.*';\n  return sdp.split('\\r\\nm=').slice(1).map(function (mediaSection) {\n    return 'm=' + mediaSection;\n  }).filter(function (mediaSection) {\n    var kindPattern = new RegExp('m=' + kind, 'gm');\n    var directionPattern = new RegExp('a=' + direction, 'gm');\n    return kindPattern.test(mediaSection) && directionPattern.test(mediaSection);\n  });\n}\n/**\n * Get the Set of SSRCs announced in a MediaSection.\n * @param {string} mediaSection\n * @returns {Array<string>} ssrcs\n */\n\n\nfunction getMediaSectionSSRCs(mediaSection) {\n  return Array.from(getMatches('^a=ssrc:([0-9]+) +.*$', mediaSection));\n}\n/**\n * Get a Set of SSRCs for a MediaStreamTrack from a Unified Plan SDP.\n * @param {string} sdp - Unified Plan SDP\n * @param {string} trackId - MediaStreamTrack ID\n * @returns {Set<string>}\n */\n\n\nfunction getUnifiedPlanSSRCs(sdp, trackId) {\n  var mediaSections = getMediaSections(sdp);\n  var msidAttrRegExp = new RegExp('^a=msid:[^ ]+ +' + trackId + ' *$', 'gm');\n  var matchingMediaSections = mediaSections.filter(function (mediaSection) {\n    return mediaSection.match(msidAttrRegExp);\n  });\n  return new Set(flatMap(matchingMediaSections, getMediaSectionSSRCs));\n}\n/**\n * Get a Map from MediaStreamTrack IDs to SSRCs from an SDP.\n * @param {function(string): Set<string>} getTrackIds\n * @param {function(string, string): Set<string>} getSSRCs\n * @param {string} sdp - SDP\n * @returns {Map<string, Set<string>>} trackIdsToSSRCs\n */\n\n\nfunction getTrackIdsToSSRCs(getTrackIds, getSSRCs, sdp) {\n  return new Map(Array.from(getTrackIds(sdp)).map(function (trackId) {\n    return [trackId, getSSRCs(sdp, trackId)];\n  }));\n}\n/**\n * Get a Map from MediaStreamTrack IDs to SSRCs from a Plan B SDP.\n * @param {string} sdp - Plan B SDP\n * @returns {Map<string, Set<string>>} trackIdsToSSRCs\n */\n\n\nfunction getPlanBTrackIdsToSSRCs(sdp) {\n  return getTrackIdsToSSRCs(getPlanBTrackIds, getPlanBSSRCs, sdp);\n}\n/**\n * Get a Map from MediaStreamTrack IDs to SSRCs from a Plan B SDP.\n * @param {string} sdp - Plan B SDP\n * @returns {Map<string, Set<string>>} trackIdsToSSRCs\n */\n\n\nfunction getUnifiedPlanTrackIdsToSSRCs(sdp) {\n  return getTrackIdsToSSRCs(getUnifiedPlanTrackIds, getUnifiedPlanSSRCs, sdp);\n}\n/**\n * Update the mappings from MediaStreamTrack IDs to SSRCs as indicated by both\n * the Map from MediaStreamTrack IDs to SSRCs and the SDP itself. This method\n * ensures that SSRCs never change once announced.\n * @param {function(string): Map<string, Set<string>>} getTrackIdsToSSRCs\n * @param {Map<string, Set<string>>} trackIdsToSSRCs\n * @param {string} sdp - SDP\n * @returns {strinng} updatedSdp - updated SDP\n */\n\n\nfunction updateTrackIdsToSSRCs(getTrackIdsToSSRCs, trackIdsToSSRCs, sdp) {\n  var newTrackIdsToSSRCs = getTrackIdsToSSRCs(sdp);\n  var newSSRCsToOldSSRCs = new Map(); // NOTE(mroberts): First, update a=ssrc attributes.\n\n  newTrackIdsToSSRCs.forEach(function (ssrcs, trackId) {\n    if (!trackIdsToSSRCs.has(trackId)) {\n      trackIdsToSSRCs.set(trackId, ssrcs);\n      return;\n    }\n\n    var oldSSRCs = Array.from(trackIdsToSSRCs.get(trackId));\n    var newSSRCs = Array.from(ssrcs);\n    oldSSRCs.forEach(function (oldSSRC, i) {\n      var newSSRC = newSSRCs[i];\n      newSSRCsToOldSSRCs.set(newSSRC, oldSSRC);\n      var pattern = '^a=ssrc:' + newSSRC + ' (.*)$';\n      var replacement = 'a=ssrc:' + oldSSRC + ' $1';\n      sdp = sdp.replace(new RegExp(pattern, 'gm'), replacement);\n    });\n  }); // NOTE(mroberts): Then, update a=ssrc-group attributes.\n\n  var pattern = '^(a=ssrc-group:[^ ]+ +)(.*)$';\n  var matches = sdp.match(new RegExp(pattern, 'gm')) || [];\n  matches.forEach(function (line) {\n    var match = line.match(new RegExp(pattern));\n\n    if (!match) {\n      return;\n    }\n\n    var prefix = match[1];\n    var newSSRCs = match[2];\n    var oldSSRCs = newSSRCs.split(' ').map(function (newSSRC) {\n      var oldSSRC = newSSRCsToOldSSRCs.get(newSSRC);\n      return oldSSRC ? oldSSRC : newSSRC;\n    }).join(' ');\n    sdp = sdp.replace(match[0], prefix + oldSSRCs);\n  });\n  return sdp;\n}\n/**\n * Update the mappings from MediaStreamTrack IDs to SSRCs as indicated by both\n * the Map from MediaStreamTrack IDs to SSRCs and the Plan B SDP itself. This\n * method ensures that SSRCs never change once announced.\n * @param {Map<string, Set<string>>} trackIdsToSSRCs\n * @param {string} sdp - Plan B SDP\n * @returns {string} updatedSdp - updated Plan B SDP\n */\n\n\nfunction updatePlanBTrackIdsToSSRCs(trackIdsToSSRCs, sdp) {\n  return updateTrackIdsToSSRCs(getPlanBTrackIdsToSSRCs, trackIdsToSSRCs, sdp);\n}\n/**\n * Update the mappings from MediaStreamTrack IDs to SSRCs as indicated by both\n * the Map from MediaStreamTrack IDs to SSRCs and the Plan B SDP itself. This\n * method ensures that SSRCs never change once announced.\n * @param {Map<string, Set<string>>} trackIdsToSSRCs\n * @param {string} sdp - Plan B SDP\n * @returns {string} updatedSdp - updated Plan B SDP\n */\n\n\nfunction updateUnifiedPlanTrackIdsToSSRCs(trackIdsToSSRCs, sdp) {\n  return updateTrackIdsToSSRCs(getUnifiedPlanTrackIdsToSSRCs, trackIdsToSSRCs, sdp);\n}\n\nexports.getSdpFormat = getSdpFormat;\nexports.getMediaSections = getMediaSections;\nexports.getPlanBTrackIds = getPlanBTrackIds;\nexports.getUnifiedPlanTrackIds = getUnifiedPlanTrackIds;\nexports.getPlanBSSRCs = getPlanBSSRCs;\nexports.getUnifiedPlanSSRCs = getUnifiedPlanSSRCs;\nexports.updatePlanBTrackIdsToSSRCs = updatePlanBTrackIdsToSSRCs;\nexports.updateUnifiedPlanTrackIdsToSSRCs = updateUnifiedPlanTrackIdsToSSRCs;","map":{"version":3,"sources":["../../../lib/webrtc/util/sdp.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/* globals RTCPeerConnection, RTCRtpTransceiver */\n'use strict';\nvar flatMap = require('./').flatMap;\nvar guessBrowser = require('./').guessBrowser;\n// NOTE(mmalavalli): We cache Chrome's sdpSemantics support in order to prevent\n// instantiation of more than one RTCPeerConnection.\nvar isSdpSemanticsSupported = null;\n/**\n * Check if Chrome supports specifying sdpSemantics for an RTCPeerConnection.\n * @return {boolean}\n */\nfunction checkIfSdpSemanticsIsSupported() {\n    if (typeof isSdpSemanticsSupported === 'boolean') {\n        return isSdpSemanticsSupported;\n    }\n    if (typeof RTCPeerConnection === 'undefined') {\n        isSdpSemanticsSupported = false;\n        return isSdpSemanticsSupported;\n    }\n    try {\n        // eslint-disable-next-line no-new\n        new RTCPeerConnection({ sdpSemantics: 'foo' });\n        isSdpSemanticsSupported = false;\n    }\n    catch (e) {\n        isSdpSemanticsSupported = true;\n    }\n    return isSdpSemanticsSupported;\n}\n// NOTE(mmalavalli): We cache Chrome's SDP format in order to prevent\n// instantiation of more than one RTCPeerConnection.\nvar chromeSdpFormat = null;\n/**\n * Get Chrome's default SDP format.\n * @returns {'planb'|'unified'}\n */\nfunction getChromeDefaultSdpFormat() {\n    if (!chromeSdpFormat) {\n        if (typeof RTCPeerConnection !== 'undefined'\n            && 'addTransceiver' in RTCPeerConnection.prototype) {\n            try {\n                new RTCPeerConnection().addTransceiver('audio');\n                chromeSdpFormat = 'unified';\n            }\n            catch (e) {\n                chromeSdpFormat = 'planb';\n            }\n        }\n        else {\n            chromeSdpFormat = 'planb';\n        }\n    }\n    return chromeSdpFormat;\n}\n/**\n * Get Chrome's SDP format.\n * @param {'plan-b'|'unified-plan'} [sdpSemantics]\n * @returns {'planb'|'unified'}\n */\nfunction getChromeSdpFormat(sdpSemantics) {\n    if (!sdpSemantics || !checkIfSdpSemanticsIsSupported()) {\n        return getChromeDefaultSdpFormat();\n    }\n    return {\n        'plan-b': 'planb',\n        'unified-plan': 'unified'\n    }[sdpSemantics];\n}\n/**\n * Get Safari's default SDP format.\n * @returns {'planb'|'unified'}\n */\nfunction getSafariSdpFormat() {\n    return typeof RTCRtpTransceiver !== 'undefined'\n        && 'currentDirection' in RTCRtpTransceiver.prototype\n        ? 'unified'\n        : 'planb';\n}\n/**\n * Get the browser's default SDP format.\n * @param {'plan-b'|'unified-plan'} [sdpSemantics]\n * @returns {'planb'|'unified'}\n */\nfunction getSdpFormat(sdpSemantics) {\n    return {\n        chrome: getChromeSdpFormat(sdpSemantics),\n        firefox: 'unified',\n        safari: getSafariSdpFormat()\n    }[guessBrowser()] || null;\n}\n/**\n * Match a pattern across lines, returning the first capture group for any\n * matches.\n * @param {string} pattern\n * @param {string} lines\n * @returns {Set<string>} matches\n */\nfunction getMatches(pattern, lines) {\n    var matches = lines.match(new RegExp(pattern, 'gm')) || [];\n    return matches.reduce(function (results, line) {\n        var match = line.match(new RegExp(pattern));\n        return match ? results.add(match[1]) : results;\n    }, new Set());\n}\n/**\n * Get a Set of MediaStreamTrack IDs from an SDP.\n * @param {string} pattern\n * @param {string} sdp\n * @returns {Set<string>}\n */\nfunction getTrackIds(pattern, sdp) {\n    return getMatches(pattern, sdp);\n}\n/**\n * Get a Set of MediaStreamTrack IDs from a Plan B SDP.\n * @param {string} sdp - Plan B SDP\n * @returns {Set<string>} trackIds\n */\nfunction getPlanBTrackIds(sdp) {\n    return getTrackIds('^a=ssrc:[0-9]+ +msid:.+ +(.+) *$', sdp);\n}\n/**\n * Get a Set of MediaStreamTrack IDs from a Unified Plan SDP.\n * @param {string} sdp - Unified Plan SDP\n * @returns {Set<string>} trackIds\n */\nfunction getUnifiedPlanTrackIds(sdp) {\n    return getTrackIds('^a=msid:.+ +(.+) *$', sdp);\n}\n/**\n * Get a Set of SSRCs for a MediaStreamTrack from a Plan B SDP.\n * @param {string} sdp - Plan B SDP\n * @param {string} trackId - MediaStreamTrack ID\n * @returns {Set<string>}\n */\nfunction getPlanBSSRCs(sdp, trackId) {\n    var pattern = '^a=ssrc:([0-9]+) +msid:[^ ]+ +' + trackId + ' *$';\n    return getMatches(pattern, sdp);\n}\n/**\n * Get the m= sections of a particular kind and direction from an sdp.\n * @param {string} sdp -  sdp string\n * @param {string} [kind] - Pattern for matching kind\n * @param {string} [direction] - Pattern for matching direction\n * @returns {Array<string>} mediaSections\n */\nfunction getMediaSections(sdp, kind, direction) {\n    kind = kind || '.*';\n    direction = direction || '.*';\n    return sdp.split('\\r\\nm=').slice(1).map(function (mediaSection) {\n        return 'm=' + mediaSection;\n    }).filter(function (mediaSection) {\n        var kindPattern = new RegExp('m=' + kind, 'gm');\n        var directionPattern = new RegExp('a=' + direction, 'gm');\n        return kindPattern.test(mediaSection) && directionPattern.test(mediaSection);\n    });\n}\n/**\n * Get the Set of SSRCs announced in a MediaSection.\n * @param {string} mediaSection\n * @returns {Array<string>} ssrcs\n */\nfunction getMediaSectionSSRCs(mediaSection) {\n    return Array.from(getMatches('^a=ssrc:([0-9]+) +.*$', mediaSection));\n}\n/**\n * Get a Set of SSRCs for a MediaStreamTrack from a Unified Plan SDP.\n * @param {string} sdp - Unified Plan SDP\n * @param {string} trackId - MediaStreamTrack ID\n * @returns {Set<string>}\n */\nfunction getUnifiedPlanSSRCs(sdp, trackId) {\n    var mediaSections = getMediaSections(sdp);\n    var msidAttrRegExp = new RegExp('^a=msid:[^ ]+ +' + trackId + ' *$', 'gm');\n    var matchingMediaSections = mediaSections.filter(function (mediaSection) {\n        return mediaSection.match(msidAttrRegExp);\n    });\n    return new Set(flatMap(matchingMediaSections, getMediaSectionSSRCs));\n}\n/**\n * Get a Map from MediaStreamTrack IDs to SSRCs from an SDP.\n * @param {function(string): Set<string>} getTrackIds\n * @param {function(string, string): Set<string>} getSSRCs\n * @param {string} sdp - SDP\n * @returns {Map<string, Set<string>>} trackIdsToSSRCs\n */\nfunction getTrackIdsToSSRCs(getTrackIds, getSSRCs, sdp) {\n    return new Map(Array.from(getTrackIds(sdp)).map(function (trackId) {\n        return [trackId, getSSRCs(sdp, trackId)];\n    }));\n}\n/**\n * Get a Map from MediaStreamTrack IDs to SSRCs from a Plan B SDP.\n * @param {string} sdp - Plan B SDP\n * @returns {Map<string, Set<string>>} trackIdsToSSRCs\n */\nfunction getPlanBTrackIdsToSSRCs(sdp) {\n    return getTrackIdsToSSRCs(getPlanBTrackIds, getPlanBSSRCs, sdp);\n}\n/**\n * Get a Map from MediaStreamTrack IDs to SSRCs from a Plan B SDP.\n * @param {string} sdp - Plan B SDP\n * @returns {Map<string, Set<string>>} trackIdsToSSRCs\n */\nfunction getUnifiedPlanTrackIdsToSSRCs(sdp) {\n    return getTrackIdsToSSRCs(getUnifiedPlanTrackIds, getUnifiedPlanSSRCs, sdp);\n}\n/**\n * Update the mappings from MediaStreamTrack IDs to SSRCs as indicated by both\n * the Map from MediaStreamTrack IDs to SSRCs and the SDP itself. This method\n * ensures that SSRCs never change once announced.\n * @param {function(string): Map<string, Set<string>>} getTrackIdsToSSRCs\n * @param {Map<string, Set<string>>} trackIdsToSSRCs\n * @param {string} sdp - SDP\n * @returns {strinng} updatedSdp - updated SDP\n */\nfunction updateTrackIdsToSSRCs(getTrackIdsToSSRCs, trackIdsToSSRCs, sdp) {\n    var newTrackIdsToSSRCs = getTrackIdsToSSRCs(sdp);\n    var newSSRCsToOldSSRCs = new Map();\n    // NOTE(mroberts): First, update a=ssrc attributes.\n    newTrackIdsToSSRCs.forEach(function (ssrcs, trackId) {\n        if (!trackIdsToSSRCs.has(trackId)) {\n            trackIdsToSSRCs.set(trackId, ssrcs);\n            return;\n        }\n        var oldSSRCs = Array.from(trackIdsToSSRCs.get(trackId));\n        var newSSRCs = Array.from(ssrcs);\n        oldSSRCs.forEach(function (oldSSRC, i) {\n            var newSSRC = newSSRCs[i];\n            newSSRCsToOldSSRCs.set(newSSRC, oldSSRC);\n            var pattern = '^a=ssrc:' + newSSRC + ' (.*)$';\n            var replacement = 'a=ssrc:' + oldSSRC + ' $1';\n            sdp = sdp.replace(new RegExp(pattern, 'gm'), replacement);\n        });\n    });\n    // NOTE(mroberts): Then, update a=ssrc-group attributes.\n    var pattern = '^(a=ssrc-group:[^ ]+ +)(.*)$';\n    var matches = sdp.match(new RegExp(pattern, 'gm')) || [];\n    matches.forEach(function (line) {\n        var match = line.match(new RegExp(pattern));\n        if (!match) {\n            return;\n        }\n        var prefix = match[1];\n        var newSSRCs = match[2];\n        var oldSSRCs = newSSRCs.split(' ').map(function (newSSRC) {\n            var oldSSRC = newSSRCsToOldSSRCs.get(newSSRC);\n            return oldSSRC ? oldSSRC : newSSRC;\n        }).join(' ');\n        sdp = sdp.replace(match[0], prefix + oldSSRCs);\n    });\n    return sdp;\n}\n/**\n * Update the mappings from MediaStreamTrack IDs to SSRCs as indicated by both\n * the Map from MediaStreamTrack IDs to SSRCs and the Plan B SDP itself. This\n * method ensures that SSRCs never change once announced.\n * @param {Map<string, Set<string>>} trackIdsToSSRCs\n * @param {string} sdp - Plan B SDP\n * @returns {string} updatedSdp - updated Plan B SDP\n */\nfunction updatePlanBTrackIdsToSSRCs(trackIdsToSSRCs, sdp) {\n    return updateTrackIdsToSSRCs(getPlanBTrackIdsToSSRCs, trackIdsToSSRCs, sdp);\n}\n/**\n * Update the mappings from MediaStreamTrack IDs to SSRCs as indicated by both\n * the Map from MediaStreamTrack IDs to SSRCs and the Plan B SDP itself. This\n * method ensures that SSRCs never change once announced.\n * @param {Map<string, Set<string>>} trackIdsToSSRCs\n * @param {string} sdp - Plan B SDP\n * @returns {string} updatedSdp - updated Plan B SDP\n */\nfunction updateUnifiedPlanTrackIdsToSSRCs(trackIdsToSSRCs, sdp) {\n    return updateTrackIdsToSSRCs(getUnifiedPlanTrackIdsToSSRCs, trackIdsToSSRCs, sdp);\n}\nexports.getSdpFormat = getSdpFormat;\nexports.getMediaSections = getMediaSections;\nexports.getPlanBTrackIds = getPlanBTrackIds;\nexports.getUnifiedPlanTrackIds = getUnifiedPlanTrackIds;\nexports.getPlanBSSRCs = getPlanBSSRCs;\nexports.getUnifiedPlanSSRCs = getUnifiedPlanSSRCs;\nexports.updatePlanBTrackIdsToSSRCs = updatePlanBTrackIdsToSSRCs;\nexports.updateUnifiedPlanTrackIdsToSSRCs = updateUnifiedPlanTrackIdsToSSRCs;\n//# sourceMappingURL=sdp.js.map"]},"metadata":{},"sourceType":"script"}