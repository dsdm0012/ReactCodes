{"ast":null,"code":"/* globals RTCPeerConnection, RTCSessionDescription */\n'use strict';\n\nvar EventTarget = require('../util/eventtarget');\n\nvar inherits = require('../../vendor/inherits');\n\nvar Latch = require('../util/latch');\n\nvar sdpUtils = require('../util/sdp');\n\nvar util = require('../util');\n\nvar isUnifiedPlan = sdpUtils.getSdpFormat() === 'unified';\nvar updateTrackIdsToSSRCs = isUnifiedPlan ? sdpUtils.updateUnifiedPlanTrackIdsToSSRCs : sdpUtils.updatePlanBTrackIdsToSSRCs;\n\nfunction SafariRTCPeerConnection(configuration) {\n  if (!(this instanceof SafariRTCPeerConnection)) {\n    return new SafariRTCPeerConnection(configuration);\n  }\n\n  EventTarget.call(this);\n  util.interceptEvent(this, 'datachannel');\n  util.interceptEvent(this, 'iceconnectionstatechange');\n  util.interceptEvent(this, 'signalingstatechange');\n  util.interceptEvent(this, 'track');\n  var peerConnection = new RTCPeerConnection(configuration);\n  Object.defineProperties(this, {\n    _appliedTracksToSSRCs: {\n      value: new Map(),\n      writable: true\n    },\n    _audioTransceiver: {\n      value: null,\n      writable: true\n    },\n    _isClosed: {\n      value: false,\n      writable: true\n    },\n    _peerConnection: {\n      value: peerConnection\n    },\n    _pendingLocalOffer: {\n      value: null,\n      writable: true\n    },\n    _pendingRemoteOffer: {\n      value: null,\n      writable: true\n    },\n    _rolledBackTracksToSSRCs: {\n      value: new Map(),\n      writable: true\n    },\n    _signalingStateLatch: {\n      value: new Latch()\n    },\n    _tracksToSSRCs: {\n      value: new Map(),\n      writable: true\n    },\n    _videoTransceiver: {\n      value: null,\n      writable: true\n    },\n    localDescription: {\n      enumerable: true,\n      get: function get() {\n        return this._pendingLocalOffer || this._peerConnection.localDescription;\n      }\n    },\n    iceConnectionState: {\n      enumerable: true,\n      get: function get() {\n        return this._isClosed ? 'closed' : this._peerConnection.iceConnectionState;\n      }\n    },\n    iceGatheringState: {\n      enumerable: true,\n      get: function get() {\n        return this._isClosed ? 'complete' : this._peerConnection.iceGatheringState;\n      }\n    },\n    remoteDescription: {\n      enumerable: true,\n      get: function get() {\n        return this._pendingRemoteOffer || this._peerConnection.remoteDescription;\n      }\n    },\n    signalingState: {\n      enumerable: true,\n      get: function get() {\n        if (this._isClosed) {\n          return 'closed';\n        } else if (this._pendingLocalOffer) {\n          return 'have-local-offer';\n        } else if (this._pendingRemoteOffer) {\n          return 'have-remote-offer';\n        }\n\n        return this._peerConnection.signalingState;\n      }\n    }\n  });\n  var self = this;\n  peerConnection.addEventListener('datachannel', function ondatachannel(event) {\n    shimDataChannel(event.channel);\n    self.dispatchEvent(event);\n  });\n  peerConnection.addEventListener('iceconnectionstatechange', function oniceconnectionstatechange() {\n    if (self._isClosed) {\n      return;\n    }\n\n    self.dispatchEvent.apply(self, arguments);\n  });\n  peerConnection.addEventListener('signalingstatechange', function onsignalingstatechange() {\n    if (self._isClosed) {\n      return;\n    }\n\n    if (peerConnection.signalingState === 'stable') {\n      self._appliedTracksToSSRCs = new Map(self._tracksToSSRCs);\n    }\n\n    if (!self._pendingLocalOffer && !self._pendingRemoteOffer) {\n      self.dispatchEvent.apply(self, arguments);\n    }\n  }); // NOTE(syerrapragada): This ensures that SafariRTCPeerConnection's \"remoteDescription\", when accessed\n  // in an RTCTrackEvent listener, will point to the underlying RTCPeerConnection's\n  // \"remoteDescription\". Before this fix, this was still pointing to \"_pendingRemoteOffer\"\n  // even though a new remote RTCSessionDescription had already been applied.\n\n  peerConnection.addEventListener('track', function ontrack(event) {\n    self._pendingRemoteOffer = null;\n    self.dispatchEvent(event);\n  });\n  util.proxyProperties(RTCPeerConnection.prototype, this, peerConnection);\n}\n\ninherits(SafariRTCPeerConnection, EventTarget);\n\nSafariRTCPeerConnection.prototype.addIceCandidate = function addIceCandidate(candidate) {\n  var self = this;\n\n  if (this.signalingState === 'have-remote-offer') {\n    return this._signalingStateLatch.when('low').then(function signalingStatesResolved() {\n      return self._peerConnection.addIceCandidate(candidate);\n    });\n  }\n\n  return this._peerConnection.addIceCandidate(candidate);\n};\n\nSafariRTCPeerConnection.prototype.createOffer = function createOffer(options) {\n  options = Object.assign({}, options);\n  var self = this; // NOTE(mroberts): In general, this is not the way to do this; however, it's\n  // good enough for our application.\n\n  if (options.offerToReceiveVideo && !this._audioTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'audio'))) {\n    delete options.offerToReceiveAudio;\n\n    try {\n      this._audioTransceiver = isUnifiedPlan ? this.addTransceiver('audio', {\n        direction: 'recvonly'\n      }) : this.addTransceiver('audio');\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n\n  if (options.offerToReceiveVideo && !this._videoTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'video'))) {\n    delete options.offerToReceiveVideo;\n\n    try {\n      this._videoTransceiver = isUnifiedPlan ? this.addTransceiver('video', {\n        direction: 'recvonly'\n      }) : this.addTransceiver('video');\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n\n  return this._peerConnection.createOffer(options).then(function (offer) {\n    // NOTE(mmalavalli): If createOffer() is called immediately after rolling back,\n    // then we no longer need to retain the rolled back tracks to SSRCs Map.\n    self._rolledBackTracksToSSRCs.clear();\n\n    return new RTCSessionDescription({\n      type: offer.type,\n      sdp: updateTrackIdsToSSRCs(self._tracksToSSRCs, offer.sdp)\n    });\n  });\n};\n\nSafariRTCPeerConnection.prototype.createAnswer = function createAnswer(options) {\n  var self = this;\n\n  if (this._pendingRemoteOffer) {\n    return this._peerConnection.setRemoteDescription(this._pendingRemoteOffer).then(function setRemoteDescriptionSucceeded() {\n      self._signalingStateLatch.lower();\n\n      return self._peerConnection.createAnswer();\n    }).then(function createAnswerSucceeded(answer) {\n      self._pendingRemoteOffer = null; // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n      // longer need to retain the rolled back tracks to SSRCs Map.\n\n      self._rolledBackTracksToSSRCs.clear();\n\n      return isUnifiedPlan ? new RTCSessionDescription({\n        type: answer.type,\n        sdp: updateTrackIdsToSSRCs(self._tracksToSSRCs, answer.sdp)\n      }) : answer;\n    }, function setRemoteDescriptionOrCreateAnswerFailed(error) {\n      self._pendingRemoteOffer = null;\n      throw error;\n    });\n  }\n\n  return this._peerConnection.createAnswer(options).then(function createAnswerSucceeded(answer) {\n    // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n    // longer need to retain the rolled back tracks to SSRCs Map.\n    self._rolledBackTracksToSSRCs.clear();\n\n    return isUnifiedPlan ? new RTCSessionDescription({\n      type: answer.type,\n      sdp: updateTrackIdsToSSRCs(self._tracksToSSRCs, answer.sdp)\n    }) : answer;\n  });\n};\n\nSafariRTCPeerConnection.prototype.createDataChannel = function createDataChannel(label, dataChannelDict) {\n  var dataChannel = this._peerConnection.createDataChannel(label, dataChannelDict);\n\n  shimDataChannel(dataChannel);\n  return dataChannel;\n};\n\nSafariRTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n  sender.replaceTrack(null);\n\n  this._peerConnection.removeTrack(sender);\n};\n\nSafariRTCPeerConnection.prototype.setLocalDescription = function setLocalDescription(description) {\n  // NOTE(mmalavalli): If setLocalDescription() is called immediately after rolling back,\n  // then we need to restore the rolled back tracks to SSRCs Map.\n  if (this._rolledBackTracksToSSRCs.size > 0) {\n    this._tracksToSSRCs = new Map(this._rolledBackTracksToSSRCs);\n\n    this._rolledBackTracksToSSRCs.clear();\n  }\n\n  return setDescription(this, true, description);\n};\n\nSafariRTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(description) {\n  // NOTE(mmalavalli): If setRemoteDescription() is called immediately after rolling back,\n  // then we no longer need to retain the rolled back tracks to SSRCs Map.\n  this._rolledBackTracksToSSRCs.clear();\n\n  return setDescription(this, false, description);\n};\n\nSafariRTCPeerConnection.prototype.close = function close() {\n  if (this._isClosed) {\n    return;\n  }\n\n  this._isClosed = true;\n\n  this._peerConnection.close();\n\n  var self = this;\n  setTimeout(function () {\n    self.dispatchEvent(new Event('iceconnectionstatechange'));\n    self.dispatchEvent(new Event('signalingstatechange'));\n  });\n};\n\nutil.delegateMethods(RTCPeerConnection.prototype, SafariRTCPeerConnection.prototype, '_peerConnection');\n\nfunction setDescription(peerConnection, local, description) {\n  function setPendingLocalOffer(offer) {\n    if (local) {\n      peerConnection._pendingLocalOffer = offer;\n    } else {\n      peerConnection._pendingRemoteOffer = offer;\n    }\n  }\n\n  function clearPendingLocalOffer() {\n    if (local) {\n      peerConnection._pendingLocalOffer = null;\n    } else {\n      peerConnection._pendingRemoteOffer = null;\n    }\n  }\n\n  var pendingLocalOffer = local ? peerConnection._pendingLocalOffer : peerConnection._pendingRemoteOffer;\n  var pendingRemoteOffer = local ? peerConnection._pendingRemoteOffer : peerConnection._pendingLocalOffer;\n  var intermediateState = local ? 'have-local-offer' : 'have-remote-offer';\n  var setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';\n\n  if (!local && pendingRemoteOffer && description.type === 'answer') {\n    return setRemoteAnswer(peerConnection, description);\n  } else if (description.type === 'offer') {\n    if (peerConnection.signalingState !== intermediateState && peerConnection.signalingState !== 'stable') {\n      return Promise.reject(new Error('Cannot set ' + (local ? 'local' : 'remote') + ' offer in state ' + peerConnection.signalingState));\n    }\n\n    if (!pendingLocalOffer && peerConnection._signalingStateLatch.state === 'low') {\n      peerConnection._signalingStateLatch.raise();\n    }\n\n    var previousSignalingState = peerConnection.signalingState;\n    setPendingLocalOffer(description); // Only dispatch a signalingstatechange event if we transitioned.\n\n    if (peerConnection.signalingState !== previousSignalingState) {\n      return Promise.resolve().then(function dispatchSignalingStateChangeEvent() {\n        peerConnection.dispatchEvent(new Event('signalingstatechange'));\n      });\n    }\n\n    return Promise.resolve();\n  } else if (description.type === 'rollback') {\n    if (peerConnection.signalingState !== intermediateState) {\n      return Promise.reject(new Error('Cannot rollback ' + (local ? 'local' : 'remote') + ' description in ' + peerConnection.signalingState));\n    }\n\n    clearPendingLocalOffer(); // NOTE(mmalavalli): We store the rolled back tracks to SSRCs Map here in case\n    // setLocalDescription() is called immediately aftera rollback (without calling\n    // createOffer() or createAnswer()), in which case this roll back is not due to\n    // a glare scenario and this Map should be restored.\n\n    peerConnection._rolledBackTracksToSSRCs = new Map(peerConnection._tracksToSSRCs);\n    peerConnection._tracksToSSRCs = new Map(peerConnection._appliedTracksToSSRCs);\n    return Promise.resolve().then(function dispatchSignalingStateChangeEvent() {\n      peerConnection.dispatchEvent(new Event('signalingstatechange'));\n    });\n  }\n\n  return peerConnection._peerConnection[setLocalDescription](description);\n}\n\nfunction setRemoteAnswer(peerConnection, answer) {\n  var pendingLocalOffer = peerConnection._pendingLocalOffer;\n  return peerConnection._peerConnection.setLocalDescription(pendingLocalOffer).then(function setLocalOfferSucceeded() {\n    peerConnection._pendingLocalOffer = null;\n    return peerConnection.setRemoteDescription(answer);\n  }).then(function setRemoteAnswerSucceeded() {\n    peerConnection._signalingStateLatch.lower();\n  });\n}\n/**\n * Whether a SafariRTCPeerConnection has any RTCRtpReceivers(s) for the given\n * MediaStreamTrack kind.\n * @param {SafariRTCPeerConnection} peerConnection\n * @param {'audio' | 'video'} kind\n * @returns {boolean}\n */\n\n\nfunction hasReceiversForTracksOfKind(peerConnection, kind) {\n  return !!peerConnection.getTransceivers().find(function (transceiver) {\n    return transceiver.receiver && transceiver.receiver.track && transceiver.receiver.track.kind === kind;\n  });\n}\n/**\n * Shim an RTCDataChannel. This function mutates the RTCDataChannel.\n * @param {RTCDataChannel} dataChannel\n * @returns {RTCDataChannel}\n */\n\n\nfunction shimDataChannel(dataChannel) {\n  return Object.defineProperties(dataChannel, {\n    maxPacketLifeTime: {\n      value: dataChannel.maxPacketLifeTime === 65535 ? null : dataChannel.maxPacketLifeTime\n    },\n    maxRetransmits: {\n      value: dataChannel.maxRetransmits === 65535 ? null : dataChannel.maxRetransmits\n    }\n  });\n}\n\nmodule.exports = SafariRTCPeerConnection;","map":{"version":3,"sources":["../../../lib/webrtc/rtcpeerconnection/safari.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/* globals RTCPeerConnection, RTCSessionDescription */\n'use strict';\nvar EventTarget = require('../util/eventtarget');\nvar inherits = require('../../vendor/inherits');\nvar Latch = require('../util/latch');\nvar sdpUtils = require('../util/sdp');\nvar util = require('../util');\nvar isUnifiedPlan = sdpUtils.getSdpFormat() === 'unified';\nvar updateTrackIdsToSSRCs = isUnifiedPlan\n    ? sdpUtils.updateUnifiedPlanTrackIdsToSSRCs\n    : sdpUtils.updatePlanBTrackIdsToSSRCs;\nfunction SafariRTCPeerConnection(configuration) {\n    if (!(this instanceof SafariRTCPeerConnection)) {\n        return new SafariRTCPeerConnection(configuration);\n    }\n    EventTarget.call(this);\n    util.interceptEvent(this, 'datachannel');\n    util.interceptEvent(this, 'iceconnectionstatechange');\n    util.interceptEvent(this, 'signalingstatechange');\n    util.interceptEvent(this, 'track');\n    var peerConnection = new RTCPeerConnection(configuration);\n    Object.defineProperties(this, {\n        _appliedTracksToSSRCs: {\n            value: new Map(),\n            writable: true\n        },\n        _audioTransceiver: {\n            value: null,\n            writable: true\n        },\n        _isClosed: {\n            value: false,\n            writable: true\n        },\n        _peerConnection: {\n            value: peerConnection\n        },\n        _pendingLocalOffer: {\n            value: null,\n            writable: true\n        },\n        _pendingRemoteOffer: {\n            value: null,\n            writable: true\n        },\n        _rolledBackTracksToSSRCs: {\n            value: new Map(),\n            writable: true\n        },\n        _signalingStateLatch: {\n            value: new Latch()\n        },\n        _tracksToSSRCs: {\n            value: new Map(),\n            writable: true\n        },\n        _videoTransceiver: {\n            value: null,\n            writable: true\n        },\n        localDescription: {\n            enumerable: true,\n            get: function () {\n                return this._pendingLocalOffer || this._peerConnection.localDescription;\n            }\n        },\n        iceConnectionState: {\n            enumerable: true,\n            get: function () {\n                return this._isClosed ? 'closed' : this._peerConnection.iceConnectionState;\n            }\n        },\n        iceGatheringState: {\n            enumerable: true,\n            get: function () {\n                return this._isClosed ? 'complete' : this._peerConnection.iceGatheringState;\n            }\n        },\n        remoteDescription: {\n            enumerable: true,\n            get: function () {\n                return this._pendingRemoteOffer || this._peerConnection.remoteDescription;\n            }\n        },\n        signalingState: {\n            enumerable: true,\n            get: function () {\n                if (this._isClosed) {\n                    return 'closed';\n                }\n                else if (this._pendingLocalOffer) {\n                    return 'have-local-offer';\n                }\n                else if (this._pendingRemoteOffer) {\n                    return 'have-remote-offer';\n                }\n                return this._peerConnection.signalingState;\n            }\n        }\n    });\n    var self = this;\n    peerConnection.addEventListener('datachannel', function ondatachannel(event) {\n        shimDataChannel(event.channel);\n        self.dispatchEvent(event);\n    });\n    peerConnection.addEventListener('iceconnectionstatechange', function oniceconnectionstatechange() {\n        if (self._isClosed) {\n            return;\n        }\n        self.dispatchEvent.apply(self, arguments);\n    });\n    peerConnection.addEventListener('signalingstatechange', function onsignalingstatechange() {\n        if (self._isClosed) {\n            return;\n        }\n        if (peerConnection.signalingState === 'stable') {\n            self._appliedTracksToSSRCs = new Map(self._tracksToSSRCs);\n        }\n        if (!self._pendingLocalOffer && !self._pendingRemoteOffer) {\n            self.dispatchEvent.apply(self, arguments);\n        }\n    });\n    // NOTE(syerrapragada): This ensures that SafariRTCPeerConnection's \"remoteDescription\", when accessed\n    // in an RTCTrackEvent listener, will point to the underlying RTCPeerConnection's\n    // \"remoteDescription\". Before this fix, this was still pointing to \"_pendingRemoteOffer\"\n    // even though a new remote RTCSessionDescription had already been applied.\n    peerConnection.addEventListener('track', function ontrack(event) {\n        self._pendingRemoteOffer = null;\n        self.dispatchEvent(event);\n    });\n    util.proxyProperties(RTCPeerConnection.prototype, this, peerConnection);\n}\ninherits(SafariRTCPeerConnection, EventTarget);\nSafariRTCPeerConnection.prototype.addIceCandidate = function addIceCandidate(candidate) {\n    var self = this;\n    if (this.signalingState === 'have-remote-offer') {\n        return this._signalingStateLatch.when('low').then(function signalingStatesResolved() {\n            return self._peerConnection.addIceCandidate(candidate);\n        });\n    }\n    return this._peerConnection.addIceCandidate(candidate);\n};\nSafariRTCPeerConnection.prototype.createOffer = function createOffer(options) {\n    options = Object.assign({}, options);\n    var self = this;\n    // NOTE(mroberts): In general, this is not the way to do this; however, it's\n    // good enough for our application.\n    if (options.offerToReceiveVideo && !this._audioTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'audio'))) {\n        delete options.offerToReceiveAudio;\n        try {\n            this._audioTransceiver = isUnifiedPlan\n                ? this.addTransceiver('audio', { direction: 'recvonly' })\n                : this.addTransceiver('audio');\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    }\n    if (options.offerToReceiveVideo && !this._videoTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'video'))) {\n        delete options.offerToReceiveVideo;\n        try {\n            this._videoTransceiver = isUnifiedPlan\n                ? this.addTransceiver('video', { direction: 'recvonly' })\n                : this.addTransceiver('video');\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    }\n    return this._peerConnection.createOffer(options).then(function (offer) {\n        // NOTE(mmalavalli): If createOffer() is called immediately after rolling back,\n        // then we no longer need to retain the rolled back tracks to SSRCs Map.\n        self._rolledBackTracksToSSRCs.clear();\n        return new RTCSessionDescription({\n            type: offer.type,\n            sdp: updateTrackIdsToSSRCs(self._tracksToSSRCs, offer.sdp)\n        });\n    });\n};\nSafariRTCPeerConnection.prototype.createAnswer = function createAnswer(options) {\n    var self = this;\n    if (this._pendingRemoteOffer) {\n        return this._peerConnection.setRemoteDescription(this._pendingRemoteOffer).then(function setRemoteDescriptionSucceeded() {\n            self._signalingStateLatch.lower();\n            return self._peerConnection.createAnswer();\n        }).then(function createAnswerSucceeded(answer) {\n            self._pendingRemoteOffer = null;\n            // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n            // longer need to retain the rolled back tracks to SSRCs Map.\n            self._rolledBackTracksToSSRCs.clear();\n            return isUnifiedPlan ? new RTCSessionDescription({\n                type: answer.type,\n                sdp: updateTrackIdsToSSRCs(self._tracksToSSRCs, answer.sdp)\n            }) : answer;\n        }, function setRemoteDescriptionOrCreateAnswerFailed(error) {\n            self._pendingRemoteOffer = null;\n            throw error;\n        });\n    }\n    return this._peerConnection.createAnswer(options).then(function createAnswerSucceeded(answer) {\n        // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n        // longer need to retain the rolled back tracks to SSRCs Map.\n        self._rolledBackTracksToSSRCs.clear();\n        return isUnifiedPlan ? new RTCSessionDescription({\n            type: answer.type,\n            sdp: updateTrackIdsToSSRCs(self._tracksToSSRCs, answer.sdp)\n        }) : answer;\n    });\n};\nSafariRTCPeerConnection.prototype.createDataChannel = function createDataChannel(label, dataChannelDict) {\n    var dataChannel = this._peerConnection.createDataChannel(label, dataChannelDict);\n    shimDataChannel(dataChannel);\n    return dataChannel;\n};\nSafariRTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    sender.replaceTrack(null);\n    this._peerConnection.removeTrack(sender);\n};\nSafariRTCPeerConnection.prototype.setLocalDescription = function setLocalDescription(description) {\n    // NOTE(mmalavalli): If setLocalDescription() is called immediately after rolling back,\n    // then we need to restore the rolled back tracks to SSRCs Map.\n    if (this._rolledBackTracksToSSRCs.size > 0) {\n        this._tracksToSSRCs = new Map(this._rolledBackTracksToSSRCs);\n        this._rolledBackTracksToSSRCs.clear();\n    }\n    return setDescription(this, true, description);\n};\nSafariRTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(description) {\n    // NOTE(mmalavalli): If setRemoteDescription() is called immediately after rolling back,\n    // then we no longer need to retain the rolled back tracks to SSRCs Map.\n    this._rolledBackTracksToSSRCs.clear();\n    return setDescription(this, false, description);\n};\nSafariRTCPeerConnection.prototype.close = function close() {\n    if (this._isClosed) {\n        return;\n    }\n    this._isClosed = true;\n    this._peerConnection.close();\n    var self = this;\n    setTimeout(function () {\n        self.dispatchEvent(new Event('iceconnectionstatechange'));\n        self.dispatchEvent(new Event('signalingstatechange'));\n    });\n};\nutil.delegateMethods(RTCPeerConnection.prototype, SafariRTCPeerConnection.prototype, '_peerConnection');\nfunction setDescription(peerConnection, local, description) {\n    function setPendingLocalOffer(offer) {\n        if (local) {\n            peerConnection._pendingLocalOffer = offer;\n        }\n        else {\n            peerConnection._pendingRemoteOffer = offer;\n        }\n    }\n    function clearPendingLocalOffer() {\n        if (local) {\n            peerConnection._pendingLocalOffer = null;\n        }\n        else {\n            peerConnection._pendingRemoteOffer = null;\n        }\n    }\n    var pendingLocalOffer = local ? peerConnection._pendingLocalOffer : peerConnection._pendingRemoteOffer;\n    var pendingRemoteOffer = local ? peerConnection._pendingRemoteOffer : peerConnection._pendingLocalOffer;\n    var intermediateState = local ? 'have-local-offer' : 'have-remote-offer';\n    var setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';\n    if (!local && pendingRemoteOffer && description.type === 'answer') {\n        return setRemoteAnswer(peerConnection, description);\n    }\n    else if (description.type === 'offer') {\n        if (peerConnection.signalingState !== intermediateState && peerConnection.signalingState !== 'stable') {\n            return Promise.reject(new Error('Cannot set ' + (local ? 'local' : 'remote') +\n                ' offer in state ' + peerConnection.signalingState));\n        }\n        if (!pendingLocalOffer && peerConnection._signalingStateLatch.state === 'low') {\n            peerConnection._signalingStateLatch.raise();\n        }\n        var previousSignalingState = peerConnection.signalingState;\n        setPendingLocalOffer(description);\n        // Only dispatch a signalingstatechange event if we transitioned.\n        if (peerConnection.signalingState !== previousSignalingState) {\n            return Promise.resolve().then(function dispatchSignalingStateChangeEvent() {\n                peerConnection.dispatchEvent(new Event('signalingstatechange'));\n            });\n        }\n        return Promise.resolve();\n    }\n    else if (description.type === 'rollback') {\n        if (peerConnection.signalingState !== intermediateState) {\n            return Promise.reject(new Error('Cannot rollback ' +\n                (local ? 'local' : 'remote') + ' description in ' + peerConnection.signalingState));\n        }\n        clearPendingLocalOffer();\n        // NOTE(mmalavalli): We store the rolled back tracks to SSRCs Map here in case\n        // setLocalDescription() is called immediately aftera rollback (without calling\n        // createOffer() or createAnswer()), in which case this roll back is not due to\n        // a glare scenario and this Map should be restored.\n        peerConnection._rolledBackTracksToSSRCs = new Map(peerConnection._tracksToSSRCs);\n        peerConnection._tracksToSSRCs = new Map(peerConnection._appliedTracksToSSRCs);\n        return Promise.resolve().then(function dispatchSignalingStateChangeEvent() {\n            peerConnection.dispatchEvent(new Event('signalingstatechange'));\n        });\n    }\n    return peerConnection._peerConnection[setLocalDescription](description);\n}\nfunction setRemoteAnswer(peerConnection, answer) {\n    var pendingLocalOffer = peerConnection._pendingLocalOffer;\n    return peerConnection._peerConnection.setLocalDescription(pendingLocalOffer).then(function setLocalOfferSucceeded() {\n        peerConnection._pendingLocalOffer = null;\n        return peerConnection.setRemoteDescription(answer);\n    }).then(function setRemoteAnswerSucceeded() {\n        peerConnection._signalingStateLatch.lower();\n    });\n}\n/**\n * Whether a SafariRTCPeerConnection has any RTCRtpReceivers(s) for the given\n * MediaStreamTrack kind.\n * @param {SafariRTCPeerConnection} peerConnection\n * @param {'audio' | 'video'} kind\n * @returns {boolean}\n */\nfunction hasReceiversForTracksOfKind(peerConnection, kind) {\n    return !!peerConnection.getTransceivers().find(function (transceiver) {\n        return transceiver.receiver && transceiver.receiver.track && transceiver.receiver.track.kind === kind;\n    });\n}\n/**\n * Shim an RTCDataChannel. This function mutates the RTCDataChannel.\n * @param {RTCDataChannel} dataChannel\n * @returns {RTCDataChannel}\n */\nfunction shimDataChannel(dataChannel) {\n    return Object.defineProperties(dataChannel, {\n        maxPacketLifeTime: {\n            value: dataChannel.maxPacketLifeTime === 65535\n                ? null\n                : dataChannel.maxPacketLifeTime\n        },\n        maxRetransmits: {\n            value: dataChannel.maxRetransmits === 65535\n                ? null\n                : dataChannel.maxRetransmits\n        }\n    });\n}\nmodule.exports = SafariRTCPeerConnection;\n//# sourceMappingURL=safari.js.map"]},"metadata":{},"sourceType":"script"}